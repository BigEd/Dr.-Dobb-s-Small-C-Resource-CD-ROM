<HTML>
<!-- 	Dr. Dobb's Small C Resource CD-ROM Compilation (c) 1997 Dr. Dobb's Journal, M&T Publishing, Inc., a subsidiary of Miller Freeman, Inc. All rights reserved.
-->
<CENTER>
<B><H1>
C NOTEBOOK:<p>
SELECTIONS FROM DR. DOBB'S FIRST C COLUMN <p>
</H1>
by Anthony Skjellum 
</CENTER>
</B>
             
 
<i>This chapter is based on a set of columns that appeared in Dr. Dobb's Journal #84 to # 100 (September 1983 to February 1984). The original ten columns, entitled &quot;C/Unix Programmer's Notebook,&quot; covered both the C language and the Unix operating system. This chapter contains programs and discussions from nine of the columns related specifically to C.</i><p> 

The C language was already popular when the first C/Unix column appeared. Today, it is even more widely used. Yet despite the proliferation of C books in bookstores, most of these books are for beginners. That means new users have virtually no source for additional information, once they have exhausted the value of beginning books. The material in this chapter is tutorial and therefore should prove interesting to both advanced novices and more seasoned users. I have reorganized the columns by topic to improve readability, added several footnotes and comments, and made some corrections and additions. <p>

What follows is not just a set of useful programs and documentation. Mostly, it is a discussion about the C language, including programming style, language extensions, and runtime libraries. Importantly, a significant percentage of the commentary came from readers who responded to my comments and proposals with their own often different ideas and conceptions. In retrospect, I am convinced that this interaction is what makes the following pages both informative and interesting. <p>

<CENTER>
<B> 
Part 1: LAYOUT OF C CODE <p>
</B>
</CENTER>
 
The C language is one of the few standards that applies to a wide variety of computers. <i>The C Programming Language</i>, by Brian W. Kernighan and Dennis B. Ritchie (Prentice-Hall, 1978), defines a standard language and runtime library, and also discusses implementation differences in several minicomputer implementations. The book does not define a standard for the layout and presentation of C code, considering this as a matter of personal taste. After reading a lot of C programs from many sources, I have decided that programmers pay too little attention to this aspect of C programming. In this section, I will explain the problem, suggest a standard for C code layout, and propose a possible solution. <p>

Whenever I receive a new piece of C code, I always check to see how the programmer has presented the code. A clear presentation with many comments and an uncluttered look is important for maintaining such code and for aiding other programmers who must understand it. More often than not, the code looks something like the following: <p>
<PRE> 
     main(){printf(&quot;Hello world\n&quot;); 
     } <p>
</PRE> 
In this case the programmer hasn't formatted the program properly. This makes it difficult to follow the inherent block structure of the language. The cluttered look that results from improper indentation is often also accompanied by a paucity of comments. The resulting code is usually hard to understand, improve, or debug. <p>

The style presented in Kernighan and Ritchie (K&amp;R) is consistent, but not optimal, since it does not present blocks and block nesting in the clearest way possible. For example, an if...else loop appears as follows: <p>
<PRE>  
     if ((fp = fopen(argv[1],&quot;r&quot;)) == NULL) { /* not found      */ 
           fprintf(stderr,&quot;%s not found\n&quot;,argv[1]); 
           exit(1); 
     } else {                /* the file is present */ 
           fprintf(stderr,&quot;%s is on-line\n&quot;,argv[1]); 
           fclose(fp); <p>
     } 
</PRE>  
Using the same fragment, I prefer the following format: <p>
<PRE>  
     if((fp = fopen(argv[1],&quot;r&quot;)) == NULL) /* not found */ 
     { 
             fprintf(stderr,&quot;%s not found\n&quot;,argv[1]); 
             exit(1); /* exit with error status 1 */ 
     } 
     else    /* the file is present */ 
     { 
             fprintf(stderr,&quot;%s is on-line\n&quot;,argv[1]); 

             fclose(fp); /* close the file */ 
     } <p>
</PRE>  
In the second form, eight-space (standard) tabs are used for indentation (as opposed to the six-space indentation used by the book). Braces are almost always on their own lines and the lowest level braces appear at the left margin. Braces indicate the nesting level of the expression that invoked them, and their contents are themselves indented an additional level. Only one statement is placed on a line, and comments are added liberally to make the code more  understandable. Finally, the space used by K&amp;R between keywords and their parenthetical expressions is omitted. (Note: In the amended standard discussed below, this space is optional but recommended. Originally, I didn't think a space in this context added readability, so I recommended that it be omitted (see Table 3-1)).<p> 

This example illustrates the layout standard I am proposing, summarized in Table 3-1. The purpose of proposing this standard is to induce C programmers to think more carefully about the layout and presentation of their C code. Clearly, there is more to programming than the layout of the code. The data structures and program structures used are crucial in producing a good piece of software. However, without good layout, the best program may be difficult to understand, maintain, or improve. <p>
<CENTER>
<b>Table 3-1: Proposed Standard for C Code Layout, Preliminary  Version</b><p>
</CENTER> 
<PRE> 
     1. Standard tabs are used for program indentation. 
         a. Four space tabs may be used, if desired, after column 56. This is permitted 
            to prevent line wrap on 80-column displays. 
 
     2. A brace is generally on a line by itself. 
         a. The lowest level braces appear on the left margin. 
         b. Comments may appear on lines containing a brace, but only after the brace. 
         c. Braces are indented to the same depth as the statement that invoked the 
            block they frame. 
         d. In variable initializations, the opening brace may be placed on the same line 
            as the equal sign, but the closing brace must have the same indentation as 
            the opening one. 
         e. In general, no statements may appear on the same line as a brace. 
 
     3. A block begins with a left brace and ends with a right brace. Its contents are 
        indented an extra level to indicate the nesting depth. 
         a. Whenever a block is longer than 24 lines (a standard CRT page), a comment 
            should follow the closing brace to indicate the block that the brace closes. 
              i. This applies to whole functions as well as regular blocks. 
             ii. This rule should also be applied with shorter blocks when block nesting 
                 makes the code complex and these comments improve the readability. 
         b. The opening and closing braces of a block are always indented identically. 
         c. The case/default labels of a switch statement are always indented a level, like 
            statements in a block. The statements that follow these labels are always 
            indented an extra level to improve readability. 
         d. Regular labels (destinations for goto's) are always placed at the left margin, 
            regardless of nesting depth. 
         e. When a null block is used (for example, {}), it may appear on the same line 
            as statements (for example, <i>do {} while(expr);</i>). 
         f. If a single statement is used instead of a block, it is indented a single level, 
            just as if it were surrounded by braces. 
              i. Null statements (that is, just a &quot;;&quot;) are indented in the same way as 
                 regular statements. 
 
     4. White space is added in expressions and assignments to improve readability. 
         a. Relational operators are delimited by single spaces. 
         b. Equal signs are delimited by single spaces. 
         c. Unary operators are not separated by space from their operands. 
         d. Parentheses are added to improve readability in complex expressions, even if 
            they are not required to produce correct evaluation. 
              i. A return statement always has a set of parentheses surrounding its 
                 expression. 
         e. No white space character is placed between function names and their 
            parenthesized argument list. 
         f. No white space character is placed between a keyword (for example, <i>if</i>) and 
            its parenthesized argument. 
 
     5. Comments are added liberally to make the program read easily. 
         a. If a comment requires more than one line, the start/end comment tokens are 
            placed on lines containing no comment text. In this case, the start/end 
            tokens are indented identically. 
         b. If a comment fits on a single line, the start/end tokens must also be placed on 
            that line. 
 
     6. Variables are always declared, even if your version of C has a default type. Always 
        explain the purpose of your variables. 
         a. Declare the variables in logical groups, and include a comment on the same 
            line as the declaration to describe the function(s) of the variable(s). 
         b. Avoid numerous declarations on a single line. 
         c. Explain complex pointer declarations. 
         d. Variable names are always lowercase only. 
         e. External variable declarations may be indented a single level for greater 
            readability. 
 
     7. Constants created with <i>#define</i> are always uppercase. Macros created with 
        <i>#define</i> may be uppercase or lowercase. 
         a. As with variables, constants should have explanatory comments to explain 
            their purpose. 
         b. Macros should be explained via comments to avoid misunderstandings about 
            their uses. This is especially important since macros tend to be cryptic. 
         c. Restrict #define statements to the beginning of code files (that is, before the 
            first function). This avoids the potential for redefinition and other 
            confusion. 
 
     8. Other items 
         a. The else..if(expr) construct is placed on a single line as if it were a single 
            keyword. 
         b. Function names are always lowercase. 
 
     9. Portability considerations 
         a. When using a nonstandard C feature, always prepare a portable alternative 
            that may be selected via conditional compilation. 
         b. Indicate any subtle uses of sign extension and type conversions made by your 
            program or your specific compiler. 
         c. Indicate any deviations in the way your compiler handles pointer arithmetic. 
         d. Include the ampersand operator (&amp;) when you pass pointers to structures, 
            even if your compiler doesn't require it. Someone else's compiler may 
            support passing structures. 
         e. Indicate any deviations of your runtime library from the standard. 
         f. Indicate any deviation in the (<i>argc,argv</i>) command line conventions made by 
            your compiler. <p>
</PRE>
<B> 
A Possible Solution <p>
</B>  
Even if a layout standard had been described in <i>The C Programming Language</i>, some programmers would deviate from it. To provide programmers with the code layouts they prefer, C beautifiers are created. Such programs take C code as input, and by adding/removing white space characters, reformat the C code to some individual layout specification. This allows each programmer to distribute code in a standard layout, while using his or her preferred layout standard for local copies of the code. <p>

Beautifiers already exist. For example, Berkeley Unix has a beautifier called CB. This program is fairly simpleminded, but it can convert totally unformatted C code (one using the minimum amount of white space) into the K&amp;R-type layout. More ambitious beautifiers can be created, and this is left for readers to work on. <p>
<B> 
Modifying the Proposed Layout Standard: Questions of White Space<p> 
</B>  
Several readers took exception to one point concerning the proposed layout standard. This was point 4f, which states, &quot;No white space character is placed between a keyword (for example, if) and its parenthesized argument.&quot; David D. Clark of State College, Pennsylvania, wrote, &quot;In general, I like your coding standard suggestions. My only strong objection is your idea of omitting spaces between reserved words [and their arguments]. It makes them look like function invocations.&quot; <p>

Tim Smith of Evanston, Illinois, noted, &quot;I think a single space between a function name and the initial opening parenthesis, or after ifs and elses, looks better. <p>

Guy Scharf of Mountain View, California, wrote, &quot;4f. I have a strong preference to always put a space between a reserved word (if, while) and its parenthesized argument. This adds legibility for me.&quot; <p>

Finally, Charlie Brady of New South Wales, Australia, wrote, &quot;The only real beef I have with you is the formatting of keywords and their parenthetical expressions. I can see no reason to depart from Kernighan and Ritchie on this point, and a number of reasons for maintaining their convention. First, a flow control construct is semantically distinct from a function call, and a formatting difference is a reasonable way of distinguishing them. Second, the formatting difference simplifies the use of a text editor for such tasks as constructing structure charts. Third, your recommendation departs from at least three extant recommended standards, namely Kernighan and Ritchie, Thomas Plum, (<i>Programming Standards and Guidelines</i>, Plum Hall, 1981) and Tim Lang (&quot;Formatting,&quot; <i>AUGEN</i>, 4(1), January, 1982). (The C standard proposed by Lang is compatible with the one described in Table 3-1.) <p>

After considering the above remarks, I have concluded that the space does serve a useful purpose. Therefore, I suggest point 4f be changed to read: &quot;A single white character is (optionally) placed between a keyword (for example, if) and its parenthesized argument.&quot; (Making the white space character optional is another point for debate.) I think it should be optional, but recommended. I don't think that adding a space for function call invocations would be beneficial, as suggested by Mr. Smith. <p>

Another question concerning white space insertion comes in connection with argument lists. The original standard does not indicate if spaces should be included. I think that a comma should be directly adjacent to the argument that it follows, and that a single white space should follow each comma to add legibility. I am also convinced that parentheses should be adjacent to the argument(s) they enclose. Thus (in agreement with Tim Lang's article, mentioned above) I would write <p>
<PRE>  
     x = atan(sin(y));<p> 
</PRE>  
and not<p> 
<PRE>  
     x = atan( sin( y ));<p> 
</PRE>  

Yet another point is that binary operators should be delimited by white space. Thus, the following statement lacks sufficient white space <p>
<PRE>  
     v = sin(ln(1.0+x));<p> 
</PRE>  
whereas this expression is properly formed <p>
<PRE>  
     v = sin(ln(1.0 + x)); <p>
</PRE>  
Finally, Section 4 needs to be updated to include a style specification for pointer references. I think that that operators &quot;.&quot; and &quot;-&gt;&quot; should not be delimited by spaces from the objects they act on. This point and the three above are formalized in Table 3-2 as additions to Section 4. <p>
<CENTER> 
<b>Table 3-2: Additions to Section 4 of Proposed Standard for C Code Layout</b> <p>
</CENTER>
<PRE>
     4. b. Binary operators (for example, +, -, /, but not &quot;-&gt;&quot; and &quot;.&quot;) and assignment
            operators (for example, =, *=, &amp;=) are delimited by white space. 
        g. Parentheses should be adjacent to the argument(s) they enclose. 
        h. A comma is bound to the argument that precedes and should be followed by 
           a single space. 
        i. Operators such as &quot;-&gt;&quot; and &quot;.&quot; (used in pointer references) directly bind to
            their arguments with no intervening spaces. <p>
</PRE>
The Lang article points out a circumstance under which point 4g need not be followed. This occurs when complicated conditional expressions of the form &quot;keyword (expr)&quot; are split over several lines. For example, you need not use a crowded expression, as follows:<p> 
<PRE>  
     if((a == 1) &amp;&amp; (b == 2) &amp;&amp; (c == 3) &amp;&amp; ((d == 4) || (d == 5))) 
     { 
             /* operations performed if conditional true */ 
             ... 
     }<p> 
</PRE>  
Instead, you can select a much more readable form: <p>
<PRE>  
     if      /* we make multiline expression look like a block */ 

     ( 
             (a == 1) &amp;&amp; 
             (b == 2) &amp;&amp; 
             (c == 3) &amp;&amp; 
             ((d == 4) || (d == 5)) 
     ) 
     ( 
             /* operations performed if conditional true */ 
             ... 
     }<p> 
</PRE>  
In this example, the parentheses are placed on lines by themselves, since they bracket a multiline expression, much like braces enclose the statements of a block. <p>

Another point of minor objection was the tabulation method specified by the standard (point 1a). Steve Newberry of Los Altos, California, stated, &quot;Upon one point I do feel compelled to argue with you, and that is the tab convention: The depth of the tab stop on a given page is of far less significance to the readability of that page than is the consistency of the depth. I really don't want to use different size tabs on the same page.&quot; <p>

Tim Smith wrote, &quot;I personally follow most all of his suggestions on how to actually format the code on the line and page, with only two exceptions. I always use 4-space tab stops.&quot; <p>

I agree that having a single tab size is the preferable way to write C code. Standard tabs give more openness to the code and make various parts of a program easier to pick out. My rationale for large horizontal tabbing is the same as for vertical tabbing. I want the program's significant portions to stand out. However, I propose adding point 1b to the standard: &quot;Four-space tabs may be used in lieu of standard tabs in cases where a subprogram includes highly nested segments.&quot; I would also include point 1c: &quot;Only one of the two tabbing conventions should be employed in any given program module.&quot; <p>

Some currently available screen editors provide a feature called horizontal scrolling. With horizontal scrolling, you can view a window of your file in both the vertical and horizontal directions. Thus, files with lines longer than the display device may be handled intelligently. Under such circumstances, there is no real disadvantage to using standard tabs to any desired nesting depth, which is permitted by point 1a of the proposed standard. <p>
<B> 
Other Corrections <p>
</B> 
Charlie Brady noted that point 3e is unnecessary. Point 3e was: &quot;When a null block is used (for example, {}), it may appear on the same line as other statements (for example, <i>do {} while(expr);</i>).&quot; Mr. Brady wrote, &quot;Another minor point of disagreement concerns the use of the null block ({}). This is never necessary, and I believe that the null statement (;) is clearer. It should be emphasized that the null statement deserves a line of its own. Your example: <p>
<PRE> 
     do {} while(expr);<p> 
</PRE>  
is more simply written<p> 
<PRE>  
     while (expr) 
             ;<p> 
</PRE>  
In accordance with Mr. Brady's remark, I propose replacing point 3e with the following: &quot;The null block ({}) can always be avoided. Instead of a null block, use the null statement.&quot; I also would add point 3f-ii: &quot;The null statement is always on a line by itself.&quot;<p> 
<B> 
Documentation Standards <p>
</B> 
In addition to a code layout standard, James Halstead of Joliet, Illinois, has proposed a basic documentation standard. He wrote, &quot;I strongly suggest that the original standards one through nine be renumbered two through ten so that the first and foremost standard may be inserted.&quot; <p> 

The documentation standard suggested by Mr. Halstead is presented in Table 3-3. In including this as part of the proposed standard, I chose to place it in section 0 to avoid renumbering. (Asterisks indicate slight additions I made.)<p> 
<CENTER> 
<b>Table 3-3: Documentation Standard for C (per Halstead)</b> <p>
</CENTER>
<PRE> 
     0. Identification Description (I.D.) information must appear at the the beginning of 
        each C language source file. 
         a. The recommended format is: 
              i. Begin comment (/*). 
             ii. Space. 
            iii. Title (identification name normally = filename). 

           * iv. Subtitle (that is, what program system does this file belong to). 
              v. Space. 
             vi. Classification (see below). 
            vii. Year. 
           viii. Owner. 
             ix. Status (see below). 
            * x. Current version number and brief history. 
             xi. Date. 
            xii. Functional/structural description in brief. 
         * xiii. Portability synopsis. 
          * xiv. Space. 
             xv. End Comment (*/). 
          * xvi. Space. 
         b. The program classification (a-vi) is one (or more) of the following: 
              i. Public-domain. 
             ii. Copyright. 
          * iii. Copyright: released for noncommercial purposes. 
             iv. Unclassified. 
              v. Secret. 
           * vi. Freeware [voluntary contribution software] 
            vii. No classification. 
         c. The program status (a-ix) is one of the following: 
              i. Outline. 
             ii. Draft. 
            iii. Test (alpha, beta, and so on). 
             iv. Release. <p>
</PRE>
In addition to Section 0, I think a basic documentation standard for functions would also be useful. Such a standard is presented in Table 3-4. I have placed this under section 10, since function documentation is a distinct task from module documentation, as described in section 0 (Table 3-3).<p> 
<CENTER> 
<b> Table 3-4: Documentation Standard for Functions </b><p>
</CENTER>
<PRE> 
     10. Each function should contain the following minimum documentation: 
 
          a. A general explanation of the function performed. 
          b. Its name, and a description of its arguments including their types and legal 
             values. 
          c. A description of the functional return value, if any. 
          d. A list of nonstandard functions used by the function. 
          e. A list of external variables used and/or modified by the 
             function. 
          f. A description of the error handling characteristics of the function. 
          g. A valid calling sequence example, if practical. <p>
</PRE>
<B> 
Other Proposals <p>
</B> 
Several other readers made suggestions for the standard. Tim Smith proposed several that merit discussion. They are presented in Table 3-5 with the point numbers they receive as part of the standard: <p>
<CENTER> 
<b>Table 3-5: Smith's Revisions to Code Standard </b><p>
</CENTER>
<PRE> 
     (5c). Don't nest comments, even if your preprocessor/compiler allows it. 
     (6f). If there are many declarations, whether on one line or many, alphabetize them. 
 
     (9g). Restrict variable and function names to 7 well-chosen characters, even ff your 
           compiler allows more.<p> 
</PRE> 
Steve Newberry wrote the following about standards: &quot;I applaud your interest in establishing a standard format convention for C programs. However, I feel that your effort would have more impact if tied to support of Tom Plum's book <i>C Programming Standards and Guidelines, Version U (Unix and offspring)</i>, third edition, January 1982. Presented in this manner, your proposed formatting standard would be seen as a consistent extension of a more general set of standards already in wide circulation.&quot; <p>
<B>
Other Points of View <p>
</B> 
Although most readers were favorable to the idea of a C format standard, 
Douglas M. Potter of Seattle, Washington, wrote, &quot;I afraid I don't see much advantage of your proposed standard over theirs [Kernighan and Ritchie]. In both cases, the size of the ident is too large, I always run out of room on the right side with a tab sized ident. I also find that nobody uses enough white space.&quot;<p>
 
John F. Draffen of Texas City, Texas, wrote me a detailed letter on why he didn't like the idea: &quot;I am writing to express my objections
 .... In the first place, I do not think a standard of this type is either necessary or desirable. The layout has nothing to do with portability, which to my mind is the only excuse for a standard. It seems to me that it is hard enough to get people to agree on necessary standards. In the second place, I do not agree with many of your suggestions on style. One of the nice things about C that it shares with Fortran is its relative conciseness. I do not like to see code strung out unnecessarily. C does not interject unnecessary constructions, and I think that introducing unnecessary white space, excessive indentation and meaningless comments is a kind of gingerbread that we can do without.&quot; Mr. Draffen's style philosophy is listed in Table 3-6.<p> 
<CENTER> 
<b>Table 3-6: Draffen's C Style Philosophy</b> <p>
</CENTER>
<PRE> 
     1. Punctuation should be used sparingly. The insertion of unnecessary white space 
        should be avoided. 
 
     2. Block structure should be indicated by indentation. Excessive indentation should 
        be avoided. 
 
     3. Comments and program code should be separated. Comments on the same line as 
        code should be displaced far enough to the right that they do not obscure the 
        code. 
 
     4. Comments should be meaningful. Comments that do no more than repeat what 
        has already been said by the code should be avoided. <p>
</PRE> 
I differ with Mr. Draffen on several counts. First and foremost, portability is not the sole subject of importance in programming. The ability to maintain,  understand, correct, and enhance code is of great importance. To understand someone else's code (or your own code at a later date) requires some formatting. Comments that seem less than essential to the programmer must sometimes be included for the sake of others. This is immensely important. It is often difficult for programmers to know how to comment their code, since they usually cannot know the level of sophistication of later readers. Thus, it is often better to include a few extra comments than to comment code sparsely. <p>

I suggested previously that users should maintain their code in the form that they prefer. However, code distributed to others could (and should) meet some minimum standard of neatness (formatting) and presentation. Some of this can be provided by a beautifier, but most must be done by the programmer.<p>
 
As a final note on C layout, I'm including an insightful paragraph from Tim Smith. It suggests why so much C code is so poorly formatted and commented: &quot;I don't think that you will ever get Unix wizards to follow these recommendations. I should have noted that I use Skjellum-like conventions when I'm writing micro-based applications. When I'm maintaining Unix sources, I stick with the standard Unix conventions, which are pretty much K &amp; R standard. Unix whizzes think that aligning curly braces is irrelevant, since vi, the editor that 90% of them use, will always let you find the top or bottom match for any brace automatically. Also, and probably more important, Unix system users always debug by staring at their CRTs, never from printouts (that's for Cobol programmers), and the goal is to reduce the number of lines of a function, so that as much of it as possible will fit on a screen. Seeing a whole line taken up by just an opening brace must drive them crazy, and some of them will even close blocks on the end of a line of code (yecch!)&quot; <p>
<B>
A C Style Reference <p>
</B> 
I have included some general references about C style above. Since I wrote of that discussion, I've run into another paper on the subject. Although the formatting is different from what I prefer, I think this paper is well worth attention: &quot;A C Style Sheet&quot; by Martin Minow of Digital Equipment Corporation. It includes a list of references from which the work is &quot;abstracted.&quot; <p>

The most important point of the foregoing discussion is that programmers need to pay attention to more than just their algorithms. The questions of code layout and documentation require consideration. Using a self-consistent set of guidelines in preparing code and documentation can only help to improve the quality of the finished product.<p>
 
For reader reference, the complete amended standard is included in Table 3-7. <p>
 <CENTER>
<b>Table 3-7: Amended Proposal for C Code Layout</b> <p>
</CENTER>
<PRE> 
     0. Identification Description (I.D.) information must appear at the beginning of 
        each C language source file. 
         a. The recommended format is: 
              i. Begin comment (/*). 
             ii. Space. 
            iii. Title (identification name normally = filename). 

             iv. Subtitle (that is, what program system does this file belong to). 
              v.  Space. 
             vi. Classification (see below). 
            vii. Year. 
           viii. Owner. 
             ix. Status (see below). 
              x. Current Version number and brief history. 
             xi. Date. 
            xii. Functional/Structural Description in brief. 
           xiii. Portability synopsis. 
            xiv. Space. 
             xv. End Comment (*/). 
            xvi. Space. 
         b. The program classification (a-vi) is one (or more) of  the following: 
              i. Public-domain. 
             ii. Copyright. 
            iii. Copyright: released for noncommercial purposes. 
             iv. Unclassified. 
              v. Secret. 
             vi. Freeware [voluntary contribution software] 
            vii. No classification. 
         c. The program status (a-ix) is one of the following: 
              i. Outline. 
             ii. Draft. 
            iii. Test (alpha, beta, and so on). 
             iv. Release. 
 
     1. Standard tabs are used for program indentation. 
         a. Four space tabs may be used, if desired, after column 56. This is permitted 
            to prevent line wrap on 80-column displays. 
         b. Four-space tabs may be used in lieu of standard tabs in cases where a 
            subprogram includes highly nested segments. 
         c. Only one of the two tabbing conventions should be employee in any given 
            program module. 
 
     2. A brace is generally on a line by itself. 
         a. The lowest level braces appear on the left margin. 
         b. Comments may appear on lines containing a brace, but only after the brace. 
         c. Braces are indented to the same depth as the statement that invoked the 
            block they frame. 
         d. In variable initializations, the opening brace may be placed on the same line 
            as the equal sign, but the closing brace must have the same indentation as 
            the opening one. 
         e. In general, no statements may appear on the same line as a brace. 
 
     3. A block begins with a left brace and ends with a right brace. Its contents are 
        indented an extra level to indicate the nesting depth. 
         a. Whenever a block is longer than 24 lines (a standard CRT page), a comment 
            should follow the closing brace to indicate the block the brace closes. 
              i. This applies to whole functions as well as regular blocks. 
             ii. This rule should also be applied with shorter blocks when block 
                 nesting makes the code complex and these comments improve the 
                 readability. 
         b. The opening and closing braces of a block are always indented identically. 
         c. The case/default labels of a switch statement are always indented a level,
             like statements in a block. The statements that follow these labels are 
            always indented an extra level to improve readability. 
         d. Regular labels (destinations for goto's) are always placed at the left margin, 
            regardless of nesting depth. 
         e. The null block {} can always be avoided. Instead of a null block, use the 
            null statement. 
         f. If a single statement is used instead of a block, it is indented a single level, 
            just as if it were surrounded by braces. 
              i. Null statements (that is, just a &quot;;&quot;) are indented in the same way as 
                 regular statements. 
             ii. The null statement is always on a line by itself. 
 
     4. White space is added in expressions and assignments to improve readability. 
         a. Relational operators are delimited by single spaces. 
         b. Binary operators (for example, +, -, /, but not &quot;-&gt;&quot; and &quot;.&quot;) and 
            assignment operators (for example, =, *=, &amp;=) are delimited by white space. 
         c. Unary operators are not separated by space from their operands. 
         d. Parentheses are added to improve readability in complex expressions, even 
            if they are not required to produce correct evaluation. 
              i. A return statement always has a set of parentheses surrounding its 
                 expression. 
         e. No white space character is placed between function names and their 
            parenthesized argument list. 
         f. A single white character is (optionally) placed between a keyword (for 
            example, if) and its parenthesized argument. 
         g. Parentheses should be adjacent to the argument(s) they enclose. 
         h. A comma is bound to the argument that precedes and should be followed by 
            a single space. 
         i. Operators such as &quot;-&gt;&quot; and &quot;.&quot; (used in pointer references)                          	directly bind to their arguments with no intervening spaces. 
 
     5. Comments are added liberally to make the program read easily. 
         a. If a comment requires more than one line, the start/end comment tokens 
            are placed on lines containing no comment text. In this case, the start/end 
            tokens are indented identically. 
         b. If a comment fits on a single line, the start/end tokens must also be placed 
            on that line. 
         c. Do not nest comments, even if your preprocessor/compiler allows it. 
 
     6. Variables are always declared, even if your version of C has a default type. 
        Always explain the purpose of your variables. 
         a. Declare the variables in logical groups, and include a comment on the same 
            line as the declaration to describe the function(s) of the variable(s). 
         b. Avoid numerous declarations on a single line. 
         c. Explain complex pointer declarations. 
         d. Variable names are always lowercase only. 
         e. External variable declarations may be indented a single level for greater 
            readability. 
         f. If there are many declarations, whether on one line or many, alphabetize 
            them. 
 
     7. Constants created with #define are always uppercase. Macros created with 
        <i>#define</i> may be uppercase or lowercase. 
         a. As with variables, constants should have explanatory comments to explain 
            their purpose. 
         b. Macros should be explained via comments to avoid misunderstandings 
            about their uses. This is especially important since macros tend to be 
            cryptic. 
         c. Restrict <i>#define</i> statements to the beginning of code files (that is, before 
            the first function). This avoids the potential for redefinition and other 
            confusion. 
 
     8. Other items. 
         a. The else..if(expr) construct is placed on a single line as if it were a single 
            keyword. 
         b. Function names are always lowercase. 
 
     9. Portability considerations. 
         a. When using a nonstandard C feature, always prepare a portable alternative 
            that may be selected via conditional compilation. 
         b. Indicate any subtle uses of sign extension and type conversions made by 
            your program or your specific compiler. 
         c. Indicate any deviations in the way your compiler handles pointer 
            arithmetic. 
         d. Include the ampersand operator (&amp;) when you pass pointers to structures, 
            even if your compiler doesn't require it. Someone else's compiler may sup 
            port passing structures. 
         e. Indicate any deviations of your runtime library from the standard. 
         f. Indicate any deviation in the (<i>argc</i>,<i>argv</i>) command line conventions made 
            by your compiler. 
         g. Restrict variable and function names to 7 well-chosen characters, even if 
            your compiler allows more. 
 
     10. Each function should contain the following minimum documentation: 
         a. A general explanation of the function performed. 
         b. Its name and a description of its arguments including their types and legal 
            values. 
         c. A description of the functional return value, if any. 

         d. A list of nonstandard functions used by the function. 

         e. A list of external variables used and/or modified by the function. 
         f. A description of the error handling characteristics of the function. 
         g. A valid calling sequence example, if practical. <p>
</PRE>
<CENTER>
<B>
PART 2: LINKER FORMATS AND RUNTIME LIBRARIES <p>
</B>
</CENTER> 
<i>The C Programming Language</i> defines a standard runtime library for C. Some of the features provided are feasible only under Unix. Thus, for CP/M, CP/M-86, and MS-DOS implementations, only part of the runtime library can be supported. Yet some C compilers do not provide a compatible subset library. The result is code that cannot be easily transported from compiler to compiler, or machine to machine. Thus, such compilers negate one of the primary purposes of the C programming language: portability. <p>

The BDS C Compiler is one such software product. It is an excellent subset compiler, but its runtime library is incompatible with the standard. After using BDS C for more than three years, I have accumulated a significant collection of useful subroutines and programs. Unfortunately, some of this software depends heavily on the BDS C runtime library. This code requires significant work before it can be used with another compiler. So be aware of this pitfall and be prepared to live with the consequences if you choose a compiler with a nonstandard runtime library. <p>

BDS C is not the only compiler whose runtime library is nonstandard. The Whitesmith C compilers use their own too. However, since Whitesmith compilers are available for many different environments, portability between Whitesmith compilers is immediate. Nevertheless, I prefer code written for use with the standard library and compilers that support that library in full or subset form. <p>
<B>
Link Formats <p>
</B> 
Besides incompatible runtime libraries, there is the question of subroutine linkage and linkage editor formats. Once again, BDS C is nonstandard. That is, it uses its own linker instead of conforming to the Microsoft .REL format. (Some 8080/Z80 compilers do support the standard, such as the Q/C compiler from The Code Works). Compatibility with the .REL format is a considerable blessing, if you plan to link other software to your C programs. <p>

The lack of linkage compatibility is not limited to the CP/M-80 world. A wide variety of C compilers sold for MS-DOS and CP/M-86 fail to use the appropriate standard. Most notably, older releases of Computer Innovations's C86 compiler used its own internal format. Furthermore, the DESMET C compiler has its own library format and linkage procedure. This made it virtually impossible to use C86 to produce subroutines for other compiled languages under MS-DOS or CP/M-86. (Note: Fortunately, newer versions of most MS-DOS and CP/M-86 C compilers can produce Microsoft-format object code.) <p>

The reasons for the incompatibility are probably manifold. The usual response from the companies producing the incompatible products is that they prefer their own format to Microsoft's. Why is this? I suppose this results from programmers who don't care about standards or just didn't consider that the users would find a compatible linkage format useful. In any case, be aware of 
the linkage format used by the C compilers you select. <p>
<B> 
Reader Responses on Link Formats <p>
</B> 
Readers had a lot to say about incompatibility between link formats. Guy Scharf of Mountain View, California, wrote, &quot;I find the incompatibility of linkage editor formats to be a real problem. For example, I want to use Digital Research's Access Manager and Display Manager 86 with C. I would prefer CI-86 (because I am used to it) but have to switch to DRI's C because of the link format. Another compiler to learn and idiosyncrasies to surmount.&quot; He concluded, &quot;I'm not sure what to do about this problem (except complain).&quot; <p>

David D. Clark of State College, Pennsylvania, wrote, &quot;The big problem isn't really the format of linkable files. Even compilers that use Microsoft's M80 and L80 will not allow linkage to code produced by different compilers. The function calling protocols vary tremendously from compiler to compiler. BDS C and Q/C have fairly straightforward function calling protocols. Eco-C, on the other hand, has a tortuous function-calling sequence. And even though Q/C and Eco-C use the Microsoft assembler and linker, the code files produced by them are not compatible.&quot; <p>

The problem that Mr. Clark mentions is also present in the 8086 (MS-DOS, CP/M-86) world. Code from different compilers cannot be mixed because: <p>
<UL> 
<LI>Each requires its own main function 
<LI>A wide variety of link formats exist 
<LI>Calling conventions differ between compilers. <p>
</UL> 
The first two points are essentially insurmountable problems from the user's point of view. However, the third point can be overcome by adding dummy routines to convert calling conventions.<p>
 
Mr. Clark makes some additional points concerning the deficiencies of the 8080 Microsoft .REL (relocatable) format (these are of interest since many 8080 C compilers rely on this format):<p> 
<OL> 
<LI>M80 and DRI's RMAC assemblers only support six unique characters (all 
        upper-case). This is awkward for many purposes. 
<LI> Although the .REL format can apparently handle seven unique characters,
         neither M80 nor RMAC support this. 
<LI> Apparently the .REL format, M80, and L80 were designed to work with the 
        Fortran-80 compiler, which permits only six character symbols. This is an old 
        standard, and does not reflect the needs of today's compilers. The absence of case 
        sensitivity in symbols is especially limiting.<p> 
</OL> 
It is obvious that an enhanced standard is necessary for the CP/M-80 world. Even under MS-DOS, where Microsoft has enhanced the linkage editor format, problems still exist. <p>

Microsoft's MS-DOS linkage format supports long symbols (31 unique characters) and has case sensitivity. Thus, it overcomes the objections that Mr. Clark posed for the 8080 .REL system. However, one problem still exists: the dichotomy between object modules and libraries. Because of this dichotomy, the MS-DOS linker always includes the full contents of a .OBJ module during linking. However, libraries are searched. To make a library efficient, each function must be compiled into its own .OBJ file. Each .OBJ file becomes a single sub-block in the library; all the functions of that sub-block file are included at program linkage. If libraries and object modules were equivalent, this problem would be overcome since the functions of an object module would be separable during linking. <p>
<B> 
Runtime Libraries <p>
</B> 
Nonstandard runtime libraries are a plague to programmers. They inhibit portability and introduce bugs when software is transported between different compilers. Charles Brady of New South Wales, Australia, wrote, &quot;An enormous contribution to standardization of C programs would be the publication of a standard I/O library for BDS C with, if necessary, a modified runtime package. The fast and efficient compiler, particularly with the symbolic debugger tool, provides an inviting environment for software development. It is a great pity that this means abundant nonstandard C. As there is no inherent reason why this should be the case ... someone should be able to ... produce a Unix-compatible I/O library.&quot; <p>

This point is especially well-taken in view of the large amount of BDS C software available through the C User's Group of McPhearson, Kansas.<p>
 
In the case of the runtime library itself, there is a clear standard. This standard is spelled out in <i>The C Programming Language</i>. Compilers need only support a proper subset appropriate to the environment in which they work.<p> 
<B> 
BDS C Runtime Solution <p>
</B> 
Alex Cameron of Malvern (Victoria), Australia, had the following comments: &quot;I couldn't help responding to your notes on the nonstandard nature of some of BDS C's runtime routines. There is probably little doubt that most of us gladly suffer its irregularities because of its speed, low price, and because it is arguably one of the finest C compilers around--all this notwithstanding, I still find the nonstandard buffered file functions such as fopen the most frustrating, simply because of the need to continually declare buffers.&quot; <p>

<a href="#list3-1">Listing 3-1</a> (stdlib3.c) is Mr. Cameron's proposed solution to this problem under BDS C. <p>
<B>
More on Libraries and Portability <p>
</B> 
Mike Meyer of Norman, Oklahoma, wrote the following concerning libraries and portability: &quot;To add some constructive comment, I'd like to point out that relying on library utilities for things does not guarantee portability. For instance, many C implementations won't have the Unix math(3) library or the qsort(3) routines. Of note is that the current AT&amp;T Unix distribution doesn't include the dbm(3) routines from Unix version 7. I used those routines to fix the 'everything is line-oriented ASCII' problem with Unix, and [people at] some of the AT&amp;T sites that don't have that library complained when they received copies of my software.&quot; <p>

This is an interesting point that I had not considered. It adds more complexity to the idea of C/Unix software portability. What libraries can and cannot be assumed when writing a program? Is it okay to think of libraries such as CURSES as standard? <p>
<CENTER>
<B>
PART 3: MEMORY MODELS <p>
</B>
</CENTER> 
This section concerns the memory model concepts of the 8086 and how this affects C compilers implemented for this microprocessor family. I discuss the advantages and drawbacks of several memory models used by existing C compilers, and present code to help overcome some limitations of small memory model compilers. <p>

For readers who are not interested in the details of 8086 C compilers, large memory models, or long pointers, there is still some interesting material in this column. Specifically, several routines included here illustrate real-life code to interface C and assembly language. Most compiler manuals are terse on this subject, so some actual code may help drive home the concepts involved. <p>
<B> 
Background <p>
</B> 
Before plunging into a discussion of memory models, a brief introduction to the 8086 architecture is necessary. This material will help to illustrate why there are different addressing schemes used by different compilers. <p>

The 8086/88 microprocessors support 20-bit addressing. This allows the microprocessor to address in excess of one million bytes. However, all the registers are 16 bits wide. This implies that some segmentation scheme must be used to address more than 64K bytes of memory. The technique used involves four 16-bit segment registers: CS, DS, ES, SS. These registers are the code-segment, data-segment, extra-segment, and stack-segment registers, respectively. Depending on the instruction used, different segment registers come into play in determining the complete 20-bit address. In forming a complete address, the segment address is always shifted left, four bits. Note that a segment register by itself addresses memory on 16-byte boundaries. Sixteen-byte regions addressable by segment registers are known as paragraphs. Although paragraphs and paragraph alignment are not normally of interest to C programmers, they are sometimes important when you are developing assembly language interface code for C. <p>
To discuss long pointers, a special notation is used. Since the address is split, it is written in the form: <p>
<PRE> 
     segment:by te_pointer <p>
</PRE> 
where segment is the segment, and byte pointer is the 16-bit low-order part of the address. A typical example of such an address would be &quot;es:bx,&quot; which means &quot;segment specified by es register and offset from this segment specified by the bx register.&quot; This notation is used throughout the listings included with this column. <p>

Machine instructions often differentiate between intersegment and intrasegment operations. For example, there are &quot;far&quot; and &quot;near&quot; CALL instructions. <p>
<B> 
8080 Memory Model<p> 
</B> 
The 8080 memory model is just what the name implies. All segment registers are set equally, so that only a total of 64K is available for a program. This model is seen mostly under CP/M-86, but is occasionally used by MS-DOS programs. None of the C compilers that I have seen restrict programs to this model.<p> 
<B> 
Small Memory Model<p> 
</B> 
Many programs can work comfortably with only 64K of data space and 64K of program space. Such a model results when the CS and DS registers are set to different blocks of memory (up to 64k each). Normally, ES and SS are set equal to DS, so that all data and stack memory resides in the same block of memory. This model is fine as long as programs and data requirements are small enough to fit within the 64K limits. Many C compilers only support this model. <p>
<B>
Large Memory Model <p>
</B> 
In a large memory model, all addresses refer to the full 20-bit range. All subroutine calls are &quot;far&quot; calls, and all data is referred to with long pointers. Long pointers include a segment and byte address pointer (thus occupying 32 bits). Only a few C compilers support this model. The reason that most compilers don't support this model is the greater complexity of code generation. I will mention more on this later.<p> 
<B> 
Small Code / Large Data Model<p> 
</B> 
A useful hybrid of the small and large memory models is the only one where 64K of program space is provided, but long pointers are used for data. This model offers speed advantages for programs that require more data storage, but are small to moderate in code size. <p>
<B> 
Large Code / Small Data Model <p>
</B> 
One other possibility would be a large-code/small-data model, which would be used for programs with small data requirements but large code requirements.<p> 
<B> 
Large Stack Feature<p> 
</B> 
One type of model, not yet considered, is one that supports a large stack. A large stack would support more than 64K of items. Implementing this feature would slow program execution significantly, since stack references would be complicated. <p>
<B> 
Which model is better? <p>
</B> 
As long as a C program can fit within the small memory model, there is a distinct speed advantage in using this model. The large memory model produces longer (and somewhat slower) programs because of the greater generality of each instruction produced (ability to refer to 1024K instead of 64K of memory requires longer pointers and more checks). Since the 8086 doesn't provide many instructions to manipulate the long pointers, many additional instructions must be generated for pointer-related operations (which also include all memory references.) Specific examples of the lack of 8086 instructions involve incrementing and decrementing long pointers. Note that a long pointer is not just a 32-bit word. The upper 16 bits is a segment address, which must be treated accordingly when crossing 64K boundaries. Examples of implementing these features in software are included in <a href="#list3-6">Listing 3-6</a> (llint.asm; examples: <i>linc</i> and <i>ldec</i> functions). <p>

Thus, all models have drawbacks. Speed is gained at the expense of (essentially) unlimited program/data space. Use the large memory model for big programs that use big chunks of data. Otherwise, stick with the small model. <p>
<B> 
Drawbacks of the Small Memory Model<p> 
</B>
Assuming that you use the small memory model (by choice or because of your compiler), everything will run smoothly until you have to deal with memory outside the C data address space. For example, it might be nice to use large buffers for copying files or keeping help information. Another possibility would involve accessing special locations in the memory map.<p> 
You can implement the ability to use long pointers in a small memory model with relative ease. A set of such routines is presented in <a href="#list3-2">Listings 3-2</a> to 3-6. <p>
<B> 
The Long Pointer Package<p> 
</B> 
The Long Pointer Package supplements a C environment by allowing references to memory locations anywhere in the 20-bit address map. This is done by defining a new data type LPTR (via a <i>typedef</i>): <p>
<PRE> 
     typedef union __lptr 
     { 
             long  _llong;                  /* long format */ 
             char  _lstr[4];                /* character format */ 
             LWORD _lword;                  /* long-word format */ 
     } LPTR; <p>
</PRE> 
where LWORD is defined as the following structure: <p>
<PRE> 
     typedef struct __lword 
     { 
             unsigned _addr;             /* address */ 
             unsigned _segm;             /* segment */ 
     } LWORD; <p>
</PRE> 
This format for LPTR makes the addresses defined directly compatible with normal long pointers used at the assembly level. These long pointers are stored in the 8080 style: least significant byte of address first, most significant byte of segment last.<p>
 
The lowest level routines that support long memory references are, of necessity, coded in assembly language. The routines that implement many of the lowest level functions in a noncompiler-specific way are included in <a href="#list3-5">Listing 3-5</a> (llsup.asm). Routines that implement functions for Aztec C86 (a typical 8086 C compiler) version 1.05i are included in <a href="#list3-6">Listing 3-6</a> (llint.asm). You may have to modify these routines for other C compilers, if register usage or stack arrangements differ. <p>

To use the routines with C programs, you must include the header file lsup.h at the beginning of modules that use or refer to LPTR data types. The &quot;lsup.h&quot; file refers to &quot;_lsup.h&quot; also. These two headersare presented in <a href="#list3-3">Listing 3-3</a>and <a href="#list3-4">Listing 3-4</a>, respectively. <p>
<B> 
Supported Functions <p>
</B> 
The package supports several functions involving long pointers. There are routines to add offsets to long pointers, copy memory between long pointers, and return data addressed by long pointers. A complete list of these functions is included in Table 3-8, which also mentions the file in which the function is located. <p>
<CENTER> 
<b>Table 3-8: Functions Involving Long Pointers </b><p>
</CENTER>
<PRE>
     <b>file: lsup.c (some C support routines) </b>
          lassign(dest,source)   assign long pointers 
          llstrcpy(dest,source)  long string copy 
          lprint(lptr)           debugging routine for printing LPTRs 
 
     <b>file: llint.asm (Aztec C dependent support routines)</b> 
 
          flptr(lptr,sptr)       form a long pointer from a normal 
                                 short C (ds relative) pointer 
          lchr(lptr)             return character addressed by long 
                                 pointer 
          lint(lptr)             returns int/unsigned addressed by 
                                 long ptr. 
          l_stchr(lptr,chr)      stores char at location lptr 
          l_stint(lptr,intgr)    stores int at location lptr 
          lload(dest,lptr,len)   general purpose copy to short 
                                 pointer area (ds relative) from 
                                 long pointer area 
          lstor(lptr,src,len)    reverse if lload() 
          linc(lptr)             increment long pointer 
          ldec(lptr)             decrement long pointer 
          ladd(lptr,offset)      add unsigned offset to lptr 
          lsub(lptr,offset)      subtract unsigned offset from lptr 
          lsum(lptr,offset)      add signed offset to lptr 
          lcopy(dest,src,len)    general purpose long to long copy 
                                 (can copy up to 1024K of memory) 

 
       <b>file: llsup.asm (compiler independent functions)</b> 
 
          linc                   increment a long pointer 
          ldec                   decrement a long pointer 
          ladd                   add an unsigned offset to a long pointer 
          lsub                   sub an unsigned offset from a long pointer 
          lsum                   add a signed offset to a long pointer 
          lcopy                  general copy routine <p>
</PRE>
<B> 
An Example: <p>
</B> 
One useful application of long pointers under MS-DOS 2.0 involves accessing a program's environment block. The environment block is a Unix-like set of environment variables and values. This is normally used to affect some particular aspects of program execution. Specifics about the environment address are included below in the sidebar &quot;Environment Block Address.&quot; Interested readers can also refer to the DOS 2.0 users' manual for more details. <p>
<B> 
Environment Block Address <p>
</B> 
C compilers under MS-DOS normally produce .EXE files. For .EXE files, a program segment prefix is created by DOS 2.0 and later. The segment address of this prefix is es:0 when the user program begins. At offset 002cH from this address is stored the segment address of the environment table. Only a segment is stored: the offset from the segment is again zero. Thus, the contents of es:2ch is the address of the environment block. <p>

Normally, C compilers have a maintenance routine that is given control at the start of program execution. For Aztec C86, this routine is called $begin and is located in the calldos.asm module included with the compiler. The user must define an external variable in calldos.asm for the benefit of env.c, in order for the segment address to be accessible as a long pointer. The procedure for this operation is detailed in the comments included in <a href="#list3-7">Listing 3-7</a>(env.c).<p> 
<B>
Allocation of Memory <p>
</B> 
If a C program intends to use DOS memory allocation in conjunction with the long pointers, it must also be sure to shrink its memory allocation using the MS-DOS SETBLOCK function. This is normally done in the initial maintenance routine of the C runtime system. For Aztec C this must be done in $begin. <p>

The example program env.c (<a href="#list3-7">Listing 3-7</a>) reads the environment block and displays the contents of the whole block on the console. In effect, it provides the same listing feature as the MS-DOS SET command.<p> 
<B> 
Long Pointer Corrections <p>
</B> 
Bruce Komusin wrote from Monaco to point out some errors in the assembly-language routines: &quot;I just read your article ... about long pointers for C. I never [have] used C, but I know 8086 assembler. From your listing of llsup.asm, it is apparent that you overlooked the fact that the 8086 affects the flags when doing INC or DEC [instructions] for 16-bit [quantities]. This is a common error because it is different on the 8080. So, for example, you can save bytes and time in the routine linc by removing the &quot;OR BX,BX.&quot; <p>

Although this is just an inefficient coding, Mr. Komusin pointed out a real bug: &quot;However, I really wrote this letter to warn you about Idec. Of course, it will not work as is because of the 'DEC BX' changing the zero flag set up by the 'OR BX,BX.' I suggest a change ... that fixes everything:&quot; <p>
<PRE> 
     ldec    proc near 
             or      bx,bx 
             jnz     ldec_1 
             mov     ax,es 
             sub     ax,1000h 
             mov     es,ax 
     ldec_1: dec     bx 
             ret 
     ldec    endp <p>
</PRE> 
Beyond the basic fixes, Mr. Komusin suggested some increases in efficiency: &quot;However, here are some points about execution speed and byte efficiency. It is much faster to 'fall through' a conditional jump than to actually jump. So, if possible, it is always a good idea to arrange the code so that the normal case falls through and only the exceptional case jumps. As a side benefit, the exceptional case can then be shared.&quot; <p>

<a href="#list3-8">Listing 3-8</a> contains a full set of improved routines. <p>With the package of C and assembly language functions that support long pointers under a small memory model environment, users can enjoy the best of both worlds: access to arbitrary amounts/locations of memory, while retaining the efficiency of short pointers for regular code and pointer operations. For compilers that only support the small model, this package allows access to features previously off-limits to 8086 C programmers. <p>
<CENTER>
<B>
PART 4: C INPUT-OUTPUT FUNCTIONS AND LANGUAGE PHILOSOPHY <p>
</B>
</CENTER> 
The C language and its runtime library are distinct concepts. The following discussion brings to light important topics concerning the state of C and its runtime library. It also helps to distinguish C from other popular languages. <p>
<B> 
Low Level Input-Output in C <p>
</B> 
Patrick Cawood of Los Angeles, California, wrote, &quot;I read with great interest your ... article [<i>DDJ</i> #86, December 1983] on tendencies in Unix to produce poor operator interaction programs. I seem to have met some of the same in C.
... To provide a secure operator interface, [you do] not echo a keyboard character to the screen until it has been examined and approved by the program. But the <i>getch()</i> function automatically echoes--even line feeds, up arrows, [and so on]!! Function <i>putch()</i> provides an automatic line feed after printing on the screen!! ... I simply cannot believe that anyone would wittingly design these functions as they are, or fail to provide any alternative hardware interfaces--especially considering some of the tasks I've heard were written in C. But perhaps these people writing serious software were all forced to write their own hardware interfaces.&quot; <p>

The problem Mr. Cawood referred to exists in several non-Unix C compilers. To begin with, let's review the problem in the Unix environment. Under Unix, <i>putc()</i> and <i>getc()</i> acquire and return a single character, respectively. However, to offload the host system, many terminal interface boards programmatically handle user input-output in lines. Thus, before any input is received by the host, you must enter a whole line. Naturally, the characters are echoed by the terminal interface hardware/firmware, and only limited line editing is permitted. On output, a whole line is buffered before transmission to the terminal. This process can be overcome by use of the &quot;raw&quot; terminal mode (raw implies no host character processing). In this mode, the program is completely responsible for input-output. This mode is much more expensive in terms of input-output cost, since the host must handle an interrupt for each input character and perform an output request for each printed character. However, this is the only way for a program to get full control of what is entered, and what appears on the display device.<p>

 With the introduction of C to microcomputers, compiler implementers often based the behavior of the runtime libraries on their Unix experiences rather than on The C Programming Language. Thus, whole lines are prebuffered by typical C runtime libraries before a single character is received by <i>getc()</i>. Conversely, a whole line of output is internally buffered before it is printed on the display. Thus, the runtime libraries of microcomputer C compilers often emulate the terminal hardware found on real Unix systems. However, this is not what <i>putc()</i> and <i>getc()</i> are supposed to do. In the truest sense, raw mode is the fundamental terminal mode. These functions should really work on a character-by-character basis. C libraries should permit selection between the &quot;raw&quot; and &quot;cooked&quot; modes (and echo, no-echo) and thus permit input-output flexibility without resorting to assembly language routines.<p>
 
One C compiler that correctly handles the low-level input-output is the Q/C compiler from The Code Works. For example, single characters are only required when a <i>getchar()</i> call is made. However, it doesn't seem possible to turn off the echo. Nevertheless, this can be effected under Q/C, since The Code Works is kind enough to provide runtime and compiler source code. <p>
<B>
Comments about C Input-Output <p>
</B> 
Mike Meyer wrote, &quot;What you haven't seemed to realize is that almost every flaw in Unix also appears in C. C is terse, doesn't protect the user, and is poorly documented. The only documentation for C is K&amp;R, which may be well written, but is vague and inconsistent on all the points you turn to when you start implementing the language on new machines. To make matters worse, nobody (and I do mean nobody) sells a compiler that conforms to K&amp;R, not even AT&amp;T. I don't think anybody ever has, in any case. AT&amp;T distributes a version of pcc [portable C compiler] that met K&amp;R internally, but I think that by the time it was released externally, C had grown past K&amp;R.&quot;<p>
 
Gerald I. Evenden of North Falmouth, Massachusetts, responded about C input-output as follows, with quite a different point of view: &quot;I was very disturbed with a basic concept about the C programming language that you kept implying in your column ... First of all, I suggest that you carefully read the beginning paragraph of chapter 7 of Kernighan and Ritchie's <i>The C Programming Language</i>. It begins with, 'Input and output are not part of the C language...' What remains is a description of I/O procedures contained in a standard UNIX library that will take care of most filter types of functional operations. I have generally found them to be quite adequate for most programming efforts involving stream data and simple question-answer type of console I/O.&quot;<p>
 
I am aware of the distinction between the C language definition and the standard input-output library. In teaching students how to program in C, this is one of the first points I emphasize: C is a language that gives no special favoritism to a specific set of input-output routines. One standard set does exist, and this is the Unix standard. I consider this an essential feature of C, but I believe a discussion of a real C compiler environment cannot always be separated from a discussion of the support library that comes with it. I also maintain that the Unix input-output library is more than adequate for dealing with stream operations. Mr. Evenden summarizes the distinction between C and C input-output as follows: &quot;The beauty of C is that it doesn't have [a] plethora of specialized built-in functions, but rather provides programmers with a rich facility to build tools required for their own, and occasionally specialized, needs. Obviously, we shouldn't have to redesign all the wheels needed, so most suppliers of C compilers include a library of functions patterned after the Unix libraries. But remember, there is absolutely no requirement to use them if they don't fit your needs, and they should only be viewed as a preliminary toolkit.&quot; <p>

One point that merits further exploration is that of portability. It is well and good to preach the separation of C and C input-output, but only software that uses standard Unix input-output calls (and routines built on them) have a prayer of being moved readily between different machines or even between different compilers on the same machines. <p>

In this regard, Mr. Evenden wrote, &quot;I suspect that your problem with getc [and similar expressions] is related to screen editing and control, which is a category of program that doesn't fall into the filter class of function emphasized by Unix (and its libraries), and I certainly agree that these functions don't work in this case... the astute programmer writes <i>rawin()</i> and <i>rawout()</i> to satisfy those needs. There's nothing to prevent it and everything to encourage it... The worst possible outcome of the problems posed in your article is to even remotely suggest rewriting the current stream I/O functions. Their current form is a de facto standard and a consistency of implementation is expected by most C programmers.&quot; <p>

I really don't expect anyone to throw away the existing stream functions. Not only would this be unreasonable, it would also be undesirable. However, clean raw input-output should be supported; it needn't be reinvented each time a Unix programmer discovers that stream input-output is inconvenient for interactive purposes. In discussing a similar worry expressed by Mr. Meyer, I summarized my argument by stating that interactive programs comprise a large fraction of those run by Unix users, and that when programmers write an interactive program, they do not usually want the user to be treated like an input file. <p>

Despite the extremely outspoken way Mr. Evenden lectured me in his letter, we agree in many respects. However, some things he brought up demand careful examination. He stated, &quot;The principal point of this complaint is that you should be a little more careful of what you are talking about. Writing about problems with C I/O is impossible, since C I/O doesn't exist. However, your less experienced readers will take your complaint to heart and decide that C is a useless language because Mr. Skjellum and others don't like the optional I/O library supplied with their compiler. If you were more positive in your approach, you would be telling readers how to write their own procedures to do specialized console I/O on Unix, CP/M, and so on. I've done it on both CP/M and Unix and found it to be a piece of cake in both cases, and I never gave the getc group a second thought when it was obvious it was not meant for the job at hand.&quot; <p>

I have based my comments on several years of experience with C under Unix, CP/M, VMS, and so on. It is necessary to come to grips with reality. C input-output, although optional, is normally what users must utilize to deal with a problem at hand; consequently, inexperienced users must lean more heavily on the standard library than experienced users. It is meaningful to discuss C input-output. It does exist, and Mr. Evenden discussed several points about it before stating that the topic is beyond the realm of discussion. Inexperienced users learn by reading dialogue between others who have seen problems in their own work. Censoring this information to &quot;protect&quot; such users from disenchantment with C is an unacceptable alternative. <p>

We have not reached the computer millennium. C and Unix as existing tools have flaws and drawbacks. Only through discussion can we seek solutions and create improved future systems. The idea of restricting discussions based on semantic points seems to be contrary to that goal. Some other writers have taken the approach that C and Unix are &quot;wonderful&quot; tools and heap praise on them in review after review. Certain factions feel highly insulted if this approach is not followed. In an evolving field, it makes sense to criticize as part of the learning process. That is why I include Mr. Evenden's final remarks, because I think that he has drawn a counterproductive conclusion from an understandable point of view: &quot;C is not a perfect language, but it certainly beats what's in second place. Consequently, my enthusiasm about C makes me very chauvinistic about misplaced and invalid criticisms. I have a couple minor complaints about some aspects of C, but I bite my tongue when I think about the dark ages. After several happy years with Algol in the 1960s, I was sentenced to over ten years of Fortran purgatory before being born again with C. I guard this language jealously, and you had better be careful of what you write or I'll curse you to a task of debugging 10,000 lines of Basic code.&quot; <p>

Based on the above discussion, Mr. Evenden sent in further comments, which appear next.<p>

<B> 
An August Response<p> 
</B> 
Mr. Evenden was extremely displeased with my comments about C, because he felt that they could convey the wrong impressions to the uninitiated. Furthermore, he felt it unfair for me to discuss C I/O libraries without strongly disclaiming that C and its libraries are completely separate concepts (which they indeed are). He now wrote, &quot;In regard to your response to my letter ... I must expand upon some of my earlier points and make some additional comments. In addition, please excuse the excesses of a middle-age curmudgeon. Scars acquired in numerous battles of the computer wars tend to create a knee-jerk reaction when I sense potentially deviant and dangerous thought processes. I wanted to emphasize that the compiler and the support library are distinct entities, and we must be careful to maintain the distinction. When I talk of C, I am referring to the compiler ... when I talk about the C library, I am referring to what is currently a vague and poorly defined item.&quot; <p>

The original concept of a C library is defined in <i>The C Programming Language</i>. There are other libraries available on Unix systems, but these vary from installation to installation, and from version to version. I agree with Mr. Evenden that the words C Library are currently vague. Indeed, we should standardize functions that are not inherently Unix-only features. For example, we should include the following: <p>
<UL> 
<LI>&quot;block&quot; input-output (<i>read</i>, <i>write</i> and relatives) 
<LI>stream input-output functions (<i>fopen</i>, <i>fwrite</i>, <i>fputc</i>)
<LI>memory allocation functions (<i>calloc</i>, <i>malloc</i> ...) 
<LI><i>setjmp</i>/<i>longjmp</i> procedures 
<LI>alarm (but not signal, since Unix-dependent)
<LI>exit 
<LI><i>scanf</i>, <i>printf</i>, and relatives <p>
</UL>
Furthermore, we should include the Unix math library, since these are fundamental routines (for example, <i>sin()</i>, <i>exp()</i>). Readers may wish to formulate an exact list for exclusion and inclusion. <p>

Mr. Evenden continued, &quot;This sensitivity to the compiler-library problem is caused by having to deal with compilers where too many features that should have been relegated to the support library were included as part of the compiler [that is, language definition]. For example, Fortran gives us READ, WRITE, and a few other input-output support operations that must be treated by the complier as special operations, since the syntax does not match normal external module calls (of course, external modules are involved, but they are transparent to the programmer). When specialized input-output is required that can't be handled by these statements, all sorts of contortions are done by the programmer to get around these restrictions ... typically these gyrations are specific to the host system. In addition, many manufacturers compound a bad situation by supplying a compiler with supplementary functions to provide access to unique features of their system. Good-bye, transportability!&quot; <p>

Mr. Evenden is 100 percent correct. Fortran's implicit connection of input-output functions to the language is a terrible failing. Pascal also suffers from this malady, even though it is a newer, structured language. Evenden continued with the following remarks: &quot;In the case of C, compiler users do not have to go out of their way to handle special input-output syntax, and programmers utilizing the typical C library can go to basically three levels of input-output to handle the problem: <p>
<UL> 
<LI> Basic block 'read'-'write' 
<LI> Buffered (stream) input-output with the <i>getc()</i>, <i>putc()</i> functions 
<LI> Fortran-like <i>scanf()</i> and <i>printf()</i> operations. <p>
</UL> 
This is an excellent example of building-block code: the read-write level is the lowest level and is the only place where we have to deal with the host machine's operating system; each successive level uses the previous level's entries. Application programmers can thus choose the starting level best suited to the job and add the remaining tiers of code to perform the task.&quot; <p>

Given this buildup of the C library, Mr. Evenden returned to the reasons for his original objections: &quot;One of the principal fears I have is that if we get to talking of the C compiler and a standard library in one breath, we will find some well-meaning ignoramus developing a C compiler with built-in input-output functions (or, for that matter, other 'special' features). In this situation, our input-output is engraved in stone and we will be forced back into the same situation involved in Fortran coding. With C, we can individually or collectively trash the input-output part of the library in favor of some new software and still preserve the compiler itself. In addition, the old software is still good as long as we maintain a working copy of the old library. We often cannot do this if the compiler has been rewritten. I would much rather try to transport a program where a few specialized routines had to be rewritten than have to deal with compiler variations.&quot; <p>

To summarize, the principal points Mr. Evenden made (and with which I agree) are: <p>
<OL> 
<LI> Computer languages like C are superior because they segregate their library from 
        the language definition.
<LI> Because of this, the language offers greater rmaintainability, even through 
        revisions of the libraries, because we can retain old libraries more readily than whole 
        compiler environments. 
<LI> Specialized applications can completely ignore the standard software library 
        without any loss of power. 
<LI> When informing or teaching people about C, we must emphasize this unique 
        feature to ensure that it is retained in future incarnations of the language. I hope 
        that future languages will also be constructed in this way. <p>
</OL> 
Mr. Evenden, to summarize his point of view, stated, &quot;The problem of C libraries and what is a 'standard' C function is not yet resolved and needs further discussion. Tight binding of C and Unix is unfortunate, and we need to disassociate the two if we are to encourage non-Unix use of C and transportable C software. An important part of this unbinding is specifying a viable C library that can be installed without ambiguity and omission on a wide range of operating systems.&quot; <p>
This is similar to what I mentioned above. I encourage readers to work along these lines. <p>
<CENTER>
<B>
PART 5: SCIENTIFIC USES <p>
</B>
</CENTER> 
The purpose of this section is to illustrate scientific uses of the C programming language by examples and to present routines useful in conjunction with scientific programming--some general and others that implement specific numerical algorithms. This material is intended for specific audiences. The first audience is the group of die-hard programmers who refuse to change languages and continue to produce useful programs in outdated languages. Not only is this of greater expense to themselves, but it also cheats others by locking them into Fortran or other old-fashioned languages. For them, I want to illustrate the elegance and versatility of C. <p>
The second audience (which may also include the first as a subset) are those users interested in scientific applications but who may not have used C for this purpose. This section is intended to illustrate that C is completely acceptable for such purposes, and the code shows how general concepts can be presented. (I make no attempt to survey scientific applications where C could be used, but merely to include some nontrivial examples). Finally, for those readers who don't fit into the above categories, the general purpose routines will still prove interesting.<p>
 
I present three programming systems. The first is a set of general purpose subroutines designed to simplify the process of user-program interaction and to provide a straightforward means for handling erroneous input. The input mechanisms are not particularly sophisticated, but emphasize structure in the user's program. The routines make range checking so automatic that the programmer has no excuse for omitting such checks, regardless of how &quot;quickly&quot; a program is to be completed. Providing these routines to novice programmers in the classroom has eliminated a lot of frustration over using the <i>scanf()</i> function. <p>

The second and third programming systems illustrate Runge-Kutta integration. The Runge-Kutta formalism is a standard numerical technique for handling the numerical integration of one or more ordinary first-order differential equations. Interested readers may wish to consult the book <i>Numerical Analysis</i>, by Richard L. Burden and others (Prindle, Weber, Schmidt Publishers, second edition, 1981). This is the source for the algorithms presented in the code and is also a fine reference for introductory numerical methods. The choice of Runge-Kutta routines as examples was based on their widespread use in scientific work. (Note: Interested readers may wish to consult the article &quot;C Instead of Fortran?,&quot; <i>Computer Language</i>, 2(2), February 1985.) In this article, I describe more of the advantages of C for scientific and engineering applications. <p>
<B> 
Acknowledgments <p>
</B> 
The general purpose library has received extensive use by Caltech students during the past eighteen months. Thanks are due to Scott Lewicki and Russell Natter, who each discovered minor details that caused major errors. <p>

The Runge-Kutta code was developed by Michael J. Roberts and myself. Mr. Roberts developed the major portion of the RKSYS (multiple equations) routines as a project for Caltech's Physics 20 course: Introduction to Computational Physics. We spent approximately sixty hours altogether in developing, testing, and debugging this code. Mr. Roberts also wrote the original version of the documentation for RKSYS, included in modified form as Table 3-12. <p>
<B> 
GPR: General Purpose Routines <p>
</B> 
The general purpose library consists of five subroutines. Four of these subroutines deal with input. The fifth, a simple facility for printing files to the console, is called <i>display()</i> and will be considered separately from the input functions. <p>
The other routines are <i>iinp()</i>, <i>finp()</i>, <i>sinp()</i> and <i>cinq()</i>. The first three provide integer, floating-point, and string input, respectively. The fourth is a yes-no question processor. The exact calling sequences for each of the routines is provided in Table 3-9. <p>
<CENTER>
<b>Table 3-9: Calling Sequences for General Purpose Routines</b> 
<p>
</CENTER>
<PRE> 
   1. int iinp(prompt, cflag, low,high); 
 
      char *prompt: optional prompt string to be printed before input 
      char cflag: checking flag: if nonzero, range checking is performed 
      int low 
      int high:   low, high are (inclusive) range checking values 

       iinp() repeats input until a valid number is entered; the valid 
      number is the function's return value. 
 
   2. double finp(prompt, cflag, low, high); 
 
      char *prompt: optional prompt string to be printed before input 
      char cflag: checking flag: if nonzero, range checking is performed 
      double low 
      double high: low, high are (inclusive) range checking values 
 
      finp() repeats input until a valid number is entered; the valid 
      number is the function's return value 
 
   3. len = sinp(prompt,string,length); 
 
      int len:   length of entered string 
      char *prompt: optional prompt string to be printed before input 
      int length: maximum length of input string 
 
      sinp() ignores leading spaces. 
 
   4. retn = cinq(prompt); 
 
      int retn:   1 --&gt; 'Y' was typed, 0 -&gt; 'N' was typed 
      char *prompt: optional prompt string to be printed before input 
 
   5. retn = display(fname); 
      int retn:   0 --&gt; success, -1 --&gt; failure 
      char *fname: null-terminated name of file 
 
      <i>display()</i> prints the specified file on the standard output device.<p> 
</PRE> 
Traditionally, user input is effected by a sequence of instructions, such as the following sequence for entering an integer: <p>
<PRE> 
     #define MIN 10 
     #define MAX 100 
     ... 
 
     int input; 
     ... 
 
     while (1)       /* input loop */ 
     { 
             printf(&quot;Enter input variable --&gt; &quot;); 
 
             if (scanf(&quot;%u&quot;,&amp;input) != 1)     /* get variable */ 
             { 
                     drain();         /* drain spurious characters */ 
                     continue;        /* skip range checks */ 
             } 
 
             /* do range checking */ 
 
             if ((input &gt;= MIN) &amp;&amp; (input &lt;= MAX)) 
                     break;          /* we are done */ 
 
             printf(&quot;\nNumber out of range\n&quot;); 
 
     } /* keep looping until scanf() can read a variable */ <p>
</PRE> 
Entering this sequence repeatedly can be tedious from a programmatical point of view, so error checking is often omitted. This practice leads to programs that do not handle users' mistakes intelligently. The GPR routines allow the above sequence to be replaced by a single line of code: <p>
<PRE> 
     input; = iinp(&quot;Enter input variable --&gt;&quot;,1,MIN, MAX);<p> 
</PRE> 
Since using the GPR input functions is easier than using <i>scanf()</i>, this variety of function should be well received, and it can be used in lieu of<i> scanf() </i>for most purposes. A further advantage of these functions is that they unclutter the program. More sophisticated checking will still need to be included explicitly; the input functions do only range checking. <p>

The <i>display()</i> function was included to encourage users to provide online help/documentation along with their programs. This function allows users to print out additional text whenever appropriate. With this function, a trivial online help facility can be created; a help feature is almost always appropriate, but is usually omitted.<p>
 
The GPR routines are in <a href="#list3-9">Listing 3-9</a>. The current list is not exhaustive, but intended only to suggest a trend for additional routines. <p>
<B> 
RK4: Runge-Kutta Algorithm <p>
</B> 
The general purpose library simplifies the task of correct input. Now let's consider a scientific application of C: single equation Runge-Kutta integration. Before introducing the code, some background is required. <p>
 
Start with a differential equation in the canonical form <p>
<PRE> 
     y' = f(y,t)<p> 
</PRE> 
where <i>y'</i> is the first derivative of <i>y</i> with respect to <i>t</i> and <i>f(y,t)</i> is a piecewise continuous function of its arguments. In addition to the differential equation, you are given an initial condition: <p>
<PRE> 
     y(t=0) = y0 
</PRE> 
where <i>y0</i> is some real constant (for example, 35.1). These two equations uniquely specify the solution <i>y(t)</i>, which is as yet unknown. The need for numerical techniques arise when the differential equation cannot be solved analytically. <p>

There are many possible numerical approaches to the solution of this equation, but considering them is beyond the scope of the current discussion. For now, it is sufficient to state that a technique exists called RK4 (Runge-Kutta fourth order) that can solve the equation numerically with known error characteristics. Solution of a typical equation is presented in <a href="#list3-10">Listing 3-10</a> for the equation <p>
<PRE> 
     y'(t) = 1 + t-y 
</PRE> 
with the initial condition <p>
<PRE>
     y(t=0) = 5.0 
</PRE>
Since this equation can also be solved analytically, a comparison is made with the exact solution to demonstrate error characteristics of the method. The analytical solution turns out to be <p>
<PRE> 
     y(t) = t + 5.0.*exp(-t) 
</PRE> 
This latter result can be deduced by inspection.<p>
 
The Runge-Kutta algorithm and code is presented in <a href="#list3-11">Listing 3-11</a>. Readers interested in more information should consult the book by Burden and others, cited above. Calling sequences are described in Table 3-10. <p>
<CENTER>
<b>Table 3-10: RK4: Runge-Kutta Integrator</b><p> 
</CENTER>
<PRE> 
                       Description: 
 
   File: RK4.C, Subroutine Library. Listing 3-11 
           The C language call is as follows: 
                   rk4(function,a,b,n,alpha,t,w); 
   where: 
            function      returns the right-hand side f(y,t) of the system. 
           a              is the start of the interval of integration 
           b              is the end of the interval of integration 
           n              is the number of integration steps 
           alpha          is the initial value y(0) - alpha 
           t              is the array where the times will be stored 
           w              is where the approximations to y will be stored 
 
     The formal C definitions for the function and its parameters are: 
 
     1. rk40: n step integrator 
 
        rk4(function,a,b,n,alpha,t,w) 
        double (*function)();    /* function giving f(t,y) */ 
        double a;               /* beginning of interval */ 
        double b;               /* end of interval */ 
        int n;                  /* number of steps in interval */ 

        double alpha;           /* initial condition for y */ 
        double t[];             /* array for returning T[i] values */ 
        double w[];             /* array for returning W[i] values */ 
 
     2. rk4_1():1 step integrator 
 
        rk4_1(function,h,time, yapprox) 
        double (*function)();         /* Pointer to function to integrate */ 
        double h;                     /* Step size */ 
        double time;                  /* Current time step */ 
        double *yapprox;              /* Current approximation of function */<p> 
</PRE>
<B> 
RKSYS: Systems of Differential Equations <p>
</B> 
Imagine now that you have a set (system) of N first-order ordinary differential 
equations: <p>
<PRE> 
     yi'(t)=fi(t,yi,yi,...,yi)     (i = 1,2,...N) <p>
</PRE> 
This problem is useful for solving other systems, too, since sets of linear differential equations involving higher-order derivatives can be transformed to larger systems of the above variety (see Burden). Thus, a program that can solve the above system has reasonably wide applicability.<p>
 
Unfortunately, the problem is more complicated for N equations than for one equation, as is evident from Table 3-11, in which the more general Runge-Kutta software is described. (<a href="#list3-12">Listing 3-12</a> contains the actual code.) <a href="#list3-13">Listing 3-13</a> and <a href="#list3-14">Listing 3-14</a>are example programs that use <i>rk4n()</i> to solve small systems of equations. Listing 3-13 implements the same problem as <a href="#list3-10">Listing 3-10</a>, but using <i>rk4n() </i>instead of <i>rk4()</i> to perform the integration. <p>
<CENTER>
<b>Table 3-11: RK System Solver (RKSYS)</b> <p>
</CENTER>
<PRE>
   Files:      RKS.C             Subroutine library: Listing 3-12 
                 RKST1.C         Test program #1: Listing 3-13 
                 RKST2.            Test program #2: Listing 3-14 
 
         The format of the C language call is as follows: 
 
               rk4n(function,wsource,wstore,m,a,b,n,alpha,t,kuttas); 
 
   where: 
 
         function     is a pointer to the function that will return the 
                          first derivatives of each function in your system. 
                          It will be called as: 
 
                              function(j,i,tval,rk..comp) 
 
                         where: 
                              j       is the current time step 
                              i       is the current function 
                                      number (0, 1, ..., m-1). 
                              tval    is the current time value 
                              rk_comp is a pointer to a function that your 
                                      derivative function must call as: 
 
                                      rk_comp(n,j,i) 
                       where: 
                                      n is the function number in the 
                                      system (0,...m-1) of the 
                                      function you wish to evaluate. 
                                      j is the time step. 
                                      i is the current 
                                      function number. 
 
   wsource         is a pointer to your function that will return a W 
                         value (which will have been stored by the user's
                         WSTORE routine -- you need only worry about storing 
                         and returning these values, not the values themselves). 
                         It will be called as: 
                           wsource(j,i) 
 
                   where: 
                           j      is the current time step. 
                           i      is the current function number. 

 
   wstore          is a pointer to the user's function that will store 
                       values of W (see wsource above). It is called as: 
 
                           wstore(j,i,value) 
 
                   where: 
                           j      is the current time step. 
                           i      is the current function number. 

                           value  is the value to be stored for that  location. 
 
                           Note: wsource(j,i) should be equal to &quot;value&quot; 
                           after wstore(j,i,value). 
 
   m         is the number of equations in your system. 
 
   a          is the starting time value for the interval. 
 
   b          is the ending time value for the interval. 
 
   n          is the number of points into which the interval is to be broken. 
 
   alpha      is a one-dimensional array of the initial values. The 
              value alpha[0] is the first function at time: a, 
              alpha[1] is the second, and so on. 
 
   t          is a one-dimensional array where rk4n() will store the 
              time values as it calculates them. It must be at least  as large as n. 
 
   kuttas     is a two-dimensional array, the size of whose second 
              element is 4 (that is, kuttas[][4]). It will be the 
              storage area for &quot;k&quot; values as they are calculated. 
 
      The formal C definitions for the function and its parameters are: 
 
      double rk4n(function,wsource,wstore,m,a,b,n,alpha,t,kuttas) 

      double (*function)(); 
      double (*wsource)(); 
      double (*wstore)(); 
      int m; 
      double a; 
      double b; 
      int n; 
      double alpha[]; 
      double t[]; 
      double kuttas[][4]; 
 
   Comments on array sizes, (*wsource)(), (*wstore)(): 
 
       The <i>(*wstore)() </i>function should trap out-of-bound storage requests that 
   result as a natural part of the<i> rk4n()</i> algorithm. A more elegant solution 
   is to make the array size used by <i>(*wstore)()</i> one greater than the number 
   of steps. <p>
</PRE>
<B> 
How to Use the Integrator <p>
</B> 
The rk4n() subroutine will solve a system of first-order differential equations as specified by the calling program, using the Runge-Kutta order four integrator described in Burden and others, pages 239-240;see also page 205. <p>

The calling program must provide information for the <i>rk4n()</i> subroutine for it to solve the system of differential equations. This information must consist of: <p>
<UL>
<LI> The first derivatives of each of the functions in the system 
<LI> Subroutines to store and retrieve values as the functions are integrated 
<LI> Initial conditions for each of the functions 
<LI> The range over which the function will be integrated 
<LI> Storage areas for the time and intermediate &quot;K&quot; value arrays.<p> 
</UL> 
The information must be provided in a specific order and format, which is described in Table 3-11.<p>
 
By studying the Runge-Kutta routines, you will notice the central importance of pointers to functions in the organization of the code. Using this concept effectively allows the software to be completely divorced of the specifics of your program. <p>

In this section, three sets of example routines were presented. This code was included to demonstrate how scientific applications and related software is actually implemented in C. Studying the examples should help you gain insight into the use of C for similar undertakings. <p>
<B> 
Availability <p>
</B> 
All the code presented with Part 5 is copyright 1983, 1984 (c) by the California Institute of Technology (Caltech), Pasadena, CA 9112.5. All rights reserved. This code may be freely distributed, used for all noncommercial purposes, but may not be sold for profit. <p>
<CENTER>
<B>
PART 6: X: EXTENDED C GRAMMAR <p>
</B>
</CENTER>
The first five sections have been devoted to C as it exists in the real world. In this section, I discuss some proposals for increasing the power and flexibility of C. Many languages go through regular upgrades and improvements (for example, Fortran IV, Fortran 66, and Fortran 77). C has undergone fewer changes than other popular languages. The lack of upgrades is probably due mainly to C's lack of intrinsic functions, but clearly points to the basic elegance and power of C. <p>

I am aware of only a few upgrades beyond the language definition specified in <i>The C Programming Language</i> (K&amp;R). These are enumerated types and structure assignment. Both features were introduced with Unix version 7 and are detailed in Unix 7 documentation. Structure assignment is useful in what follows, but type enumeration will not be mentioned. Therefore, although our definition is based on the Unix 7 version of C, this is not likely to confuse those who have access only to <i>The C Programming Language</i>. <p>

Purists may argue that I have no business recommending changes or upgrades to C. Others may argue that many of the suggestions can be implemented via compiler preprocessors or by function calls and need not be part of the language. (This second point is discussed below.) In order to head off the criticism that I am &quot;tampering&quot; with the C language, I offer my recommendations as a new language grammar based on C but called X. I chose the letter X to denote language extensibility, which is the main point of the following proposals. <p>
<B>
Language Extensibility <p>
</B> 
Most languages allow user-defined functions and subroutines, and many newer languages allow user-defined data types. Extensible languages such as Forth and APL allow functions, operators, and data types to be added to the programming environment in a way that makes them equivalent in stature to predefined operations. C retains tremendous flexibility by excluding intrinsic functions, but it does not allow user-defined types to be treated as easily as ints, longs, or floats. Specifically, you cannot extend the definitions of operators such as addition or multiplication to new data types created with typedef. This means that function calls must be used; although this is a completely viable approach, it lacks elegance. This concept is illustrated in the following example. <p>

I need to define a data type called COMPLEX, which will function like Fortran's complex data type. This data type is used for handling complex numbers of the form<i> A + iB</i>, where <i>i</i> is the imaginary unit and <i>A</i> and <i>B</i> are real numbers. This might be done with the following definition: <p>
<PRE>
     typedef struct /* complex number type definition */ 
     { 
             double _creal;     /* real part */ 
             double _cimag;  /* imaginary part */ 
     } COMPLEX;<p> 
</PRE> 
I will work with several variables of type COMPLEX (for example, alpha and beta), which are defined as follows:<p> 
<PRE> 
     COMPLEX alpha, beta;   /* alpha and beta are complex #'s */ 
<p>
</PRE> 
Up to this point, I have treated the complex data type equivalently to built-in types. You can also work with pointers to or arrays of COMPLEX, so there is no deficiency along these lines. However, to assign, add, multiply, or subtract these COMPLEX variables, subroutines would have to be invented. Subroutines for two representative operations are illustrated in Figure 3-1. <p>
<CENTER>
<b>Figure 3-1. Subroutines for two representative operations.</b>
<p> 
</CENTER>
<PRE> 
   Assignment: alpha = A + iB; /* pseudo code */ 
 
   Function: 
           calling sequence  (K&amp;R C):     cassign(&amp;alpha,A,B); 
           calling sequence  (Unix 7 C):  alpha = cassign(A,B); 
 
           function definition (K&amp;R C): 
 
                   cassign(comp,a,b) 
                   COMPLEX *comp; 
                   double a,b; 
                   { 
                           comp-&gt;_creal = a; 
                           comp-&gt;_cimag = b; 
                   } 
 
           function definition (Unix 7 C): 
 
                   COMPLEX cassign(a,b) 
                   double a,b; 
                   { 
                           COMPLEX temp; /* temporary variable */ 

                           temp._creal = a; 
                           temp._cimag = b; 
                           return(temp); /* return structure */ 
               } 
 
Addition: gamma = alpha + beta; /* pseudo code */ 
 
Function: 
        calling sequence    (K&amp;R C):    cadd(&amp;gamma,&amp;alpha,&amp;beta); 
        calling sequence    (Unix 7 C): gamma = cadd(alpha,beta); 

 
        function definition (K&amp;R C): 
 
                cadd(gamma,alpha,beta) 
                COMPLEX *gamma; /* destination */ 
                COMPLEX *alpha; /* addend */ 
                COMPLEX *beta;  /* augend */ 
                { 
                        gamma-&gt;_creal = alpha-&gt;_creal + beta-&gt;_creal; 
                        gamma-&gt;_cimag = alpha-&gt;_cimag + beta-&gt;_cimag; 
                } 
 
        function definition (Unix 7 C): 
 
                COMPLEX cadd(alpha,beta) 
                COMPLEX alpha,beta; /* addend, augend */ 
                { 
                        COMPLEX temp; /* temporary */ 
 
                        temp._creal = alpha._creal + beta._creal; 

                        temp._cimag = alpha._cimag + beta._cimag; 

                        return(temp); 
                } <p>
</PRE> 
The pseudo-code presented with the subroutines in Figure 3-1 is the most convenient way to specify the operations desired. If the data types had been intrinsic, you could have used similar real C statements in lieu of subroutines. To use +, *, or other operators with the COMPLEX data type, you must introduce a mechanism for defining these operations.<p> 
<B>
Operators <p>
</B> 
How could you specify new operations? For example, how would you define addition for the complex data type? The following type of definition could be used to extend addition to the COMPLEX type: <p>
<PRE> 
     COMPLEX oper '+'(alpha,beta)     /* X grammar */ 
     COMPLEX alpha,beta; 
     { 
             COMPLEX __temps /* temporary */ 
             __temp._creal = alpha._creal + beta._creal; 
             __temp._cimag = alpha._cimag + beta._cimag; 
 
             return(__temp); /* return result */ 
      } <p>
</PRE> 
The keyword oper is new: oper indicates that the following definition is for an operator. The return keyword used in function calls also appears with a similar meaning. Since COMPLEX precedes oper, this defines an operation over the COMPLEX data type. Since there are two arguments (alpha, beta), the operator is binary. Finally, note that the + is enclosed in graven accents. Quoting by graven accents is chosen as a way to distinguish operator names. Quotation will not always be needed. <p>

To use this new operator (and assuming that = had also been defined), the following statement could be used: <p>
<PRE> 
   gamma = alpha + beta;   /* add complex numbers */ <p>
</PRE> 
Note that I have omitted the graven accents. Since the + can be distinguished from keywords or identifiers in this context, quoting is not required. The operator definition specified above gives the X compiler a means to evaluate the addition request specified in the example statement. The parser would break this statement down until it could pass an argument garnered from the left and right of the addition operator, much as it does with intrinsic operators and data types. Whether this results in a subroutine call or inline code would depend on the compiler's implementation. <p>
<B> 
More on Operators<p> 
</B> 
Operators turn out to be a powerful and useful concept. We needn't limit ourselves to defining standard operations for new types. There is nothing to stop the definition of arbitrary operators. A crude facility already exists for this in C via the parameterized <i>#define</i> statement. However, the above facility is more general and more consistent with the syntax of C than the preprocessor <i>#define</i> approach. To encompass the generation of inline code as provided by <i>#define</i>, include the inline adjective, which could be used as follows:<p>
 <PRE> 
     COMPLEX inline oper `-`(alpha,beta) /* subtraction 
     inline */ 
     ... <p>
</PRE> 
This keyword would instruct the compiler to generate inline code (as opposed to a subroutine call) whenever possible. Its use is analogous to the use of the register adjective: the compiler complies when feasible and silently ignores the request when it cannot comply. <p>

In some cases, C definitions can be shortened when no ambiguity exists (for example, &quot;unsigned&quot; instead of &quot;unsigned int&quot;). Therefore, &quot;inline&quot; would replace &quot;inline oper&quot; in practice. Furthermore, operators would by default work on and return integers, as functions do by default. <p>
<B> 
Other Uses for Operators <p>
</B> 
In my view, operators would be used not only to define existing operations over new data types, but also for specifying other operations over new as well as existing data types. These new operators would normally have alphanumeric names and would thus require quoting in graven accents when they appear in expressions. For example, we define the operation of NAND (negated and) for integers as follows (no graven accents are required in the definition but are required in the below invocation): <p>
<PRE> 
      int oper nand(a,b) 
      int a,b; 
      { 
              return(~(a &amp; b)); 
      } <p>
</PRE> 
To use this in an actual expression, you would have to quote the nand: <p>
<PRE> 
      c = a `nand` b; 
</PRE>
<B> 
Operator Hierarchy <p>
</B> 
C already has a built-in hierarchy for known operations. The most reasonable approach is to give user-defined operators the lowest priority. This might require more parentheses, but seems logical. <p>
<B> 
Pointers to Operators <p>
</B> 
C provides the facility to use pointers to functions. It could potentially prove useful to have pointers to operators as well. A function's address is specified by its name without trailing parentheses. Unfortunately, operator names are used in this way to indicate the operation they represent. To remove the ambiguity in requesting, the pointer, the operator name could be parenthesized (for example, (+) or (`nand`)). <p>
     Using pointers to operators implies that defined operations must have subroutines associated with them. Thus, truly inline operators could have no pointers associated with them. <p>
<B> 
Dichotomy of Operators and Functions <p>
</B> 
Functions and operators are almost the same thing. However, the compiler must know if an operator is binary or unary. Therefore, its definition must be available before use. On the other hand, arguments to C functions are not checked for number or type. Therefore, I choose to keep operators and functions separate, although there is nothing to prevent operators using function calls.<p>
 
To avoid lexical conflicts, operator and function names would have to be different. This is also desirable from a programming viewpoint, to avoid confusion and errors. <p>
<B>
Other Proposals <p>
</B> 
With the addition of operators, the X grammar provides a much more consistent programming environment than standard C. However, there are some other points that deserve consideration. The first of these is providing a means to handle subroutines with a variable number of arguments. This is considered first. <p>

Since C makes no assumptions about its function library, users are free to write their own, should the standard functions prove inadequate. However, users cannot properly handle functions with variable number of arguments, as must be done by <i>printf()</i>, <i>scanf()</i>, and their relatives. You can solve this problem by introducing a typing adjective called vec, which is short for vector. This adjective is used to indicate that the number of arguments to the function is variable. For example, the fictitious function <i>my_printf()</i>, which allows variable arguments (and returns an integer), would be defined as follows: <p>
 <PRE>
     vec int my_printf(argcnt,argvec) 
     int argcnt; 
     char *argvec[]; 
     { 
             /* code goes here */ 
     } <p>
</PRE> 
A function declared with vec always has two arguments: argcnt, argvec. These variables are analogous to <i>main()</i>'s (<i>argc</i>,<i>argv</i>) pair. Before use, a definition of the form: <p>
<PRE> 
     vec my_printf();<p> 
</PRE> 
would be included in each file where <i>my_printf()</i> is referenced. This definition causes command-line arguments to be processed normally: the right-most argument is pushed (placed on the stack) first, and the left-most last, when code is generated. However, the two additional arguments argcnt and argvec are also stacked. The argvec variable points to the stack location where the first real argument is located. Since normal stacks are push-down, this should provide the arguments in the correct order. The argument argcnt contains the number of arguments plus one to account for argvec. This makes it completely analogous to argc. The argument argvec always contains an address, but this is not very useful, if no arguments were specified in the function call. <p>

To illustrate the stacking mechanism, imagine that you invoke <i>my_printf()</i> as follows: <p>
<PRE> 
     my_printf(arg1,arg2,arg3,arg4,arg5); <p>
 </PRE>
For this specific call, the stacking arrangment (excluding any special register saves) would look as specified in Figure 3-2. Note that argcnt is six (five arguments) for this case, as described above. <p>
It might be worthwhile to have variable argument calls, even if the function was not declared as using this calling convention. To allow this, you introduce the ellipsis (...) concept into the argument string. If <i>my_printf()</i> were not declared as <i>vec</i>, you could force variable argument format as follows:<p> 
<PRE> 
     my_printf(arg1,arg2,arg3,arg4,arg5...); <p>
</PRE> 
Always including the ellipsis for this variety of call seems to improve readability, but is not required to remain compatible with current C usage. 
<B> 
Fixed Arguments <p>
</B> 
The argvec variable always points to the first variable specified on the command line. However, the function definition could still explicitly declare a finite number of arguments that it may wish to examine more directly. For example, if the first argument of <i>my_printf()</i> were a control string, you could declare <i>my_printf()</i> as follows:<p> 
<PRE> 
     vec int my_printf(argcnt,argvec,control_string); 
     int argcnt; 
     char **argvec; 
     char *control_string; <p>
</PRE> 
Notice that contents of <i>control_string</i> would be meaningless if argcnt were less than two. <p>

<CENTER> 
<b>Figure 3-2. Memory layout for a variable argument function call</b>. <p>
</CENTER>
<PRE> 
             ____________________ 
             -    Low memory    - 
             ____________________ 
             -      ...         - 
             ____________________ 
             -    argcnt = 6    - 
             ____________________ 
             -    argvec = ADDR - 
             ____________________ 
       ADDR: -       arg1       - 
             ____________________ 
             -       arg2       - 
             ____________________ 
             -       arg3       - 
             ____________________ 
             -       arg4       - 
             ____________________ 
             -       arg5       - 
             ____________________ 
             -        ...       - 
             ____________________ 
             -    High memory   - 
             ____________________ <p>
</PRE> 
One final note about variable argument control is that it enhances a function's ability to detect incorrect input. With reference to <i>printf()</i>, Kernighan and Ritchie state, &quot;A warning: <i>printf</i> uses its first argument to decide how many arguments follow and what their types are. It will get confused, if there are not enough arguments or if they are the wrong type.&quot; If implemented with the <i>vec</i> arrangement,<i> printf()</i> could at least know if it has been given the right number of arguments. It still would not know if they were of the correct types. <p>
<B> 
Variable Length Automatic Arrays <p>
</B> 
Another element of the X grammar is the ability to declare automatic arrays that possess variable length. Since stack displacements are computed at each entry to a block, this only forces a computed size allocation. At worst, a memory allocation mechanism must be tied into the compiler. This latter restriction can be serious if C is used in a very low level environment, such as in operating system development. So you can readily see the use of this feature, X requires the use of the var adjective in conjunction with such definitions. For most purposes, it offers a welcome enhancement. Where it is inappropriate, you should disable this feature via a compiler switch. <p>

As a general example, you can declare a variable length array in the following routine: <p>
<PRE> 
     /* declare an array of integers one larger than 
     argument */ 
     array_test(length) 
     int length; 
     { 
            var int test[length+1]; /* declare array */ 
            ... 
     } <p>
</PRE>
<B> 
A New Looping Structure <p>
</B> 
Many loops are unconditional with breaks generated only from within. Therefore, it is often useful to have an unconditional looping command. This avoids a lot of &quot;while(1)&quot; sequences. This could be implemented as follows:<p> 
<PRE> 
                           loop 
                           { 
                                   ... code ... 
                           } 
replaces 

                           while(1) 
                           { 
                                  ... code ... 
                           }<p>
</PRE> 
<B> 
Preprocessors and Related Comments <p>
</B> 
Preprocessors could be used to implement several of the X features mentioned above. The statements and exqressions would be expanded by the preprocessor into standard function calls. The preprocessor would also provide subroutines from definitions, as needed. New data types could certainly be handled in this way. However, changes to the C parser must be made in order to handle the vec and var features. Trivial additions such as loop can be handled with the existing C preprocessor. <p>

Some programmers may argue that no additions are needed, since most of the features outlined above can be achieved through function calls. In my view, the X grammar makes C more (and not less) consistent because it allows both intrinsic and user-defined types to be handled similarly. It also allows greater portability by defining a means through which variable argument functions can be handled uniformly. In summation, it turns C into an extensible language while adding only a few new keywords.<p>
 
In this section, I have suggested an enhanced C grammar, denoted X to indicate extensibility. It is the (Unix 7) C language with enhancements designed to allow the incorporation of user-specified operators into programs. This should provide more flexible and consistent reference to user-defined data types. Also mentioned were variable length automatic arrays (<i>var)</i> and a mechanism for allowing variable argument functions (<i>vec</i>). Finally, the use of preprocessors for implementing these ideas was mentioned.<p>
 
Now let's turn to reader response to these proposals. <p>
<B>
Comments on the X Grammar<p> 
</B> 
I received several comments about the X grammar. John M. Gamble of Batavia, Ohio, wrote, &quot;Your column on extensions to the C language was very interesting. I have a few comments: (i) To keep analogy between functions and opers, I think it should be legal to declare static opers.&quot; <p>
This sounds fine, but what is a static oper? Since I'm not sure what Mr. Gamble means, I can't really comment. He continued, &quot;(2) I have trouble thinking of any justification for adding one more reserved word (loop) just to do what 'for(;;)' does just as well. If it really offends your eye, couldn't you just use #define to substitute for it?&quot; <p>

I agree. I only mentioned loop because I wanted an efficient way to specify an unconditional loop. This is fine, since for(;;) shouldn't produce unnecessary instructions in object code. Mr. Gamble continued his list of comments as follows: &quot;(3) I think your method of declaring argument lists in vec functions is too limited to be practical. A function list is not analogous to argv, which deals only with character strings. A function, after all, deals with all sorts of variables. To get around this problem, I have thought of two possible solutions: (a)Require that the first argument be a string equivalent to printf's control string. Quite frankly, I dislike this solution. Deciphering the control string would be a pain, and the code needed to deal with this pain would probably ruin C's reputation for compact code. (b)Declare the types of the argument list members in the function itself. This would be efficient and easy to modify later on. For example, say that you wish to have some integer variables, and you wish to exchange their values so that they are in [numerical] order. Rather than going through the trouble of inserting the values in an array, calling a sorting routine, and recovering the values from the array, a vec function called <i>sort_them()</i> might be easier to use. The declaration might be as follows: <p>
<PRE> 
     vec int sort_them(argcnt, argvec) 
     int argcnt; 
     int *argvec[];  /* Integer arguments */ 
     { 
        /* 
         * exchange the values of the argvec array 
         * here 
         * 
         */ 
     } <p>
 </PRE>
If you wanted to make the function more flexible by allowing the ordering to be user-specified, you could have the first argument be a function. Then the declaration would resemble this: <p>
<PRE> 
     vec int sort_them(argcnt, argvec) 
     int argcnt; 
     int *(argvec[0])(); 
     int *argvec[];                 /* The rest are integers */ 
     { 
        /* etc. */ 
     } 
</PRE> 
Of course, you are not limited to integer pointers. A <i>vec</i> function could just as easily have arguments of all sorts. Such an example is: <p>
<PRE> 
     vec char *dunno(argcnt, argvec) 
     int     argcnt; 
     char    *argvec[0]; 
     long    *argvec[1]; 
     double  *argvec[2]; 
     COMPLEX *argvec[3]; 
     int     *argvec[];   /* rest are integers */ 
     { 
        /* 
         * Here we have a function whose first four arguments 
         * are respectively: char, long, double, and COMPLEX 
         * pointers. Anything after that is an integer 
         * 
         */ 
     } <p>
 </PRE>
Since the argvec array consists of pointers only, the addresses of the argument list are passed in, not the values. Therefore, register variables may not be used in the list. Also, since passing addresses is the default, we can drop the &amp; before each variable [in the calling sequence].&quot; <p>

I think Mr. Gamble's ideas are valid and are consistent with my original intentions for an extended grammar. Does anyone else have further comments about vec functions? <p>

Gerald Evenden of North Falmouth, Massachusetts, responded as follows: &quot;Your thoughts about adding definable operators is quite interesting, but I have some reservations. First, I did not see any mention of the order of evaluation and determination of operator precedence. Secondly, the problem of mixed mode of operands also was not considered. For example, <p>
<PRE> 
     COMPLEX a,b,c; 
     ... 
     a = 2. * (a+ b*c); <p>
</PRE> 
would be considered a straightforward expression for complex arithmetic, but it contains binary operators of mixed type and the classic case of operator precedence (is it (a + b)*c or a + (b*c)?). If these problems are not resolved in a more complete set of specifications, I don't feel that the constructs are of much interest. It seems that you may end up putting UNIX's 'yacc' into the preprocessing phase, and this may be more of a challenge than you'd want to bargain for.&quot; <p>

Mr. Evenden's points are well taken. First, I would argue that mixed mode arithmetic should not be supported. Thus, the above expression would be written using a cast: <p>
<PRE> 
     COMPLEX a,b,c; 
     ... 
     a = (COMPLEX)(2.) * (a+ b*c); <p>
</PRE> 
The problem involving precedence is more tricky. One answer is to give all user-defined operators equal precedence and to require parentheses to specify the order of evaluation. However, this would make user-defined operations more restrictive than operations on intrinsic types. <p>

Mr. Evenden continued, &quot;Two of your ideas I find to be plain 'fluff': automatic arrays and 'loop.' Dynamic allocation of memory is readily taken care of by calls to a memory allocation procedure ... if you want to use 'loop' for cosmetic purposes, a define of 'for(;;)' or 'while(1)' does the job nicely!&quot; <p>

I have taken a lot of heat concerning &quot;loop.&quot; The reason I suggested it is rather fundamental. The simplest structured loop is an unconditional loop, which can only be terminated with break. It appeared to me that this should be supported by the language internally. I realize that the form for(;;) does exactly what I want. <p>

I also had specific reasons for suggesting variable length arrays. Algorithms often require variable size arrays, and it is often undesirable to declare an array that is &quot;big enough for all supported applications.&quot; Furthermore, it seems more natural for beginners to specify array declaration in this way. Moreover, the operation would become independent of a specific runtime library feature, which could differ (in principle) between implementations. <p>

Mr. Evenden also addressed the problem of variable length arguments: &quot;The problem with variable arguments is quite nasty ... I am not too keen on your method for solving the problem and would like to suggest an alternative approach. If the compiler would put the argument count of the argument stack at the top of the stack (as per your method) the programmer who needs this information can get it as follows: <p>
<PRE> 
       func(arg1,arg2,...,argN) 
       { 
               int s_size, *dummy; 
               dummy = &amp;arg1; 
               s_size = dummy[-1]; 
       } <p>
</PRE> 
Admittedly, this is clumsy and there should be a better way. My second suggestion is to provide that if the [function] ... name is used in the context of a simple integer, then that integer value will be located at the top of the argument stack ... [it] will contain the [argument] count. [The following example] illustrates the usage of this concept.&quot; <p>
<PRE> 
       double  /* hypothetical routine to return minimum 
       value */ 
       amin()  /* of a list of double precision numbers 
       */ 
       { 
               double *list, min; 
 
               if(amin &lt;= 0) 
                       return(0.0); /* no args condition */ 
 
               list = (double *)(&amp;amin + sizeof(int)); 
 
               for(min = *list++; --amin; list++) 
                       if(*list &lt; min) 
                               min = *list; 
 
               return(min);    /* return the minimum */ 
       } <p>
</PRE> 
I think this second idea has one problem. The name amin without parentheses is treated by C as a pointer to the function amin(). The problem is that a function really has basically three attributes: its address, the number of arguments, and the starting location for the arguments. To access these other attributes, you could add two pseudo-functions analogous to the return() statement. These pseudo-functions are illustrated in the following example, which is a rewrite of Mr. Evenden's last example. <p>
<PRE> 
     double  /* hypothetical routine to return minimum 
     value */ 
     amin()  /* of a list of double precision numbers 
     */ 
     { 
             double *list, min; 
             if(noargs() == 0) 
                     return(0.0); /* no args condition */ 
             list = (double *)(addrof() + sizeof(int)); 
 
             for(min = *list++; --amin; list++) 
                     if(*list &lt; min) 
                              min = *list; 
 
             return(min);    /* return the minimum */ 
     } <p>
</PRE> 
In this example, noargs() returns the number of arguments that a function has received, whereas addrof() returns the starting address (as a pointer to characters). The pseudo-functions return the information about the function they reside in. The mechanism is therefore unambiguous and should be practical.<p>
 
In conclusion, Bob Desinger of Cupertino, California, noted that a much better approach to improving C was suggested in the Bell Labs Technical Memorandum &quot;The C++ Programming Language.&quot; According to Desinger, it offers the following (including examples): <p>
<UL> 
<LI>  User-defined data types (such as complex numbers) 
 <LI> Operator overloading (such as defining + ) 
 <LI> Argument checking for functions [for example, for <i>printf()</i>] <p>
</UL>
 
I have yet to see a copy of this memorandum, but I recommend that interested readers look for it. <p>
<CENTER>
<B> 
PART 7: WISH LISTS<p> 
</B>
</CENTER> 
This section includes some of the shorter (mainly unrelated) subjects that appeared in columns. These subjects often include valuable insights about C and programming in general. Others are just pragmatic ideas. <p>
<B> 
Programming Philosophy <p>
</B> 
John A. Grosberg of Scottsdale, Arizona, wrote an interesting letter concerning programming style and philosophy. He wrote his letter after reading the August 1984 column, which included a short listing by Alex Cameron (see <a href="#list3-1">Listing 3-1</a>, discussed in Part 2). Mr. Grosberg wrote, &quot;Your column ... caught my attention, particularly the short listing of Mr. Alex Cameron's routines to automatically allocate I/O buffers. ... I am writing to present a few ideas on program structure, and I will use his listing as an example. This is not an attack on his application or on the style he used in his listing; I assume that there were reasons for the form chosen. But my perfectionism was provoked by that listing, and the more I read it, the more I wanted to write. One important principle of program design is that the structure of the program (I will use program, routine, and function interchangeably for this discussion) should reflect the structure of the problem. This sounds nice, but what does it mean? Without guidelines it is almost a theological principle, over which well-meaning people could argue loud and long and never come to agreement. The reason for this is that the 'structure of the problem' depends on your viewpoint; that is, it is relative to the observer ... the program's structure reflects the way we are thinking about the problem.&quot; <p>

Since the way we write programs is based on our viewpoint, Mr. Grosberg suggested a set of standard reference points: &quot;In mechanical drafting, there are three standard orthogonal viewpoints that are used to describe most objects. They are called 'front,' 'side,' and 'top' views of the object. The structure of the physical object inheres in the spatial relationships of its elements, and these must be captured in the drawing. <p>
&quot;In software, an important aspect of structure is the temporal relationships among the elements. The two primary temporal relationships are sequence and frequency, and these relationships should be captured in the code. If one action occurs before another in time (sequence), then the first should precede the second in the code. If an action occurs the same number of times (frequency) as another, then they should be in the same (logical) block of code.&quot; <p>

Mr. Grosberg's recommendations are practical, and this type of coding technique could only improve maintainability of software. He continued, &quot;Expanding on the concept of temporal relationships as expressed in code, consider that on any single execution of a program, an element of that program may be executed once, more than once, or less than once [that is, not executed]. If the element executes once and only once per program execution (sequence), it should be simply listed in sequence where it belongs. If the element executes more than once per execution (repetition), it should appear once in a loop. If the element executes less than once per program execution (alternation), it should appear once in a program branch statement. Finally, all elements that execute the same number of times should appear together in the listing.&quot; <p>

Although these points seem obvious to me (and also to Mr. Grosberg), it is clear that they are not often followed. I cannot claim to have adhered to these principles in the past, but I plan to do so in the future. For those interested in pursuing the concepts further, he recommends <i>Practical LCP, A Direct Approach to Structured Programming</i>, by Albert C Gardner (McGraw-Hill, 1980). Mr. Grosberg has recoded Alex Cameron's listing to exemplify his comments; this code is presented in <a href="#list3-15">Listing 3-15</a>. Concerning the code itself, he commented, &quot;In Mr. Cameron's function 'sfopen,' the call to 'alloc' actually occurs only once per execution, but it is written three times in the code [sequence]. The 'return' occurs only once per execution, but is written 10 times [sequence]. The three main 'if' statements <p>
<PRE> 
     if(*mode == 'x') 
     { 
     ... 
     } <p>
</PRE> 
are written as if they occur sequentially, when in fact only one of them can occur per execution [alternation]. The structure of the code actually obscures the execution behavior of the function.&quot; <p>
Mr. Grosberg did not claim to have perfectly embodied his comments in Listing 3-15. He just created it (untested) to illustrate his remarks. I find his ideas worthwhile. <p>
<B> 
Controlling Size of Intrinsic Data Types <p>
</B> 
John M. Gamble of Batavia, Ohio, wrote, &quot;I am very glad you printed this column [August 1984] (I ranked it number one for the month) because it inspired me to jot down my own wish list. It is only one wish long, but it is something I have longed for, for some time.&quot; <p>

Mr. Gamble's wish is for a way to more precisely control the sizes of intrinsic data types in C.!For example, integers can have different sizes on different machines. He continued, &quot;The size of the various types (int, char, long, etc.) vary too much from machine to machine. However, I don't think that forcing a size to a type (a la Plum Hall) is the answer (besides, I hate the baby words Plum uses to define them). Instead, I think that another 'storage class specifier' (see The C Programming Language, page 192) like typedef could be defined. I'm going to call it 'sizetype.' Sizetype would be used just like typedef, but what is declared is the size of the storage class. For example, we could define a type small this way: <p>
<PRE> 
     sizetype u8 small; <p>
</PRE> 
The letter u is optional and stands for 'unsigned.' Thus a variable of type small is unsigned and eight bits long. Another example would be: <p>
<PRE> 
     sizetype 16 hexsize; <p>
</PRE> 
which would guarantee that variables of type hexsize are sixteen bits long.&quot; <p>

I am enthusiastic about Mr. Gamble's suggestion. It would enhance portability of C code. Anyone who has moved between microcomputers and minis is aware that there can be significant problems when moving from machines with signed or unsigned characters. Integer length differences are also annoying. Mr. Gamble added, &quot;Use of the sizetype declaration would guarantee portability between machines (which currently is a problem). It also means that only one more reserved word is added, instead of the many that would be needed to define a type for every conceivable integer length. If the sizeof operator could be altered to return fractions, we could use sizetype to define bit lengths that are not multiples of eight. On the other hand, I notice that the sizeof operation on a bit-field structure is not defined in <i>The C Programming Language</i>, so maybe it is just up to the person who writes the compiler.&quot; <p> <B>
Floating Point Improvements <p>
 </B>
Gerald Evenden wrote about C floating-point deficiencies: &quot;Most of my criticisms [of C] are minor except for one: evaluation of all floating-point data elements in double precision. When two type float values are joined by a binary operator, I fail to see any reason why we should pay the costly runtime premium of double precision evaluation! Of course, conversion of float function arguments to double is equally strange and pointless. I suspect floating-point arithmetic was one of the last features added to the language and got short-changed in the final stages of the development of C. If the people at Bell Labs have any excuse for this peculiar handling of floating point by C, I'd sure like to hear it! Hopefully, some ... readers may also have comments.&quot; <p>

Mr. Evenden has hit on an important point. Not only is the conversion of float to double expensive, programming can get messy when dealing with pointers and arrays. For example, if a program needs a large number of floats (in an array), it is difficult to use with a function that expects pointers to double. I see no reason for using arrays of double precision numbers for many applications. Yet to simplify programming logic, memory must often be wasted (by a factor of two) for floating-point arrays. On systems such as the 8086/8087, the actual cost for single/double precision operations is the same, but conversions and other effects are still cause for grief. <p>

Mr. Evenden continued, &quot;I have given some thought to what would be required to make C's floating point behave in a more traditional manner, and I have come to the conclusion that upward compatibility of a new compiler might not be possible as far as floating-point syntax is involved. Obviously, the 'standard' library routines will have to be changed ('printf' will need '%E' and '%e') ... functions returning floating-point values will have to be in two precisions (sqrt() and dsqrt(), for example).&quot; <p>
<B>
Variable Formats in <i>printf()</i> <p>
</B> 
I'd like to change gears and consider an aspect of printf format strings. Consistent with previous discussions, I remind the readers that this is a discussion relevant to the C library and not the compiler. p>

A typical <i>printf()</i> call might look as follows:<p>
<PRE> 
      float number; 
     ... 
     printf(&quot;%7.3e\n&quot;,number); <p>
</PRE>
 
In certain cases, you might wish to vary the format dynamically. One way to accomplish this is as follows:<p>
<PRE> 
 
     float number; 
     ... 
     char fmt_string[100];      /* make format string here */ 
     char format[10];           /* format contained here */ 
     strcpy(format,&quot;7.3&quot;);      /* copy a specific format */ 
     ... 
     sprintf(fmt_string,&quot;%%%sf&quot;,format); /* make format string */ 
     printf(fmt_string,number); /* print number in format */ <p>
</PRE>
 The format string in the <i>sprintf()</i> is &quot;%%%sf.&quot; The first two percent signs place a single output percent in <i>fmt_string</i>. The %s causes the string format (containing &quot;7.3&quot;) to go into <i>fmt_string</i>. Finally, the letter <i>f</i> is interpreted literally and is sent to <i>fmt_string</i>. The point of giving this example is to show how cumbersome the operation can be. Now I want to pose a simple solution to the problem. <p>

To allow variable formats as part of a single printf(), you need a way to indicate an indirection. Then, printf() could use the current member of its argument list as a source for the format. This is illustrated as follows: 
<PRE> 
     float number;<p>
     ... 
     printf(&quot;%&amp;s\n&quot;,&quot;7.3f&quot;,number); <p>
</PRE> 
The indirect format is &amp;s, which tells <i>printf()</i> to take the first argument as a string and print it into the format string before proceeding. Thus, the ultimate format string is &quot;%7.3f&quot; as originally. Another possibility would be <p>
<PRE> 
     float number; 
     float format = 7.3; 
     ... 
     printf(&quot;%&amp;f\n&quot;,format,number); <p>
</PRE> 
which demonstrates the range of choices allowed by indirect formats. To print an ampersand, the following sequence would be required: <p>
<PRE> 
     printf(&quot;%&amp;&amp;&quot;); <p>
 </PRE>
Why would these be useful? Primarily, they allow programs to readily adapt to data variations. This could allow greater user selection, or, if extended to <i>scanf()</i>, greater ability to read and write &quot;foreign&quot; data files. <p>
<B> 
Conclusion <p>
</B> 
In conclusion, I'd like to quote Gerald Evenden one more time. Concerning future upgrades or modifications of C, Mr. Evenden wrote, &quot;Some people criticize C as being a 'spartan' language, but I maintain that this spartan attribute is its principal and strongest feature ... [C] is a real programmer's language, providing an excellent tool for doing everything from real time processing, to writing other compilers, to sophisticated scientific applications. If we ever make changes to C, we will have to be very careful to maintain this strong feature of the language.&quot; <p>

I leave this quotation as my parting remark. <p>

<b><a name="list3-1">LISTING 3-1</a><p> </b>
<PRE>  
   /* 
   ** stdlib3.c -- standard I/O library 
   ** 
   ** Copyright 1984 A. Cameron 
   */ 

   #include &quot;bdscio.h&quot; 
 
  /* 
   ** 
   **     Standard fopen 
   ** 
   **          return fd on success, NULL on error       ** 
   */ 
 
   sfopen(filename,mode) 
   char *filename; 
   char *mode; 
   { 
           int fd; 
 
           if (*mode == 'w')             /* write mode */ 
           { 
                   if (!(fd = alloc(BUFSIZ))) 
                            return(NUlL); 
                   else 
                   { 
                            if (fcreat(filename, fd) == -1) 
                            { 
                                    free(fd); 
                                    return(NULL); 
                            } 
 
                            return(fd); 
                   } 
 
           } 
 
           if (*mode == 'r')        /* read mode */ 
           { 
                   if (!(fd = alloc(BUFSIZ))) 
                            return(NULL); 
                   else 
                   { 
                            if (fopen(filename, fd) == -1) 
                            { 
                                    free(fd); 
                                    return(NUlL); 
                            } 
                            return(fd); 
                   } 
           } 
 
           if (*mode == 'a')        /* append mode */ 
           { 
                   if (!(fd = alloc(BUFSIZ))) 
                            return(NULL); 
                   else 
                   { 
                            if (fappend(filename,fd) == -1) 
                            { 
                                    free(fd); 
                                    return(NULL); 
                            } 
 
                            return(fd); 
 
           } 
 
           return(NULL); /* failure */ 
 
   } 
 
   /* 
   ** 
   **      Standard fclose 
   ** 
   */ 
 
   sfclose(fd) 
   int fd; 
   { 
           fputc(CPMEOF,fd); 
 
           if (!(fclose(fd))) 
           { 
                   free(fd); 
                   return(NULL); 
           } 
 
           return(ERROR); 
   } <p>
</PRE>  
<b><a name="list3-2">LISTING 3-2</a><p></b> 
<PRE>  
  
 /***********************************************************************   * 
  *                                                                       * 
  *        lsup.c                            created: 25-Mar-84           * 
  *                                                                       * 
  *        long pointer support for small memory model 8086 C compilers.  * 
  *                                                                       * 
  *        version 1.00 as of 25-Mar-84                                   * 
  *                                                                       * 
  *        Copyright 1984 (c) Anthony Skjellum.                           * 
  *        All rights reserved.                                           * 
  *                                                                       * 
  *        This program may be freely distributed for all non-commercial  * 
  *        purposes, but may not be sold.                                 * 
  *                                                                       * 
  *        The routines contained here are designed to be portable to     * 
  *        a large variety of compilers. Currently they have been tested  * 
  *        with Aztec C86 v 1.05i only.                                   * 
  *                                                                       * 
  *        Modules comprising this package:                               * 
  *                                                                       * 
  *                lsup.c          this file.                             * 
  *                lsup.h          header/definition file.                * 
  *                _lsup.h         lower level header for this file       * 
  *                llsup.asm       assembly language support (compiler    * 
  *                                independent)                           * 
  *                llint.asm       compiler interface code (compiler      *
  *                                dependent)                             * 
  *                                                                       * 
  *        Subroutines included here:                                     * 
  *        (those marked with an asterisk are only included if compiler   * 
  *        used lacks some preprocessor support feature)                  * 
  *                                                                       * 
  *                                                                       * 
  ***********************************************************************/ 
 
  #include &quot;_lsup.h&quot;              /* header with definitions */ 
 
  /*           Special routines: Included only if compiler lacks one 
                of  several features.   
 */ 
 
  /* lassign(dest,source): assignment of type LPTR to the left */ 

 
  #ifndef MSUBST 
 
  lassign(dest,source) 
  LPTR dest; 
  LPTR source; 
  { 
          dest._llong = source._llong; /* assignment */ 
  } 
 
  #endif 
 
  /* 
          General purpose routines: 
  */ 
 
  /* llstrcpy(dest,src): copy null terminated strings between long ptrs */ 
 
  llstrcpy(dest,src) 
  LPTR *dest; 
  LPTR *src; 
  { 
          char chr;                       /* temporary */ 
 
          while(1)                        /* loop */ 
          { 
                chr = lchr(&amp;src);         /* get a character */ 
                l_stchr(&amp;dest,chr);       /* store a character */ 
 
                linc(&amp;dest);              /* increment destination ptr */ 
                linc(&amp;src);               /* and source pointer */ 
 
                if(!chr)                  /* we are done at eos */ 
                        break; 
          } 
  } 
  /* debugging routines: */ 
 
  lprint(lptr) 
  LPTR *lptr; 
  { 
          printf(&quot;%lx&quot;,lptr-&gt;_llong); 
  }<p> 
</PRE> 
<b><a name="list3-3">LISTING 3-3</a><p></b> 
<PRE> 
  #include &quot;_lsup.h&quot; 

  /* place any special function specifications (defined in lsup.c) here: */ <p>
</PRE>  
<b><a name="list3-4">LISTING 3-4</a><p></b> 
<PRE>  
  
 /************************************************************************
  *                                                                       * 
  *       _lsup.h                           created: 25-Mar-84            * 
  *                                                                       * 
  *       a component of lsup.c                                           * 
  *                                                                       * 
  *       version 1.00 as of 25-Mar-84                                    * 
  *                                                                       * 
  *       Copyright 1984 (c) Anthony Skjellum.                            * 
  *       All rights reserved.                                            * 
  *                                                                       * 
  *       This program may be freely distributed for all non-commercial   * 
  *       purposes, but may not be sold.                                  * 
  *                                                                       * 
  *       This is a header/definition file which must be included         * 
  *       in any module which utilizes long pointers.                     * 
  *                                                                       * 
  ***********************************************************************/  
  /* 
          compiler feature toggles: 
          comment out any which don't apply to the compiler in use. 
  */ 
 
  #define MSUBST                  /* macro substitution supported */ 
 
  /* typedefs */ 
 
  typedef struct __lword 
  { 
          unsigned _addr;         /* address */ 
          unsigned _segm;         /* segment */ 
  } LWORD; 
 
  typedef union __lptr 
  { 
          long    _llong;         /* long format (for assignments) */ 
          char    _lstr[4];       /* character format */ 
          LWORD   _lword;         /* long-word format */ 
  } LPTR; 
 
  /* constants */ 
 
  /* macros */ 
 
  /* lassign(destination,source): effect assignment of type LPTR */ 
 
  #ifdef MSUBST 
  #define lassign(d,s)    d._llong = s._llong; 
  #endif 
 
  /* function specifications: */ 
 
  char lchr(); <p>
</PRE>  
<b><a name="list3-5">LISTING 3-5</a><p></b> 
<PRE>  
  ; 
  ; llsup.asm 
  ; 
  ; a component of lsup.c 
  ; 
  ; Copyright 1984 (c) A. Skjellum. All rights reserved. 
  ; 
  ; version of 25-Mar-84 
  ; updated: 31-Mar-85 (used with MASM 1.0) 
  ; 
  ; This routine makes no assumptions about the behavior of the 
  ; C compiler in use. 
  ; 
  ; all procedures are &quot;near&quot; 
  ; 
 
  dseg    segment para public 'data' 
  dseg    ends 
 
  cseg    segment para public 'code' 
          assume cs:cseg,ds:dseg 
 
  ; 
  ; linc:        increment a long pointer by 1 byte 
  ; 
  ; expects:     es:bx with long pointer to increment 
  ; returns:     pointer incremented. 
  ; consumes:    es, bx, f, ax 
  ; 
          public linc 
  linc    proc   near 
          inc    bx              ; increment low part of word 
  ;       or     bx,bx           ; is it zero now? (NOT NEEDED --&gt; inc set zf) 
          jnz    linc_exit       ; no, we are done 
          mov    ax,es 
          add    ax,1000h        ; another 64k of paragraphs 
          mov    es,ax           ; store back to es 
  linc_exit: 
          ret                    ; return 
  linc    endp 
 
  ; 
  ; ldec:        decrement a long pointer by 1 byte 
  ; 
  ; expects:     es:bx with long pointer to decrement 
  ; returns:     pointer decremented. 
  ; consumes:    es, bx, f, ax 
  ; 
          public ldec 
  ldec    proc   near 
          or     bx,bx           ; zero currently ? 
          pushf                  ; save condition (BUG FIX) 
          dec    bx              ; decrement it 
          popf                   ; restore condition (BUG FIX) 
          jnz    ldec_exit       ; just decrement low end and exit... 
          mov    ax,es           ; get segment register 
          sub    ax,1000h        ; remove 64k of paragraphs 
          mov    es,ax           ; store back to es 
  ldec_exit: 
          ret                    ; return 
  ldec    endp 
 
  ; 
  ; ladd:        add a constant to a long pointer 
  ; 
  ; expects:     es:bx with long pointer's original value 
  ;              ax with unsigned constant to be added 
  ; returns:     pointer with constant added 
  ; consumes:    es, bx, f, ax 
  ; 
          public ladd 
  ladd    proc   near 
          add    bx,ax           ; add in offset 
          jnc    ladd_exit       ; no carry, so we are done. 
          mov    ax,es 
          add    ax,1000h        ; add 64k of paragraphs 
          mov    es,ax           ; and store back to es 
  ladd_exit: 
          ret 
  ladd    endp 
 
  ; 
  ; lsub:        subtract a constant from a long pointer 
  ; 
  ; expects:     es:bx with long pointer's original value 
  ;              ax with unsigned constant to be subtracted 
  ; returns:     pointer with constant subtracted 
  ; consumes:    es, bx, f, ax 
  ; 
          public lsub 
  lsub    proc   near 
          sub    bx,ax           ; subtract offset 
          jnb    lsub_exit       ; no borrow, so we are done. 
          mov    ax,es 
          sub    ax,1000h        ; subtract 64k of paragraphs 
          mov    es,ax           ; and store back to es 
  lsub_exit: 
          ret 
  lsub    endp 
 
  ; 
  ;lsum:         add a signed offset to a long pointer 
  ; 
  ; expects:     es:bx with long pointer 
  ;              ax with signed offset 
  ; returns:     pointer with constant added (signed) 
  ; consumes:    es, bx, f, ax 
  ; 
          public lsum 
  lsum    proc   near 
          or     ax,ax           ; negative? 
          js     lsum_neg 
          call   ladd            ; do addition 
          ret                    ; and exit 
  lsum_neg: 
          and    ax,07fffh       ; and out sign flag 
          jnz    lsum_neg_ok 
          mov    ax,8000h        ; -32768 value (don't treat as O) 
  lsum_neg_ok: 
          call   lsub 
          ret 
  lsum    endp 
  ; 
  ; lcopy:       copy from one long pointer to another, 
  ;              up to 1024k bytes of data 
  ; 
  ; expects:     ds:si with src address 
  ;              es:di with dest address 
  ;              ds|cx with length (dx is high order, cx is low order) 
  ; returns:     block copied 
  ;              ds, es intact 
  ; consumes:    ax, cx, f 
  ;       this  routine uses a copy downward method, to produce 
  ;       correct copying for overlapping regions 
  ; 
          public lcopy 
  lcopy   proc   near 
          ; 
          ; convert dx into segment form: 
          ; 
          push   dx              ; save original form of dx 
          push   cx              ; save low order of long count 
          and    dx,15           ; smallest meaningful value 
          xchg   dh,dl           ; switch upper and lower parts 
          mov    cl,4 
          shl    dh,cl           ; effect is shift left by 12 bits 
          pop    cx              ; and recover low order of long count 
          ; 
          mov    ax,es 
          add    ax,dx 
          mov    es,ax 
          mov    ax,ds 
          add    ax,dx 
          mov    ds,ax           ; gross adjustment of segments 
          pop    dx              ; recover original form of dx 
          ; 
          add    di,cx           ; adjust dest. ptr to end of area 
          jnc    no_dest_adj 
          mov    ax,es 
          add    ax,1000h        ; add offset 
          mov    es,ax           ; and store back to segment register 
  no_dest_adj: 
          ; 
          ; do same work for source pointer: 
          ; 
          add    si,cx           ; do the addition 
          jnc    no_mor_adj      ; no more adjustment needed if no carry 
          mov    ax,ds 
          add    ax,1000h        ; do the adjustment 
          mov    ds,ax           ; and store back to ds 
          ; 
          ; at this stage: 
          ; 
          ;      es:di is at the last byte of the dest. area 
          ;      ds:si is at the last byte of the src. area 
          ; 
  no_mor_adj: 
          std                    ; set direction flag for moves 
  lc_loop: 
          or     si,si           ; is si zero? 
          lodsb                  ; get byte ds:[si], decrement si 

          jnz    no_ds_adj       ; no need to adjust if non-zero at start 
          mov    ax,ds 
          sub    as,1000h 
          mov    ds,ax           ; adjust pointer for next load 
  no_ds_adj: 
          or     di,di           ; is di zero? 
          stosb                  ; set byte es:[di] = al, decrement di 
          jnz    no_es_adj       ; no need to adjust if non-zero at start 
          mov    ax,es 
          sub    ax,1000h 
          mov    es,ax           ; adjust pointer for next store 
  no_es_adj: 
          loop   lc_loop         ; copy whole block (--cx, jnz lc_loop) 
          dec    dx              ; work on outer loop 
          or     dx,dx 
          jnz    lc_loop         ; loop over dx counts too 
          ; 
          ; we are done 
          ; 
          inc    si 
          inc    di              ; restore to original calling values 
          ret                    ; exit 
  lcopy   endp 
 
  cseg    ends 
          end <p>
</PRE>  
<b><a name="list3-6">LISTING 3-6</a> <p></b>
<PRE>  
  ; 
  ; llint.asm 
  ; 
  ; version of 25-Mar-84 
  ; 
  ; a component of lsup.c 
  ; 
  ; Copyright 1984 (c) A. Skjellum. All rights reserved. 
  ; 
  ; these routines are setup for Aztec C86 v 1.05i 
  ; 
  ; all procedure are  &quot;near&quot; 
  ; 
 
  dseg    segment para public 'data' 
  dseg    ends 
 
  cseg    segment para public 'code' 
          assume cs:cseg,ds:dseg,es:dseg,ss:dseg 
 
  ; 
  ; Routines which do not merit calls to portable routines in llsup.asm 
  ; 
  ; 
  ; ds = flptr(lptr,sptr) 
  ; LPTR *lptr; 
  ; char *sptr; 
  ; 
  ; form a long pointer from a &quot;normal&quot; ds relative short pointer (sptr) 
  ; and store at lptr 
  ; 
  ; note: no portable segment (flptr) in llsup.asm since this 
  ; is such a trivial routine. 
  ; 
  ; return value is also ds, should this prove useful 
  ; 
         public   flptr_ 
  flptr_ proc     near 
         mov      bx,sp           ; prepare for argument load 
         mov      ax,4[bx]        ; get short pointer ds:ax 
         mov      bx,2[bx]        ; get address where to store 
long pointer 
         mov      [bx],ax         ; store low order 
         mov      ax,ds 
         mov      2[bx],ax        ; store high order 
         ret                      ; return value is also ds 
 
  flptr_ endp 
 
  ; 
  ; the following four routines are examples of what can 
  ; be done to supplement general routines with specific 
  ; (more efficient ones). Many more variations are 
  ; possible than the two presented here. They follow 
  ; directly from this basic idea: 
  ; 
  ; 
  ; char lchr(lptr) 
  ; LPTR *lptr; 
  ; 
  ; return character pointed to by lptr 
  ; 
         public   lchr_ 
  lchr_  proc     near 
         mov      bx,sp           ; prepare for argument load 
         push     ds              ; save ds register 
         mov      bx,2[bx]        ; get address of lptr 
         mov      ax,[bx]         ; 
         mov      ds,2[bx]        ; begin forming pointer 
         mov      bx,ax           ; ds:bx now is valid pointer 
         sub      ax,ax           ; zero whole acc. 
         mov      al,[bx]         ; get the character 
         pop      ds 
         ret                      ; exit with char in ax 
  lchr_  endp 
 
  ; 
  ; int lint(lptr) 
  ; LPTR *lptr; 
  ; 
  ; return integer or unsigned pointed to by lptr 
  ; 
         public   lint_ 
  lint_  proc     near 
         mov      bx,sp           ; prepare for argument load 
         push     ds              ; save ds segister 
         mov      bx,2[bx]        ; get address of lpr 
         mov      ax,[bx]         ; 
         mov      ds,2[bx]        ; begin forming pointer 
         mov      bx,ax           ; ds:bx now is valid pointer 
         mov      ax,[bx]         ; get the integer or unsigned 
         pop      ds              ; recover old ds value 
         ret                      ; and exit with char in ax 
  lint_  endp 
 
  ; 
  ; l_stchr(lptr,chr) 
  ; LPTR *lptr; 
  ; char chr; 
  ; 
  ; store character chr at address lptr 
  ; 
         public   l_stchr_ 
  l_stchr_ proc   near 
         mov      bx,sp           ; prepare for argument load 
         mov      cl,4[bx]        ; get character 
         mov      bx,2[bx]        ; prepare for load of long pointer 
         push     ds              ; save ds segment register 
         mov      ax,[bx]         ; 
         mov      ds,2[bx]        ; begin forming pointer 
         mov      bx,ax           ; ds:bx now is valid pointer 
         mov      [bx],cl         ; store byte 
         pop      ds 
         ret 
  l_stchr_ endp 
 
  ; 
  ; l_stint(lptr,val) 
  ; LPTR *lptr; 
  ; int val; 
  ; 
  ; store integer or unsigned at address lptr 
  ; 
         public   l_stint_ 
  l_stint_ proc   near 
         mov      bx,sp           ; prepare for argument load 
         mov      cx,4[bx]        ; get integer to store 
         mov      bx,2[bx]        ; prepare to form ds:bx with correct 
                                  ; storage address 
         push     ds              ; save current ds 
         mov      ax,[bx]         ; 
         mov      ds,2[bx]        ; begin forming pointer 
         mov      bx,ax           ; ds:bx now is valid pointer 
         mov      [bx],cx         ; store the integer 
         pop      ds 
         ret                      ; exit 
  l_stint_ endp 
 
  ; 
  ; lload(dest, lptr, len) 
  ; char *dest; 
  ; LPTR *lptr; 
  ; unsigned len; 
  ; 
  ; general purpose copy routine from long data storage to ds: relative 
  ; storage 
  ; 
  ; we assume es = ds for Aztec C explicitly here 
  ; 
  ; due to convenient 8086 instructions, the portable function would 
  ; consist merely of a &quot;cld&quot;, &quot;rep movsb&quot; sequence followed by 
  ; a  return.  Therefore, no portable lload is included in llsup.asm 
  ; 
 
         public   lload_ 
  lload_ proc     near 
         mov       bx,sp           ; prepare for argument load 
         push      ds              ; save Aztec ds segment 
         push      si 
         push      di              ; save source and destination indices 
         ; 
         mov       cx,6[bx]        ; get length for move 
         mov       di,2[bx]        ; es:di now has the destination address 
         mov       bx,4[bx]        ; prepare to load long ptr 
         mov       si,[bx]         ; get low order 
         mov       ds,2[bx]        ; and then high order 
         cld 
         rep       movsb           ; do the move 
         pop       di 
         pop       si 
         pop       ds 
         ret 
  lload_ endp 
 
  ; 
  ; lstor(lptr,src,len) 
  ; LPTR *lptr; 
  ; char *src; 
  ; unsigned len; 
  ; 
  ; Reverse of lload: this routine copies data from ds:src to lptr 
  ; Once again, there is no llsup analog. 
  ; 
         public   lstor_ 
  lstor_ proc     near 
         mov      bx,sp           ; prepare for argument load 
         push     es 
         push     di 
         push     si              ; save registers as required by Aztec C. 
         mov      cx,6[bx]        ; get length of move 
         mov      si,4[bx]        ; ds:si now contains source index 
         mov      bx,2[bx]        ; prepare to form es:di 
         mov      di,[bx] 
         mov      es,2[bx] 
         rep      movsb           ; move the data 
         pop      si 
         pop      di 
         pop      es 
         ret                      ; restore registers and exit 
  lstor_ endp 
 
  ; 
  ;----------------------------------------------------- 
  ; 
  ; routines that call portable subroutines in llsup.asm 
  ; 
  ;------------------------------------------------------ 
  ; 
  ; linc(lptr) 
  ; LPTR *lptr; 
  ; 
  ; increment a long pointer by 1 
  ; 
  ; 
         public linc_ 
  linc_  proc     near 
         extrn    linc:near 
         mov      bx,sp           ; prepare for argument load 
         push     es              ; save es value from caller 
         mov      bx,2[bx] 
         push     bx              ; address where answer will go 
         mov      es,2[bx]        ; get segment 
         mov      bx,[bx]         ; and address 
         call     linc            ; do the work 
         pop      ax 
         xchg     ax,bx 
         mov      [bx],ax 
         mov      2[bx],es        ; store the value 
         pop      es              ; recover the old value 
         ret                      ; and exit 
  linc_  endp 
 
  ; 
  ; ldec(lptr) 
  ; LPTR *lptr; 
  ; 
  ; decrement a long pointer by 1 
  ; 
         public   ldec_ 
  ldec_  proc     near 
         extrn    ldec:near 
         mov      bx,sp           ; prepare for argument load 
         push     es              ; preserve es 
         mov      bx,2[bx]        ; get address ds:bx 
         push     bx              ; address where answer will go 
         mov      ax,[bx]         ; 
         mov      es,2[bx] 
         mov      bx,ax 
         call     ldec            ; do the decrement 
         pop      ax 
         xchg     ax,bx 
         mov      [bx],ax 
         mov      2[bx],es        ; store the value 
         pop      es              ; recover it for sake of caller 

         ret                      ; and then exit 
  ldec_  endp 
 
  ; 
  ; ladd(lptr,offset) 
  ; LPTR *lptr; 
  ; unsigned offset; 
  ; 
  ; add unsigned offset to a long pointer 
  ; 
         public   ladd_ 
  ladd_  proc     near 
         extrn    ladd:near 
         mov      bx,sp           ; prepare for argument load 
         push     es              ; save es value of caller 
         mov      ax,4[bx]        ; get the offset to ax 
         mov      bx,2[bx] 
         push     bx              ; address where answer will go too. 
         mov      cx,[bx] 
         mov      es,2[bx] 
         mov      bx,cx 
         call     ladd            ; do the addition 
         pop      ax 
         xchg     ax,bx 
         mov      [bx],ax 
         mov      2[bx],es        ; store the value 
         pop      es              ; recover old es value 
         ret                      ; and then exit 
  ladd_  endp 
 
  ; 
  ; lsub(lptr,offset) 
  ; LPTR *lptr; 
  ; unsigned offset; 
  ; 
  ; subtract unsigned offset from a long pointer 
  ; 
         public   lsub_ 
  lsub_  proc     near 
         extrn    lsub:near 
         mov      bx,sp           ; prepare for argument load 
         push     es              ; preserve es 
         mov      ax,4[bx]        ; get the offset 
         mov      bx,2[bx] 
         push     bx              ; store answer at this addr. too. 
         mov      cx,[bx] 
         mov      es,2[bx] 
         mov      bx,cx 
         call     lsub            ; do the subtraction 
         pop      ax 
         xchg     ax,bx 
         mov      [bx],ax 
         mov      2[bx],es        ; store the value 
         pop      es              ; restore es 
         ret                      ; and then exit 
  lsub_  endp 
 
  ; 
  ; lsum(lptr,offset) 
  ; LPTR *lptr; 
  ; int offset; 
  ; 
  ; add signed offset to a long pointer 
  ; 
         public   lsum_ 
  lsum_  proc     near 
         extrn    lsum:near 
         mov      bx,sp           ; prepare for argument load 
         push     es              ; preserve caller's es 
         mov      ax,4[bx]        ; get the signed offset 
         mov      bx,2[bx] 
         push     bx 
         mov      cx,[bx] 
         mov      es,2[bx] 
         mov      bx,cs 
         call     lsum            ; do the signed addition 
         pop      ax 
         xchg     ax,bx 
         mov      [bx],ax 
         mov      2[bx],es        ; store the value 
         pop      es              ; 
         ret                      ; exit. 
  lsum_  endp 
 
  ; 
  ; lcopy(dest,src,len) 
  ; LPTR *dest; 
  ; LPTR *src; 
  ; long len;    (treated as a long unsigned quantity) 
  ; 
  ;      copy from src to dest, len bytes. 
  ; 
  ; note this routine can be used to copy arbitrarily large chunks of memory 
  ; 
         public   lcopy_ 
  lcopy_ proc     near 
         extrn    lcopy:near 
         mov      bx,sp           ; prepare for argument load 
         push     ds 
         push     es              ; save segment registers 
         push     di 
         push     si              ; save these registers for Aztec C 
         ; 
         mov       cx,6[bx]       ; get length (low order) 
         mov       dx,8[bx]       ; high order of length 
         mov       ax,2[bx]       ; get ds:ax as pointer to dest. 

         xchg      ax,bx 
         mov       di,[bx] 
         mov       es,2[bx] 
         mov       bx,ax 
         mov       bx,4[bx]       ; get ds:bx as pointer for dest. 
         mov       si,[bx] 
        mov       ds,2[bx]       ; get long pointer 
         ; 
         call      lcopy 
         ; 
         pop       si 
         pop       di 
         pop       es 
         pop       ds 
         ret 
  lcopy_ endp 
 
  cseg   ends 
         end 
   /* <p>
</PRE>
<b><a name="list3-7">LISTING 3-7</a><p></b> 
<PRE>  
        env.c                           created: 25-Mar-84 
        
       This package echoes the environment to the standard output.  
        example of using long pointers with lsup package. 

         This is set up to work with Aztec C. 

         by Anthony Skjellum. (C) 1984. All rights reserved. 
        Released for non-commercial purposes only. 

         This program echoes the environment block to the console. 
        In effect, this is the same as the DOS 2.0 SET command. 
        Nevertheless, it illustrates the usefulness of long pointers. 
         ---------------------------------------------- 
         The following changes were made to the $begin 
        routine of the Aztec C 1.05i module calldos.asm: 
                  i) a new global variable called envseg was created 
                          envseg_ segment word common 'data' 
                         $envdat dw 0 
                         $envseg dw ? 
                         envseg_ ends 

                 ii) On entry to $begin, when es contains the 
                    program segment prefix (PSP), es:[2ch] contains 
                    the segment address of the environment. This 
                    segment address is stored into the second word 
                    of envseg_ (ie $envseg). 
                     The environment may now be referred to through 
                    the external LPTR envseg.  

               iii) If DOS 2.0 allocation is to be used, be sure to 
                    shrink the program size using the SETBLOCK function. 
                    This must also be done in $begin where the psp, 
                    ds, segments are both available. 
 */ 
 
#include &lt;stdio.h&gt; 
#include &quot;lsup.h&quot;      /* support for long pointers */ 
 
extern LPTR envseg;    /* envseg is a structure of type LPTR */ 
 
main(argc,argv) 
int argc; 
char *argv[]; 
{ 
        char chr; 
        int i; 
        LPTR lptr; 
 
        lassign(lptr,envseg); /* get long pointer to environment */ 
 
         while()        /* loop */ 
         { 
                chr = lchr(&amp;lptr);      /* get the next byte */ 
 
                if(!chr) /* we have hit the end of the environment */ 
                        break; 
 
                 while((chr = lchr(&amp;lptr))) /* get characters of string */ 
                 { 
                        putchar(chr);     /* write them to console */ 
                        linc(&amp;lptr);      /* increment pointer */ 
                 } 
 
                 linc(&amp;lptr);    /* pass the zero byte just encountered */ 
 
                 putchar('\n');  /* add new line between entries */ 
 
         } /* end while(1) */ <p>
</PRE>  
<b><a name="list3-8">LISTING 3-8</a><p></b> 
<PRE>  
        ; 
        ; improvements to llsup routines by Bruce Komusin 
        ; % Microworld 
        ; L'Estoril 
        ; 31 Ave. Princesse Grace 
        ; Monte Carlo, Monaco 
        ; 
        ; these routines offer more temporal and byte-efficient 
        ; code than those originally presented in llsup.asm 
        ; 
        ldec    proc    near 
                or      bx,bx 
                jz      ldec_2 
                dec     bx 
                ret 
        ldec_2  dec     bx 
        ldec_3  mov     ax,es 
                sub     ax,1000h 
                mov     es,ax 
                ret 
        ldec    endp 
 
        lsub    proc    near 
                sub     bx,ax 
                jb      ldec_3 
                ret 
        lsub    endp <p>
</PRE>  
<b><a name="list3-9">LISTING 3-9</a><p></b>
<PRE>  
  /* 
        gpr.c                               created: 01-0ct-83 
 
        general purpose utility routines for use with C to simplify 
        user/program interaction. 
 
        by Anthony Skjellum 
 
        Copyright 1983, 1984, 1985 (c) Caltech. All rights reserved. 
        This subroutine library may be distributed freely and 
        used for all non-commercial purposes but may not be sold. 
 
        Routines: 
 
                iinp(): integer input w/ prompt, range check + retry 
                finp(): float input w/ prompt, range check + retry 
                sinp(): string input w/ prompt 
                cinq(): yes/no question processor w/ prompt + retry 
                display(): display a file 
 
        updated: 20-Jul-84 
        updated: 31-Mar-85 
 
        testing information: this code was tested with Aztec C 1.05j 
        testing information: this code compiled okay under Lattice C 2.12 
*/ 
 
#include &lt;stdio.h&gt; 
 
/* Unix flag (used by display()) */ 

/* 
 #define UNIX 1 
*/ 

#ifndef UNIX 
#define TEOF 26         /* ^Z */ 
#endif 
 
/* general purpose subroutines: */ 
 
/* iinp(): integer input with range checking, prompt and retry */ 

 
iinp(prompt,cflag,low,high) 
char *prompt; 
char cflag; 
int low; 
int high; 
{ 
        int ival; 
 
        while(1) 
        { 
                printf(&quot;%s&quot;,prompt); 
                if(scanf(&quot;%d&quot;,&amp;ival) &lt; 1) 
                { 
                        while(getchar() != '\n') 
                                ; 
                        continue; 
                } 
                if((!cflag)||(ival &gt;= low)&amp;&amp;(ival &lt;= high)) 
                         break; 
                                /* no checking, or within bounds */ 
 
                printf(&quot;\nValue out of range, try again...\n&quot;); 
         } 
 
         return(ival); /* return the value */ 
 
} /* end iinp() */ 
 
/* finp(): floating point input with range checking, prompt and retry */ 
 
double finp(prompt,cflag,low,high) 
char *prompt; 
char cflag; 
double low; 
double high; 
{ 
        double fval; 
        while(1) 
        { 
                printf (&quot;%s&quot;,prompt); 
                if(scanf(&quot;%lf&quot;,&amp;fval) &lt; 1) 
                { 
                        while(getchar() != '\n') 
                                ; 
                        continue; 
                } 
 
                if((!cflag)||(fval &gt;= low)&amp;&amp;(fval &lt;= high)) 
                        break; 
                               /* no checking, or within bounds */ 
 
                printf(&quot;\nValue out of range, try again...\n&quot;); 
        } 
 
        return(fval); /* return the value */ 
 
} /* end finp() */ 
 
/* subroutine sinp(): input a string with prompt, length limit */ 

 
sinp(prompt,string,length) 
char *prompt; 
char *string; 
int length; 
{ 
        int len;                      /* length of actual string input */ 
        char chr; 
        char *fgets();                /* string input function */ 

 
        printf(&quot;%s&quot;,prompt);                 /* display the prompt */ 
        while(isspace(chr = getchar())) 
                ; 
        ungetc(chr,stdin); 
        fgets(string,length,stdin);    /* input the string */ 
 
        if((len = strlen(string))) 
                string[strlen(string)-1] = '\0'; 
 
        return(len); 
} /* end sinp() */ 
 
/* subroutine cinq(): yes no question processor with prompt, retry */ 
 
cinq(prompt) 
char *prompt; 
{ 
        char chr; 
 
        while(1) 
        { 
                printf(&quot;%s&quot;,prompt); 
 
                do /* drain spurious 'white space' */ 
                { 
                        chr = tolower(getchar()); /* use first char */ 
                } 
                while(isspace(chr)); 
                if((chr == 'y')||(chr == 'n')) break; 
 
                printf(&quot;\nRespond with Y or N, please try again...\n&quot;); 
          } 
 
          return((chr == 'y') ? 1 : 0); 
} 
 
/* display(): subroutine to print an ascii file on the console */ 

 
display(fname) 
char *fname; 
{ 
        char c;        /* character to output */ 
        FILE *disp; 
 
        if((disp = fopen(fname,&quot;r&quot;)) == NULL) 
                 return(-1);    /* can't open file */ 
 
        while((c = getc(disp)) != EOF) /* print the file */ 
        { 
#ifndef UNIX 
                if(c == TEOF) /* text end of file */ 
                        break; 
#endif 
 
                putchar((c &amp; 127)); /* output each character less parity */ 
        } 
 
        fclose(disp); /* close the file */ 
        return(0);    /* successful completion */ 
} <p>
</PRE>  
<b><a name="list3-10">LISTING 3-10</a><p></b> 
<PRE>  
/* 
        program:        rktest1.c 
        created:        03-Nov-83 
        by:             A. Skjellum 
 
        Copyright 1983, 1984 (c) California Institute of Technology. 
        All rights Reserved. This program may be freely distributed 
        for all non-commercial purposes but may not be sold. 
 
        updated:        16-Nov-83 
        purpose:        illustrate the use of rk4 program 
 
        uses:           rk4.c 
 
        summary: 
                integrates the differential equation: 
 
                y'(t) + y(t) = t + 1 
                y(0) = 5.0. 
 
                for which the exact solution: 
 
                y(t)= t + 5exp(-t) is known. 
 
*/ 
 
/* constants */ 
 
#define YZERO   5.0   /* initial value for y */ 
#define TSTART  0.0   /* starting time for integration */ 
#define TEND    10.0  /* ending time for integration */ 
#define STEPS   80    /* 40 steps in integration */ 
 
/* subroutines: */ 
 
/* exact(): returns exact solution value, given t */ 
 
double exact(t) 
double t; 
{ 
       extern double exp(); /* exponential function */ 
 
       if(t) 
              return((t + YZERO*exp(-t))); 
              return(YZERO); 
} 
 
/* fn(t,y): return f(t,y) given t,y values */ 
 
double fn(t,y) 
double t; 
double y; 
{ 
       /* 
              differential equation is y' + y= t + 1 
 
              therefore, f = t + 1 - y. 
 
       */ 
 
       return(t + 1.0 - y); 
} 
 
/* solutn(): print solution step at console */ 
 
solutn(t,y) 
double *t;     /* pointer to t value */ 
double *y;     /* pointer to y value */ 
{ 
       printf(&quot;t = %7.3e, y= %7.3e, y_exact = %7.3e, diff = %7.3e\n&quot;, 
               *t,*y, exact(*t),*y - exact(*y)); 
} 
 
/* main program: */ 
 
main() 
{ 
       /* external declarations */ 
 
       double fn();  /* ensure that this is typed as double */ 
 
       /* local variables: */ 
 
       register int i; 
 
       double yarray[STEPS],tarray[STEPS]; 
               /* integrated solution stores here */ 
 
       /* begin code: */ 
 
       printf(&quot;\n\nrktest1.c   as of 03-Nov-83\n\n&quot;); 
       printf(&quot;Integrates: y' + y = 1 + t  for\n\n&quot;); 
       printf(&quot;t = %7.3e to %7.3e, with %u steps\n\n&quot;, 
               TSTART,TEND,STEPS); 
 
       /* 
               integrate the answer from t = 0 to t =10 sec 
               80 points. 
       */ 
 
       rk4(fn,TSTART,TEND,STEPS,YZERO,tarray,yarray); 
                       /* compute the answers */ 
 
       for(i=0;i&lt;STEPS;i++)     /* print solution */ 
               solutn(tarray+i,yarray+i); 
 
       printf(&quot;\n\nEND of execution\n\n&quot;); 
} 
/* 
       program:        rktest1.c 
       created:        03-Nov-83 
       by:             A. Skjellum 
 
       Copyright 1983, 1984 (c) California Institute of Technology. 
       All rights Reserved. This program may be freely distributed 
       for all non-commercial purposes but may not be sold. 
 
       updated:        16-Nov-83 
       purpose:        illustrate the use of rk4 program 
 
       uses:           rk4.c 
 
       summary: 
               integrates the differential equation: 
 
               y'(t) + y(t) = t + 1 
               y(0) = 5.0. 
 
               for which the exact solution: 
               y(t) = t + 5exp(-t) is known. 
*/ 
 
/* constants */ 
 
#define YZERO 5.0   /* initial value for y */ 
#define TSART 0.0   /* starting time for integration */ 
#define TEND  10.0  /* ending time for integration */ 
#define STEPS 80    /* 40 steps in integration */ 
 
/* subroutines: */ 
 
/* exact(): returns exact solution value, given t */ 
 
double exact(t) 
double t; 
{ 
        extern double exp();  /* exponential function */ 
 
        if(t) 
               return((t + YZERO*exp(-t))); 
 
        return(YZERO); 
} 
 
/* fn(t,y): return f(t,y) given t,y values */ 
 
double fn(t,y) 
double t: 
double y: 
{ 
        /* 
               differential equation is y' + y = t + 1 
 
               therefore, f = t + 1 - y. 
        */ 
 
        return(t + 1.0 - y); 
} 
 
/* solutn(): print solution step at console */ 
 
solutn(t,y) 
double *t;     /* pointer to t value */ 
double *y;     /* pointer to y value */ 
{ 
        printf(&quot;t = %7.3e, y = %7.3e, y_exact = %7.3e, diff = %7.3e\n&quot;, 
               *t,*y,exact(*t),*y - exact(*y)); 
} 
/* main program: */ 
 
main() 
{ 
        /* external declarations */ 
 
        double fn();    /* ensure that this is typed as double */ 

         /* local variables: */ 
 
        register int i; 
 
        double yarray[STEPS],tarray[STEPS]; 
                /* integrated solution stored here */ 
 
        /* begin code: */ 
 
        printf(&quot;\n\nrktest1.c   as of 03-Nov-83\n\n&quot;); 
        printf(&quot;Integrates: y' + y = 1 + t     for\n\n&quot;); 
        printf(&quot;t = %7.3e to %7.3e, with %u steps\n\n&quot;, 
                TSTART,TEND,STEPS); 
 
        /* 
                integrate the answer from t = 0 to t = 10 sec 
                80 points. 
        */ 
 
        rk4(fn,TSTART,TEND,STEPS,YZERO,tarray,yarray); 
                        /* compute the answers */ 
 
        for(i=0;i&lt;STEPS;i++) /* print solution */ 
                solutn(tarray+i,yarray+i); 
 
        printf(&quot;\n\nEnd of execution\n\n&quot;); 
} <p>
</PRE> 
<b><a name="list3-11">LISTING 3-11</a><p></b> 
 <PRE> 
  /* 
        Runge - Kutta order 4 Algorithm 
 
        Creation date: 31-Oct-83 
        Author:        Mike Roberts 
 
        Copyright 1983, 1984 (c) California Institute of Technology. 
        All rights Reserved. This program may be freely distributed 
        for all non-commercial purposes but may not be sold. 
 
        This algorithm is described in detail on page 205 of 
        Burden, Richard L.: Numerical Analysis. 
 
        To approximate the solution of the initial value problem 
               y'=f(t,y), a&lt;=t&lt;=b, y(a)=alpha, 
        at (N+1) equally spaced numbers in the interval [a,b]: 
        INPUT endpoints a,b; integerg N; initial condition alpha. 

        OUTPUT approximation w to y at the (N+1) values of t. 
 
Step 1: 
        Set     h=(b-a)/N; 
                t=a; 
                w=alpha; 
        Output (t,w). 
Step 2: 
        For i=1,2,...,N do Steps 3-5: 
 
        Step 3: 
                Set     K1=hf(t,w); 
                        K2=hf(t+h/2,w+K1/2); 
                        K3=hf(t+h/2,w+k2/2); 
                        K4=hf(t+h,w+K3). 
        Step 4: 
                Set w=w+(K1+2K2+2K3+K4)/6;     (Compute w[i].) 
                        t=a+ih.                (Compute t[i].) 
        Step 5: 
                Output (t,w). 
 
Step 6: 
        Stop. 
 
*/ 
 
#define FALSE 0 
#define TRUE 1 
 
rk4(function,a,b,n,alpha,t,w) 
 
double (*function)();   /* function giving f(t,y) */ 
double a;               /* beginning of interval */ 
double b;               /* end of interval */ 
int n;                  /* number of steps in interval */ 
double alpha;           /* initial condition for y */ 
double t[];             /* array for returning T[i] values */ 
double w[];             /* array for returning W[i] values */ 
 
{ 
        register int i; /* counter for integration steps */ 
        double h;       /* stepsize */ 
        double time; 
        double yapprox; /* approximation for y value */ 
 
        /* STEP 1:   Initialization */ 
 
        h = (b-a) / (double)n ;        /* Compute stepsize */ 
        time = a;                      /* Initialize time */ 
        yapprox = alpha;               /* Start with the approximation 
                                          equal to the initial value */ 
 
        for (i=0; i&lt;n; i++)            /* Main integration loop */ 
        { 
                if(i)   /* if not first time, call the integrator */ 
                        rk4_1(function,h,time,&amp;yapprox); 
 
                        /* Pass the function pointer, the h, time, and 
                                yapprox values, and the pointers to 
                                the current positions in the T and W 
                                matrices */ 
 
                time = a + h*(double)i;  /* compute time */ 
                t[i] = time;             /* also save it */ 
                w[i] = yapprox;          /* store value for function */ 
        } 
} 
 
/* This is the RK4 integrator portion. It performs one step of the 
       integration, and is called on each step from the RK4 loop. 

        function = pointer to function to integrate 
       h = stepsize 
       time = current time location 
       yapprox = current w (function approximation) 
 
*/ 
 
rk4_1(function,h,time,yapprox) 
 
double (*function)();          /* Pointer to function to 
integrate */ 
double h;                      /* Step size */ 
double time;                   /* Current time step */ 
double *yapprox;               /* Current approximation of 
function */ 
 
{ 
 
        double k1, k2, k3, k4; /* Temporary values in RK calculation */ 
 
        k1 = h * (*function)(time,*yapprox);    /* Evaluate first approx */ 
        k2 = h * (*function)(time+h/2.0, *yapprox+k1/2.0); 
                                                /* Evaluate second approx */ 
        k3 = h * (*function)(time+h/2.0, *yapprox+k2/2.0); 
                                                /* And the third */ 
        k4 = h * (*function)(time+h, *yapprox+k3); 
                                                /* And the last one */ 
 
        *yapprox += (k1 + 2.0,(k2 + k3) + k4)/6.0; /* new approx */ 
} <p>
</PRE> 
<b><a name="list3-12">LISTING 3-12</a><p></b> 
<PRE>  
/* 
        rk4n.c                          created: 07-Nov-83 
        authors:                        A. Skjellum, 
                                        M. Roberts 
 
        updated:                        14-Nov-83 
                                        by MJR 
 
        Copyright 1983, 1984 (c) California Institute of Technology. 
        All rights Reserved. This program may be freely distributed 
        for all non-commercial purposes but may not be sold. 
 
        Purpose: 
        integrate M first order differential equations 
 
        y'[i] = f[i](t;y[j-1...M]) 
 
        M equations. 
 
        algorithm:     see Burden, Faires, Reynolds, p. 239-240 
                       also see p. 205 
 
                1. interval t = [a,b] 
                2. choose N &gt; 0 as as partition of interval (N steps) 
                3. define step size h: (b-a)/N. 
                4. Initial conditions: (denote w[i,j] as approxes to y's) 
 
                w[i,0] = alpha[i] 
                means: ith w at time zero is set to initial value 

                       alpha[i]. 
 
                5. Computing the w[i,j+1] from w[i,j] is done as follows: 
 
                       loop over i = 1 to M 
 
                           compute k1[i]= h*f[i](t,w[1,j],...,w[M,j]) 
 
                       end of loop 
 
                       loop over i = 1 to M 
 
                           compute k2[i] = h*f[i](t+h/2,w[1,j]+.5*k1[1],..., 
                                           w[M,j] + .5*k1[M]) 
 
                       end of loop 
 
                       loop over i = 1 to M 
 
                           compute k3[i] =h*f[i](t+h/2,w[1,j]+.5*k2[1],..., 
                                          w[M,j] + .5*k2[M]) 
 
                       end of loop 
 
                       loop over i = 1 to M 
 
                           compute k4[i] =h*f[i](t+h,w[1,j]+k3[1],..., 
                                          w[M,j] + k3[M]) 
 
                       end of loop 
 
                       loop over i = 1 to M 
 
                           w[i,j+1] = w[i,j] + 
                                      {k1[i]+ 2*k2[i] + 2*k3[i] + k4[i]}/6 
 
                       end of loop 
 
*/ 
 
double (*rk_function)(); 
double (*rk_source)(); 
double (*rk_store)(); 
double (*rk_kuttas)[4]; 
double (*rk_comp[4])();               /* tells us how to form k's */ 
 
/* functions called indirectly by k_calc() */ 
 
double rk_1(n,j,i)      /* to provide compatibility with calling */ 
int n; 
int j; 
int i; 
{ 
        return ((*rk_source)(j,n)); 
} 
 
double rk_23(n,k,j,i) /*  N is in { 0...M } = argument number. 
                          Since we have one argument to FN per equation, 
                          N will indicate which we are currently being 
                          asked to provide. Same goes for other RK_x 
                          functions below. */ 
int n; 
int k; 
int j; 
int i; 
{ 
        return((*rk_source)(j,n) + .5*rk_kuttas[n][k]); 
} 
 
double rk_2(n,j,i) 
int n; 
int j; 
int i; 
{ 
        return(rk_23(n,0,j,i)); 
} 
 
double rk_3(n,j,i) 
int n; 
int j; 
int i; 
{ 
        return(rk_23(n,1,j,i)); 
} 
 
double rk_4(n,j,i) 
int n; 
int j; 
int i; 
{ 
        return((*rk_source)(j,n) + rk_kuttas[n][2]); 
} 
 
/* Here's the integrator!!! */ 
 
double rk4n(function,wsource,wstore,m,a,b,n,alpha,t,kuttas) 
 
double (*function)();  /* pointer to function which returns deriv info */ 
double (*wsource)();   /* source of w[i,j] values */ 
double (*wstore)();    /* function which stores w[i,j] values for us */ 
int m;                 /* number of equations */ 
double a;              /* start of interval */ 
double b;              /* end of interval */ 
int n;                 /* number of points */ 
double alpha[];        /* array of initial values */ 
double t[];            /* array where we store times */ 
double kuttas[][4];    /* n x 4 kuttas (k1,k2,k3,k4 i=1,...m) */ 
{ 
 
        register int i; /* looping variable */ 
        register int j; /* looping variables */ 
        double time; 
        double h = (b-a)/(double)n;     /* step size */ 
 
        double rk_k2(),rk_k3(),rk_k4(); /* include for emphasis */ 
 
        rk_function = function; 
 
        rk_kuttas   = kuttas; 
        rk_source   = wsource; 
        rk_store    = wstore; 
 
        rk_comp[0]  = rk_1; 
        rk_comp[1]  = rk_2; 
        rk_comp[2]  = rk_3; 
        rk_comp[3]  = rk_4; 
 
        /* First assign initial values */ 
 
        for (i = 0;i &lt; m;i++) 
                (*rk_store)(0,i,alpha[i]); 
 
        /* Now loop through the necessary loop, calculating 
               each K value for each equation in each time step. */ 
 
        for(j : 0;j &lt; n;j++) /* n time steps */ 
        { 
                time = a + h*(double)j; /* compute time */ 
                t[j] = time;            /* also save it */ 
 
                rk4_1n(m,j,time,h); 
        } 
} 
 
/* rk4_1n(): compute one solution step for n equations */ 
 
rk4_1n(m,j,time,h) 
int m; 
int j;                        /* time step we're working on */ 
double time; 
double h; 
{ 
        register int k; /* k calculation loop */ 
        register int i; /* m equations loop */ 
        double value;   /* temporary */ 
 
        for(k=0;k &lt; 4;k++)    /* k compute loop */ 
                k_calc(m,k,j,time,h); 
 
        for(i=0;i&lt;m;i++)      /* compute new w[i,j]'s j fixed here */ 
        { 
                value = (*rk_source)(j,i) + .166666667*(rk_kuttas[i][0] + 
                        2.0*(rk_kuttas[i][1] + rk_kuttas[i][2]) 
                            + rk_kuttas[i][3]); 
                                /* value for w[i,j] */ 
                (*rk_store)(j+1,i,value); /* save this hard got number */ 
 
        } 
} 
 
/* k_calc(): compute rk coefficients for fixed j */ 
 
k_calc(m,k,j,time,h) 
int m; 
int k; 
int j; 
double time; 
double h; 
{ 
        register int i; 
        double tval; 
 
        switch(k) 
        { 
               case 0: 
                       tval : time; 
                       break; 
               case 1: 
               case 2: 
                       tval = time + .5*h; 
                       break; 
               case 3: 
                       tval = time + h; 
                       break; 
        } 
 
        for(i=0;i&lt;m;i++)               /* used to be 1;&lt;=m */ 
        { 
               rk_kuttas[i][k] = h*(*rk_function)(j,i,tval,rk_comp[k]); 
        } 
} <p>
</PRE>  
<b><a name="list3-13">LISTING 3-13</a><p> </b>
<PRE>  
  /* 
        program:        rkst1.c 
        created:        03-Nov-83 
        by:             A. Skjellum 
 
        modified:       14-Nov-83 
        by:             M. J. Roberts 
 
        Copyright 1983, 1984 (c) California Institute of Technology. 
        All rights Reserved. This program may be freely distributed 
        for all non-commercial purposes but may not be sold. 
 
        purpose:        illustrate the use of rk4n program 
 
        uses:           rk4n() (rks.c) 
        summary: 
                integrates the differential equation: 
 
                y'(t) + y(t) = t + 1 
                y(0) = 5.0. 
 
                for which the exact solution: 
 
                y(t) = t + 5exp(-t) is known. 
 
                Integrates the same equation as rktest1 
                but using the more general equation solver, 
                rk4n(). This run is exactly the same as for 
                rktest1, except that, rather than trying to solve 

 
                exactly the same equation, we will solve a 
                &quot;system&quot; of one differential equation. 
 
*/ 
 
/* constants */ 
 
#define SYSIZE 1     /* number of functions in system */ 
#define YZERO 5.0    /* initial value for y */ 
#define TSTART 0.0   /* starting time for integration */ 
#define TEND 10.0    /* ending time for integration */ 
#define STEPS 50     /* 50 steps in integration */ 
 
/* variables external to all functions */ 
 
double wvalue[STEPS+1][SYSIZE]; 
double yarray[STEPS+1][SYSIZE]; 
double tarray[STEPS]; 
        /* integrated solution stored here */ 
 
/* subroutines: */ 
 
/* exact(): returns exact solution value, given t */ 
 
double exact(t) 
double t; 
{ 
        extern double exp(); /* exponential function */ 
 
        return((t + YZERO*exp(-t))); 
} 
 
/* fn(j,i,t,y): return f(t,y) given t,y values */ 
 
double fn(j,i,t,y) 
int j; 
int i; 
double t; 
double (*y)(); 
{ 
        double a,b;            /* temporary storage space */ 
 
        /* 
                differential equation is y' + y = t + 1 
 
                therefore, y' = t + 1 - y. 
 
        */ 
 
        a = (*y)(0,j,i);       /* calculate function              
                           Note that the ZERO was passed so as to 
                               allow the function to know which argument 
                               we are talking about - in this case, 
                               we only need one argument evaluated, so 
                               pass it 0 to indicate the first (zeroeth, 
                               actually) argument is to be calculated. */ 

         b = t + 1.0 - a;       /* and figure out the rest of it  */ 
        return(b); 
 
} 
/* store(): the routine to store away the W values for later reference */ 
 
double store(row, col, value) 
int row, col;           /* location to store the value */ 
double value;           /* the actual value to store */ 
{ 
      wvalue[row][col]=value; 
      return (value); 
} 
 
/* source(): return the W value referenced by input parameters */ 

 
double source(row,col) 
int row, col;          /* location to look up */ 
 
{ 
        return (wvalue[row][col]); 
} 
 
/* solutn(): print solution step at console */ 
 
solutn(j,i) 
int j,i;        /* element numbers */ 
{ 
        double time; 
        double ex; 
        double approx; 
 
        time   = tarray[j]; 
        ex     = exact(time); 
        approx = source(j,i); 
 
        printf(&quot;t = %7.3e, y = %7.3e, y_exact = %7.3e, diff = %7.3e\n&quot;, 
                time,approx,ex,approx - ex); 
} 
 
/* main program: */ 
 
main() 
{ 
        /* external declarations */ 
 
        double store(), source(); 
 
        double fn();     /* ensure that this is typed as double */ 
 
        /* local variables: */ 
 
        register int i,j; 
 
        double init[1];        /* initial condition matrix */ 
 
        /* begin code: */ 
 
        printf(&quot;\n\nrktest1.c as of 03-Nov-83\n\n&quot;); 
        printf(&quot;Integrates: y' + y = 1 + t    for\n\n&quot;); 
        printf(&quot;t = %7.3e to %7.3e, with %u steps\n\n&quot;, 

                TSTART,TEND,STEPS); 
 
        /* 
                integrate the answer from t = 0 to t = 10 sec 
                STEPS points. 
        */ 
 
        init[0] = YZERO;       /* set up initial condition matrix */ 
 
        
rk4n(fn,source,store,SYSIZE,TSTART,TEND,STEPS,init,tarray,yarray); 
                        /* compute the answers for 1 function */ 
 
        /* Print out solution */ 
 
        for(j=0;j&lt;STEPS;j++)  /* print solution */ 
                solutn(j,0); 
 
        printf(&quot;\n\nEnd of execution\n\n&quot;); 
} <p>
</PRE>  
<b><a name="list3-14">LISTING 3-14</a> <p></b>
<PRE>  
  /* 
         program:        rkst2.c 
         created:        03-Nov-83 
         by:             A. Skjellum 
 
         modified:       14-Nov-83 
         by:             M. J. Roberts 
         and:            5-Dec-83 
         by:             M. J. Roberts 
 
         modified:       25-Jul-84 
         by:             A. Skjellum 
 
         Copyright 1983, 1984 (c) California Institute of Technology. 
         All rights Reserved. This program may be freely distributed 
         for all non-commercial purposes but may not be sold. 
 
         purpose:        illustrate the use of RKS program 
         update:         to test the rk4n() subroutine using a system 
                         of two differential equations. 
 
         uses:           rk4n() (rks.c) 
         summary: 
 
                 integrates the differential equation system: 
 
                 u1'(t) = 8u2(t)                 u1(0) = 10 
                 u2'(t) = 2u1(t)                 u2(0) = 7 
 
                 for which the exact solution is known to be: 
 
                 u1(t) = 12exp(4t) - 2exp(-4t) 
                 u2(t) = 6exp(4t) + exp(-4t) 
 
*/ 
 
/* constants */ 
 
#define SYSIZE 2      /* number of functions in system */ 
#define Y1ZERO 10.0   /* initial value for first equation */ 
#define Y2ZERO 7.0    /* initial value for other equation */ 
#define TSTART 0.0    /* starting time for integration */ 
#define TEND 1.0      /* ending time for integration */ 
#define STEPS 50      /* 50 steps in integration */ 
 
/* variables external to all functions */ 
 
double wvalue[STEPS+1][SYSIZE]; 
double yarray[STEPS+1][SYSIZE],tarray[STEPS]; 
        /* integrated solution stored here */ 
 
/* subroutines: */ 
 
/* exact(): returns exact solution value, given t */ 
 
double exact(n,t) 
int n;          /* which equation is it? 0 or 1? */ 
double t; 
 
{ 
        extern double exp();  /* exponential function */ 
 
        /* This must find solutions for both U1 and U2. The 
               exact solutions are given in the header comments to 
               this program, above. */ 
 
        switch (n) 
        { 
               case O: 
                      return(12*exp(4*t) - 2*exp(-4*t)); 
               case 1: 
                      return( 6*exp(4*t) + exp(-4*t)); 
        } 
} 
/* fn(j,i,t,y): return f(t,y) given t,y values */ 
 
double fn(j,i,t,y) 
int j; 
int i; 
double t; 
double (*y)(); 
{ 
        switch (i) 
        { 
               case 0: 
                      /* u1'(t) = 8 * u2(t) */ 
                      return(8*(*y)(1,j,i)); 
 
               case 1: 
                      /* u2'(t) = 2 * u1(t) */ 
                      return(2*(*y)(0,j,i)); 
        } 
} 
 
/* store(): the routine to store away the W values for later 
reference*/ 
 
double store(row, col, value) 
int row, col;           /* location to store the value */ 
double value;           /* the actual value to store */ 
{ 
       wvalue[row][col]=value; 
       return (value); 
} 
 
/* source(): return the W value referenced by input parameters */ 

 
double source(row, col) 
int row, col;           /* location to look up */ 
 
{ 
return (wvalue[row][col]); 
} 
 
/* solutn(): print solution step at console */ 
 
solutn(j,i) 
int j,i;       /* element numbers */ 
{ 
        printf(&quot;\nt=%7.3e, y%1d=%7.3e, y%1d_exact=%7.3e, diff=%7.3e&quot;, 
                tarray[j],i,source(j,i),i,exact(i,tarray[j]), 
                source(j,i) - exact(i,tarray[j])); 
} 
 
/* main program: */ 
 
main() 
{ 
        /* external declarations */ 
 
        double store(), source(); 
 
        double fn(); /* ensure that this is typed as double */ 
 
        /* local variables: */ 
 
        register int i,j; 
 
        double init[SYSIZE];        /* initial condition matrix */ 
 
        /* begin code: */ 
 
        printf(&quot;\n\nrkst2.c    as of 25-Jul-84\n\n&quot;); 
        printf(&quot;        Integrates the differential equation system:\n\n&quot;); 
        printf(&quot;        u1'(t) = 8u2(t)                 u1(0) = 10\n&quot;); 
        printf(&quot;        u2'(t) = 2u1(t)                 u2(0) = 7\n&quot;); 
        printf(&quot;        for which the exact solution is known to be:\n\n&quot;); 
        printf(&quot;        u1(t) = 12exp(4t) - 2exp(-4t)\n&quot;); 
        printf(&quot;        u2(t) = 6exp(4t) + exp(-4t)\n\n&quot;); 
        printf(&quot;        for    t = %7.3e to %7.3e, with %u steps\n\n&quot;, 
                TSTART,TEND,STEPS); 
 
        /* 
                integrate the answer from t = 0 to t = 10 sec 
                STEPS points. 
        */ 
 
        init[0]: Y1ZERO;        /* set up initial condition matrix */ 
        init[1] = Y2ZERO; 
 
        
rk4n(fn,source,store,SYSIZE,TSTART,TEND,STEPS,init,tarray,yarray); 
                        /* compute the answers for 1 function */ 
 
        /* Print out solutions */ 
 
        for(i=0;i&lt;SYSIZE;i++) 
                for(j=0;j&lt;STEPS;j++)    /* print solution */ 
                        solutn(j,i); 
 
        printf(&quot;\n\nEnd of execution\n\n&quot;); 
  } <p>
</PRE>  
<b><a name="list3-15">LISTING 3-15</a><p> </b>
<PRE>  
/* 
        Revised &lt;untested&gt; version of &quot;sfopen.&quot; The original 
        version was written by A. Cameron and published in Dr. Dobb's
         Journal, August 1984 issue.  

        This revision is to illustrate the design principle that 
        the structure of a program should reflect the behavior of 

        the program (a corollary of the principle that the structure 
        of a solution should reflect the structure of the problem) 
 
        The focus of this example is that the execution sequence 
        and execution frequency are primary elements of problem 
        structure and should be mirrored in the code. 
 
               by: John A. Grosberg 
 
               [relevant for BDS C] 
*/ 
 
#define NULL   0 
#define BUFSIZ 256 
#define TRUE   1 
#define ERR    -1 
 
sfopen(filename, mode) 
char *filename; 
char *mode; 
{ 
        int fd, 
            err; 
 
        if (fd = alloc(BUFSIZ)) 
        { 
                 switch(*mode) 
                 { 
                         case 'w':                      /* write mode */ 
                                 err: (fcreat(filename,fd) == ERR); 
                                 break; 
                         case 'r':                      /* read mode */ 
                                 err = (fopen(filename,fd) == ERR); 
                                 break; 
                         case 'a':                      /* append mode */ 
                                 err = (fappend(filename,fd) == ERR); 
                                 break; 
                         default:                  /* invalid mode */ 
                                 err = TRUE; 
                                 break; 
                 } 
 
                 if (err) 
                 { 
                         free(fd); 
                         fd = NULL; 
                 } 
        } 
        else                             /* alloc failure */ 
        { 
                fd = NULL;               /* redundant */ 
} 
 
         return(fd); 
  }	  
</PRE> 
<P>
<CENTER>  Return to <a href="../toc.htm">Table of Contents
</a>
</CENTER>
<P>
</HTML> 
