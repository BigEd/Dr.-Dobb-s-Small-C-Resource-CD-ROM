 <HTML>
<!--
 	Dr. Dobb's Small C Resource CD-ROM Compilation (c) 1997 Dr. 
Dobb's Journal, M&T Publishing, Inc., a subsidiary of Miller 
Freeman, Inc. All rights reserved.<p>
-->
<CENTER>
<B><H1>SMALL-TOOLS: PROGRAMS FOR TEXT PROCESSING</H1> <p>

by J. E. Hendrix<p>
</CENTER>
</B>


<i>This article was adapted from the Small-Tools manual.</i><p>

Brian W. Kernighan and P. J. Plauger, in the book <i>Software 
Tools</i>
(Addison-Wesley, 1976), describe a philosophy of computer 
programming in which
programs are considered tools to be used for solving problems. 
Each program, or
tool, is designed to work with the other tools. Each performs one 
of a set of
functions needed to complete a task. Given a set of tools, you 
can combine
them in various ways to achieve desired results.<p>

The key to making the software-tools concept work is to have the 
output of
each tool compatible with the input of all the other tools. The 
tools must be
designed for flexible use; they must not make too many 
assumptions about the
functions they perform. They should do something rational even 
when their
operating parameters are unusual, since even unusual effects may 
be useful.<p>

The chief advantage of this approach to program design is that a 
new
program need not be developed, nor an old one modified, whenever 
a need arises
that is slightly different from what is already being done. 
Familiarity with the
tools at hand and a little imagination can often produce the 
solution to a new
problem.<p>

<b>The Small-Tools Package<p>
</b>

Small-Tools is a set of programs inspired by the ones described 
in the book
Software Tools. The programs are especially designed for use with 
single-user
microcomputer systems.<p>

Their area of application is text processing--an area of high 
activity in
virtually every line of work. Tasks for which they are suited 
include (but are not
limited to):<p>
<UL>
<LI>Writing letters, reports, articles, and books
<LI>Checking for spelling errors
<LI>Writing computer programs
<LI>Creating forms and documents by answering questions
<LI>Composing legal documents from prewritten material and/or 
answering prompts
<LI>Maintaining mailing lists
<LI>Printing personalized form letters individually or from a 
mailing list
<LI>Addressing envelopes<p>
</UL>
Many other uses are possible, depending on your needs and 
imagination.<p>

<b>The Small-Tools Programs<p>
</b>

The Small-Tools package (Table 13-1) consists of programs
designed to perform the following specific functions on text 
files:<p>
<UL>
<LI>Editing
<LI>Formatting
<LI>Sorting
<LI>Merging
<LI>Listing
<LI>Printing
<LI>Searching
<LI>Changing
<LI>Transliterating
<LI>Copying and concatenating
<LI>Encrypting and decrypting
<LI>Replacing spaces with tabs
<LI>Replacing tabs with spaces
<LI>Counting characters, words, or lines
<LI>Selecting printer fonts<p>
</UL>
All the programs work with files of the same format, and you can 
use the output
of any program as input to any other program. Alternatively, you 
may send the
output of any program to the console, to a printer, or to any 
device attached to
the computer. Likewise, the input to any program may come from 
the console
or any device connected to the computer.<p>

<center>
<b>Table 13-1. Small-Tools Programs and Usage Messages</b>
</center>
<pre>
<b>listing      program    description</b>

1            CHANGE     replace occurrences of a pattern
2            COPY       copy one or more files into one
3            COUNT      count characters, words, and/or lines
4            CRYPT      encrypt or decrypt files
5            DETAB      replace tabs with equivalent blanks
6            EDIT       create or modify files
7            ENTAB      replace blanks with equivalent tabs
8            FIND       find lines containing a pattern
9            FONT       set printer fonts
10           FORMAT     format and print files
11           LIST       list a file in columns and pages
12           MERGE      merge two sorted files for unique, equal, or all lines
13           PRINT      print with page skips, headings, and line numbers
14           SORT       sort text lines ascending or descending on key field
15           TRANS      transliterate characters
16                      header files and functions common to all the
                        programs

             <i>program    usage message</i>

             CHANGE     pattern [replacement]
             COUNT      [file] [-C|-W|-L]
             COPY       [file]... [.?] [-B] [-NCR] [-NLF] [-T#,#]
             CRYPT      key
             DETAB      [#]... [+#]
             EDIT       [file] [-V]
             ENTAB      [#]... [+#]
             FIND       [~]pattern
             FONT       [device]
             FORMAT     [mergefile] [-BC#] [-EC#] [-BP#] [-EP#] [-PO#]
                        [-NP] [-T] [-I] [-U] [-S] [-BS#] [-NR]
             LIST       [file] [-C#] [-PW#] [-PL#] [-NB] [-NN] [-NP]
             MERGE      file [file] [-1|-2|-3|-F]
             PRINT      [file]... [.?] [-NN] [-NH|-NS] [-LM#] [-BP#]
                        [-EP#] [-P] [-NR]
             SORT       [-C#|-F#?] [-D] [-U] [-Tx] [-Q]
             TRANS      [~]from [to]<p>
</pre>

Input may also come from disk directories. The special filenames 
A:, B:,
and so on represent the directories on the indicated drives (X: 
is the default
drive). A directory is made to look like an ASCII file of 
filenames, one per line.
This facility makes it easy to select filenames from which you 
can build
SUBMIT files, for performing multifile operations.<p>

Used in combination, these programs can perform a wide variety of 
tasks.<p>

You may notice in the source code for some these programs the use 
of
bitwise logical operators | and &amp; in places where their 
relational counterparts
|| and &amp;&amp; would seem more appropriate. This is because 
these programs were
originally developed under Small-C version 1, which did not 
support the
relational operators.<p>
<b>
System Requirements<p>
</b>

This implementation of the Small-Tools package runs on 
8080/8085/Z80
machines using the CP/M-80 operating system. You should have two 
disk
drives and 56K of memory. Since these programs are written in 
Small-C and
are distributed as source code, you must have the Small-C 
compiler (version
2.1 or later).<p>
<center>
<b>Small-Tools Concepts and Facilities<p>
</b>
</center>
<b>File Concepts<p>
</b>

Every Small-Tools file has the same format. A file consists of a 
sequence of lines.
If the file resides on disk, the last line is followed by an 
end-of-file byte of value
26 decimal (1A hex). In the case where a file ends with the last 
byte of a sector,
however, the end-of-file byte is not written. If the file is 
assigned to an
input/output device, such as a printer, no end-of-file byte is 
written either.<p>

A line consists of a series of zero or more characters terminated 
by a
two-character carriage-return, line-feed sequence. A line may 
contain, at most, 192
data characters besides the two terminating characters. When you 
enter data
from the console, a line is automatically terminated after the 
192nd character.
When reading text files, most programs interrupt a line after the 
192nd
character and begin the next line with the following character.<p>


If the output of a program is directed to a disk file and a file 
by the same
name already exists, then it is overwritten. The text editor is 
an exception; it
first renames an existing file to a .$$$ extension, then after a 
successful write
operation it deletes the .$$$ file.<p>

Most programs have one input file and one output file. These 
&quot;standard&quot;
files may be directed to disk files or devices. Unless 
redirected, the standard
input file is assigned to the keyboard and the standard output 
file is assigned to
the screen. You may place input/output redirection specifications 
in the
command line to alter these default assignments.<p>

The redirection specification for standard input consists of the 
&quot;less than&quot;
symbol &lt; followed immediately by a filename (in regular CP/M 
format) or a
logical device name (CON: or RDR:) or a directory name (A:, 
B:,..., G:, X:).
The character string &lt;B:FILE3 redirects standard input to 
FILE3 on drive B, and
&lt;B: redirects it to the directory on drive B.<p>

The redirection specification for standard output uses the 
&quot;greater than&quot;
symbol &gt; instead. Filenames or logical devices (CON:, LST:, or 
PUN:) may be
used. Naturally, directory names cannot be used for output. When 
standard
output is redirected by a pair of symbols (for example, 
&gt;&gt;FILE3) then the output
is appended to whatever data was already in the named file. If 
the file does not
already exist it is created, and &gt;&gt; is no different than 
&gt;.<p>

Both redirection specifications may be given simultaneously and 
placed in
any order and in any position following the program name in the 
command
line.<p>

Take care not to assign both the input and the output of a 
program to the
same file; the result will be a corrupted file.<p>

<b>Command-Line Format<p>
</b>

The command to invoke a Small-Tools program consists of (1) the 
program
name with optional drive designator in standard CP/M format, (2) 
redirection
specifications for standard input and output files, and (3) 
parameters used to
control the action of the program. One or more spaces are used to 
separate the
parts of a command; therefore, a parameter may not contain 
embedded spaces.
An escape sequence (described later) may be used to specify 
spaces in
parameters.<p>

Redirection specifications are not seen by the programs, so they 
may appear
in any position following the program name. The position of 
parameters,
however, may be important. The CHANGE program (<a 
href="#list13-1">Listing 13-1</a> ), for instance, takes two
parameters--a text pattern to look for in the input file and a 
character string that
replaces all occurrences of the text pattern in the output file. 
The first parameter
is taken for the search pattern and the second parameter is taken 
for the
replacement string. They must be given in that order.<p>

Note: To be effective, several of the programs need to accept 
lowercase
letters in parameters. However, the CP/M CCP and SUBMIT program 
convert
command lines to uppercase before passing them on to programs. 
Patches to allow
lowercase characters are provided in the documentation on the 
distribution
diskette. After you apply these patches, you can create lowercase 
filenames with
the CP/M utilities. I recommend, however, that you use lowercase 
only to
specify text patterns and replacement strings, since you might 
encounter problems
with lowercase CP/M filenames. The Small-Tools programs, on the 
other hand,
always convert filenames to uppercase, in keeping with the CP/M 
convention.<p>

<b>Command-Line Switches<p>
</b>

A special class of command-line parameter, known as a switch, is 
often used to
control peripheral or secondary effects of a program. Switches 
usually consist of
a hyphen immediately followed by one or more letters and, in some 
cases,
numeric values. For example, the switch -BP123 informs the print 
program to
(b)egin output on (p)age (123). As the parentheses indicate, 
switches are
designed to be easily remembered.<p>

Switches may appear in any position after the program name. Only
nonswitch parameters are sensitive to position, and that is only 
with respect to one
another. Switches and redirection specifications may be freely 
spread among
nonswitch parameters without affecting them.<p>

Since switches are introduced by hyphens, you should avoid 
filenames that
begin with a hyphen (such names given as nonswitch parameters 
would look
like switches).<p>

<b>Usage Messages<p>
</b>

To aid in remembering the various switches and parameters used 
with these
programs, the console displays a usage message whenever you 
invoke a
Small-Tools program with a null or undefined switch. If you need 
help remembering
how to invoke a program, just enter the program's name followed 
by an isolated
hyphen. Usage messages indicate the syntax of the command to 
invoke a
program; they have the form<p>
<pre>
        usage: &lt;program&gt; &lt;parameter&gt;... &lt;switch&gt;...<p>
</pre>
where &lt;program&gt; is the program name, &lt;parameter&gt; is a 
nonswitch
parameter, &lt;switch&gt; is a switch, and the ellipses indicate 
that other occurrences may
follow. Switches are always optional. Nonswitch parameters may or 
may not be
optional, depending on the program.<p>

Redirection specifications are not shown in usage messages since 
they are
common to most programs and their presence can be assumed.<p>

Square brackets [] appear in usage messages to indicate optional 
fields. The
brackets are not part of the command. Programs take a default 
action when an
optional field is missing. Normally switches are needed only in 
exceptional
cases.<p>

The ellipsis (...) appears in usage messages to indicate, as 
above, that a
given type of field may occur more than once in the command. The 
ellipsis
itself is not part of the command.<p>

The vertical bar | is used to indicate alternate choices. In 
reading a usage
message, you may imagine the vertical bar stands for the word or. 
Like the
square bracket and the ellipsis, the vertical bar is not part of 
the command.<p>

The number sign # stands for a decimal integer of one or more 
digits.<p>

The question mark ? stands for any character or, in some cases, a 
string of
characters. Numbers, letters, and special characters are legal.<p>


Words or combinations of words are used as generic names for 
specific
types of parameters. For example, the term outfile stands for an 
output filename,
the word pattern stands for any legal search pattern, and so on.
<p>

<b>Error Handling<p>
</b>

All Small-Tools programs, except the editor, handle errors in the 
same way.
When an error occurs, a message is sent to the console with an 
audible alarm
and the program terminates.<p>

If the problem is an invaid command line parameter, the usage 
message
described above is sent to the console. Other errors result in 
other appropriate
messages.<p>

Two error messages are common to all Small-Tools programs. The 
message
&quot;output error&quot; indicates that an error occurred while 
writing into an output
disk file. The most probable cause is not enough space on the 
diskette to contain
the data. Since this error is common to all programs, it is not 
listed with the
individual program descriptions below. The other common error 
message is
&quot;&lt;file&gt;: can't open,&quot; which means that a file by 
the name &lt;file&gt; cannot be
found on the diskette in question.<p>

Two errors are caught by the runtime library rather than the 
program:<p>
<UL>
<LI>R, Redirection specification error, which indicates an attempt to redirect 
standard input to come from a nonexistent file.
<LI> M, Memory allocation error, which indicates that an attempt 
was made to 
allocate more memory than was available. This error should never 
occur.<p>
</UL>
<b>Escape Sequences<p>
</b>

Sometimes it is necessary to enter nonprintable characters or 
characters that
ordinarily have special meaning. You can enter such characters 
from the
keyboard by using the colon as an escape character. An escape 
character changes
the meaning of the character that follows it.<p>

Together, the escape character and the character following are 
seen as a
single character by the program. The escape sequences are:<p>
<pre>
     :b                   backspace
     :n                   newline (carriage return)
     :s                   space
     :t                   tab
     :&lt;other character&gt;   the actual character given<p>
</pre>

Some special characters known as metacharacters have special 
meaning when
they appear in search patterns or replacement strings. You may 
use the &lt;other
character&gt; escape sequence to force them to be seen as 
themselves in these
contexts.<p>

The colon, having a special use (escape character), must be 
escaped to be
accepted as itself; thus, :: is taken for a single colon.<p>

Provision is made for the space character, since if an actual 
space were
included in a parameter, it would delimit the parameter.<p>

<b>Metacharacters<p>
</b>

Certain characters assume special meanings when they appear in 
search
patterns or replacement strings (Table 13-2). As a group, these 
characters are
designated metacharacters (as opposed to ordinary characters). 
Since these
metacharacters occasionally need to appear as ordinary characters 
in a search
pattern or replacement string, they may, in such cases, be 
entered as escape
sequences. All the Small-Tools programs use the metacharacter 
definitions
found in the file TOOLS.H. You may change these metacharacter 
assignments
to suit your fancy by changing that file before compiling the 
programs.<p>
<b>
Search Patterns<p>
</b>

Search patterns are used by the text editor and some other 
programs to identify
selected character strings.<p>

The simplest form of search pattern is a character string 
identical to the
one sought.<p>

Preceding the pattern with a grave accent (`) specifies that the 
string must
appear at the beginning of a line. The grave accent in any other 
position has no
special meaning.<p>

Terminating a pattern with an apostrophe (') specifies that the 
string being
sought must occur at the end of a line. An apostrophe in any 
other position has
no special meaning.<p>

The following patterns illustrate the use of these 
metacharacters:<p>
<pre>
     <b>pattern                          meaning</b>

     `abcd              the string &quot;abcd&quot; at the beginning of a line
     xyz'               the string &quot;xyz&quot; at the end of a line
     `xxx'              a line consisting of only &quot;xxx&quot;
     ab'cd`e           the string &quot;ab'cd`e&quot; occurring anywhere in a line<p>
</pre>
A question mark ? in a pattern matches any character in that 
position of a
string. Thus, the pattern f??t matches foot, feet, f it, and so 
on.<p>

An asterisk (*) causes a match on zero or more occurrences of the
preceding character. An asterisk at the beginning of a pattern 
has no special meaning.
The following examples illustrate the use of the asterisk.<p>
<pre>
     <b>pattern                        matching strings</b>

     *abc               *abc
     a*bc               bc, abc, aabc, aaabc, ...
     aa*bc              abc, aabc, aaabc, aaaabc, ...
     s?*p               sp, sxp, sleep, sl2 xp, ...
     the:s*man          theman, the man, the   man, ...<p>
</pre>
<center>
<b>Table 13-2. Metacharacters and Their Special Meanings</b>
</center>
<pre>
   <b>symbol    name             use</b>

   :         colon            escape character
   `         grave accent     matches the beginning of a line
   '         apostrophe       matches the end of a line
   ?         question mark    matches any character
   *         asterisk         matches zero or more occurrences of the
                              preceding character
   [         left bracket     introduces a character class definition
   ]         right bracket    terminates a character class definition
   -         hyphen           indicates a range of characters in a character class
                              definition
   ~         tilde            complements a character class definition
   ^         circumflex       in a replacement string, stands for the entire
                              original string<p>
</pre>
You may specify that a character position in the pattern will 
match any one of a
list (or class) of characters, but no others. To do this, simply 
enclose the list of
characters in square brackets. For example, the pattern <i>
ab[15Q]z</i> matches <i>ablz</i>,
<i>ab5z</i>, <i>abQz</i>, but not <i>ab3z</i>.<p>

Since the set of decimal digits, lowercase letters, and uppercase 
letters are
used frequently, and since they are such long lists, a shorthand 
method of
specifying [012...9], [abc...z], and [ABC...Z] exists. You may 
place a hyphen between
the first and last characters. Thus, the pattern <i>a[0-9]</i> 
matches <i>a0</i>, <i>a1</i>, and so on,
and the pattern<i> [A-Z] [a-z]*</i> matches <i>A</i>, <i>Able</i>
, <i>Zebra</i>, and so on.<p>

You need not specify the entire set of decimal digits nor all of 
the letters
when the shorthand notation is used. You may give [5-7], [a-g], 
and so on. The
only restrictions are that the lower-valued character must be 
listed in front of
the hyphen. You may use the shorthand notation in a list of 
characters
specifying a character class. Thus, <i>[s12g5-7a-zA-Z$(]</i> is a 
valid character class.<p>

The hyphen (-) has special meaning only when it falls between 
characters
in a character class definition. If it appears at either end of 
the definition or
outside such a definition, it has no special meaning.<p>

If the first character inside the left bracket is a tilde (~), it 
causes a match
on any character except those listed.<p>

It is important to think of the character class as a single 
character position.<p>

If you need a literal [ or ] in a pattern, then escape it as :[ 
or :],
respectively.<p>

<b>Console Input<p>
</b>

Whenever you use the console keyboard for input, you may correct 
errors
anytime before you press the carriage-return key. You may erase 
input characters in
the reverse order from which you entered them; simply press the 
delete (DEL)
or backspace (BS) key for each erasure. A 
backspace-space-backspace sequence is
echoed to the console for each such erasure; if the console 
device is a video
screen, this causes the disappearance of the last character in 
the line being
entered. Printer devices simply back up one print position.<p>

You may erase the entire line you are entering by pressing 
control-X.<p>

The CP/M printer toggle (control-P) does not work with Small-C 
programs.
It is generally not needed anyway, since program output can 
usually be
redirected to LST: or PUN:.<p>

You may command a Small-Tools program that is executing to pause 
or
abort. A paused program simply stops in its tracks and waits to 
be resumed. A
control-S character from the console pauses a program, and 
another one resumes
it. This is handy when a program's output is going to the console 
screen too fast.
You may alternately pause and resume program execution so that 
you may
study the output before it scrolls off the screen. You can abort 
a running or
paused program by entering control-C.<p>

Anytime a program's standard input is assigned to the console 
keyboard
(default condition), the program will continue to process input 
until a control-Z
is entered. The control-Z is taken for an end-of-file indicator. 
No prompt is
given to signal the operator that a program is waiting for input 
when standard
input is directed to the keyboard; the program sits there waiting 
for data to
process. The text editor is the only exception to this rule.<p>

<b>Header File<p>
</b>

The file TOOLS.H is included into each Small-Tools program at 
compile time. It
defines several system-wide parameters. As mentioned above, the
metacharacters are defined there. Also the maximum size of text 
lines and the
dimensions of the console screen and printer paper are defined. 
You may
change any of these values to suit your particular needs. You 
should preview
this file before starting to compile any Small-Tools programs.<p>
<center>
<b>Program Descriptions<p>
</b>
</center>

<b>CHANGE<p></b>
<pre>
            CHANGE pattern [replacement]<p>
</pre>
Description:<p>

CHANGE copies the standard input file to the standard output 
file. In the
process, it scans the text for occurrences of a pattern; a 
replacement string is
substituted for each occurrence found.<p>

The search pattern is given in the command line and is formed 
according
to the rules described above. Full use of metacharacters and 
escape sequences is
allowed.<p>

The replacement string is any string of characters. Only two 
metacharacters
have significance in a replacement string: the circumflex, which 
stands for the
entire string that matched the pattern, and the colon, which is 
the escape
character. If you desire an actual circumflex or colon, use an 
escape
 sequence to specify it.<p>

If no replacement string is given, the null string is assumed; 
that is, strings
matching the pattern are deleted.<p>

A search pattern or replacement string may not exceed 48 
characters in
length. Only the first 48 characters of longer strings are used.
<p>

It is a good idea to make a trial run of CHANGE with output to 
the console
before making the final run.<p>

Previewing the effect of the run on the screen will verify 
whether or not
you have specified the pattern and replacement strings correctly. 
Recall that you
may cause the program to pause and resume by successively 
entering control-S;
also, you may cause it to abort by entering a control-C.<p>

Examples:
</b>
<pre>
  <b>command                            description
</b>
  CHANGE &lt;ABC eror      
			Copy file ABC to the console, changing occurrences
			error of &quot;eror&quot; to &quot;error.&quot;

  CHANGE &lt;F1 &gt;F2
			Copy file F1 to file F2, deleting all leading numeric
			`[0-9]* digits from each line.<p>
</pre>
Messages:<p>
<pre>
 <b> message                            explanation</b>

  pattern too long       The expanded internal form of the pattern is too
                         large to fit into its reserved memory space.

  replacement too long   The expanded internal form of the replacement
                         string is too large to fit in its reserved memory space.<p>
</pre>
<b>COUNT<p></b>
<pre>
               COUNT [file] [-C|-W|-L]<p>
</pre>
Description:<p>

COUNT (<a href="#list13-3">Listing 13-3</a>) scans an input file, 
counting all characters, words, and lines. It then
reports its findings to the standard output file. A nonswitch 
parameter in the
command line is taken for a filename that is opened for input. If 
no such
filename is given, input comes from the standard input file, 
which may be
redirected.<p>

If no switch is given in the command line, it reports<p>
<pre>
     nnnnn characters
     nnnnn words
     nnnnn lines<p>
</pre>
where nnnnn is a number between 0 and 65535.<p>

If one of the switches is given, COUNT reports a single number, 
indicating
the number of characters (-C), words (-W), or lines (-L) found. 
If more than one
switch is given, only the first one is used.<p>

The carriage-return and line-feed characters that terminate each 
line are
not included in the character count. To get the total number of 
bytes in the file,
add to the character count two times the line count plus one for 
the end-of-file
byte (if the result is not a multiple of 128).<p>

A word is defined as any contiguous string of printable 
characters.<p>

Examples:<p>
<pre>
   <b>command                            comment</b>

   COUNT &lt;REPORT
			Display on the console the number of characters,
			words, and lines in the file named REPORT.

   COUNT &lt;FILE 
			Place the number of words in the file FILE
			into the &gt;WORDS -W file WORDS.<p>
</pre>
Messages: none<p>

<b>COPY<p></b>
<pre>
             COPY [file]... [.?] [-B] [-NCR] [-NLF] [-T#,#]<p>
</pre>
Description:<p>

COPY (<a href="#list13-2">Listing 13-2</a>) a general-purpose 
file-copying program. It copies standard Small-Tools
files as well as files of straight binary data in which the 
content of the file is
totally unrestricted. If you designate more than one input file, 
all the files are
concatenated into a single output file. You may also specify that 
any &quot;# include
...&quot; statements (in C programs) or &quot;.so ...&quot; 
formatting 
 commands (in FORMAT text files) be replaced by the contents of 
the named files.<p>

Files to be copied are listed in the command line in the order 
they are to be
joined. If no filenames are given, the standard input file is 
used. Output always
goes to the standard output file.<p>

If # include and .so files are to be included into the output, 
then the special
.? switch (described below) must be placed in the command line.<p>


It is customary to create filenames consisting of two parts, the 
name
proper and an extension to the name that designates the type of 
data in the
file. Normally these parts are separated by a period. The symbol 
? stands for
a string of zero or more characters corresponding to the 
extension used with
the files that are to be included in the copy process. If ? is 
null (an isolated
period is given), then all referenced files are included. If ? is 
one or more
characters long, then only the files whose extensions match ? are 
included
in the copy process.<p>

The -B switch designates that a binary copy is to occur; that is, 
a straight
byte-for-byte copy without any attempt to include referenced 
files and no
attempt to stop on end-of-file bytes within the files. Every byte 
of each input disk
file is copied to the output. If input is coming from the console 
or an I/O port, a
control-Z terminates the input. If the .? switch is given for a 
binary copy, the
console displays the message &quot;cannot include files during 
binary copy&quot; and the
run aborts.<p>

In the absence of the -B switch or one of the switches that 
implies a binary
copy operation, standard text files are assumed; in that case, 
the include
function is allowed and copying of an input file terminates when 
an end-of-file byte
is encountered.<p>

The -NCR switch, meaning &quot;no carriage return,&quot; 
indicates that any
carriage-return characters occurring in the input files are to be 
stripped away. This
switch implies a binary copy operation.<p>

The -NLF switch, meaning &quot;no line feeds,&quot; indicates 
that any line-feed
characters occurring in the input files are to be stripped away. 
This switch also
implies a binary copy operation.<p>

The -T#,# switch may be used to translate all occurrences of a 
given
character in the input files to another character. The first 
sharp sign stands
for the decimal value of the character to be translated; the 
second one is
the value it will become. This switch also implies a binary copy 
operation.
The action of this switch occurs after the -NCR and -NLF 
switches, so
characters translated to carriage returns or line feeds will not 
be stripped.<p>

You may use these last three switches to convert between standard 
text files
and foreign text files.<p>

Example:<p>
<pre>
   <b>command                              comment</b>

   COPY ABC DEF &gt;XYZ.     Write into the file XYZ the contents of file ABC
                          followed by DEF, replacing any &quot;#include ...&quot; or
                          &quot;.so ...&quot; lines with the contents of the named
                          files.<p>
</pre>
Messages:<p>
<pre>
   <b>message                             explanation</b>

   cannot include files   The include switch was given with a switch
   during binary copy     implying a binary copy operation.<p>
</pre>
<b>CRYPT<p></b>
<pre>
                CRYPT key<p>
</pre>
Description:<p>

CRYPT (<a href="#list13-4">Listing 13-4</a>) is used to encrypt 
and decrypt files of any type. Input to CRYPT comes
from the standard input file and output goes to the standard 
output file.<p>

A key, designated &quot;key&quot; in the command format above, is 
always required.
It may be any string of one or more characters (80 maximum). 
CRYPT
combines the key with the input file in a cyclic fashion, using 
the &quot;exclusive or&quot;
function to produce the output file. Processing takes no account 
of the character
set or the end-of-file byte in text files; it proceeds all the 
way through the file.
Thus, you may encrypt any type of file.<p>

Once a file has been encrypted, it is decrypted by processing the 
encrypted
file a second time using the same key used for encryption; that 
is, two passes on
a file using the same key return the file to its original form. 
You may achieve
extra security by using multiple encryption. Processing a file 
two or more times
with different keys of different lengths makes the encrypted file 
harder to
decipher. Decrypting is just a matter of processing the encrypted 
file again with each
key used to encrypt it; the order in which the keys are used is 
immaterial.<p>

This program is intended for use on disk files; however, it may 
operate on
data from the keyboard or from some I/O device connected to a 
port on the
computer. In such cases processing stops when a control-Z is 
encountered. The
control-Z does not appear in the output. Encrypted data is not 
printable; it
produces strange results on a printer or video screen.<p>

Examples:<p>
<pre>
   <b>command                              comment</b>

   CRYPT &lt;LIST &gt;CLIST     Encrypt the file LIST with the key MAY into the file
   MAY                    CLIST

   CRYPT &lt;CLIST MAY       If this command follows the one above, it decrypts
                          the file CLIST, sending the output to the console.
</pre>
Messages: none<p>

<b>DETAB<p></b>
<pre>
             DETAB [#]... [+#]<p>
</pre>
Description:<p>

DETAB (<a href="#list13-5">Listing 13-5</a>) is used to replace 
tab characters in a standard text file with the proper
number of blanks needed to make the file appear correctly on a 
device that does
not handle tab characters.<p>

Input comes from the standard input file, and output goes to the 
standard
output file.<p>

If no parameters are given in the command line, tab stops will be 
assumed
to exist at every eight columns, beginning with column 9. If this 
default setting
is not correct, you may specify a list of numbers in the command 
line. Each
number specifies a column in which a tab stop must exist to make 
the input
print normally on a device that does handle tabs. You may prefix 
the last
number by a plus sign to indicate that tab stops are to be 
assumed every #
columns after the last tab stop. If no unsigned numbers precede + 
#, the first
tab stop is at # plus 1.<p>

Example:<p>
<pre>
   <b>command                                  comment</b>

   DETAB &lt;SOURCE              Copy the file SOURCE (which contains tab
   &gt;LST: 5 +3                 characters intended for a typewriter-like device with
                              tab stops at positions 5, 8, 11, and so on) to the
                              device designated by logical device LST:.<p>
</pre>
Messages:<p>
<pre>
   <b>message                                explanation</b>

   tab stop beyond max line   Attempt to define a tab stop beyond the end of the
			length maximum size line.<p>
</pre>
<b>EDIT<p></b>
<pre>
                EDIT [file] [-V]<p>
</pre>
Description:<p>

EDIT (<a href="#list13-6">Listing 13-6</a>) is the Small-Tools 
text editor. It is used to create and modify standard text
files. If a file is named in the command line, EDIT automatically 
reads the
named file into the editing buffer and displays the first several 
lines on the
console. The editing buffer starts out empty when no file is 
named. A sharp sign
prompts you for a command.<p>

If the -v switch is given in the command line, a v command is 
issued
before anything else is done; it turns off automatic viewing of 
the buffer. This is
desirable when using EDIT in a submit file.<p>

EDIT obtains commands from the standard input file. It is 
possible,
therefore, to create a file of edit commands, then invoke the 
editor with standard
input redirected to that file. This is handy for standard editing 
functions,
especially when you invoke the editor from a submit file.<p>

When EDIT displays lines from the buffer, it sends the output to 
the
standard output file. You may redirect this output to a file or 
some device other
than the console. No useful reason comes to mind for redirecting 
standard
output, however.<p>

The Editing Buffer<p>

EDIT is an in-memory editor; that is, the entire file being 
edited must fit into an
editing buffer in the main memory of the computer. EDIT activity 
affects only
the in-memory copy of the file; the text residing on the disk is 
not affected
while editing activity is taking place. A write command must be 
issued to cause
the buffer contents to be written to disk, either as a new file 
or replacing an
existing file.<p>

Since the text formatter, copy program, print program, and 
Small-C
compiler support include statements, files too large to fit into 
memory can be
segmented into smaller parts and then treated as single files 
when formatting,
copying, printing, and compiling.<p>

Whenever EDIT changes a line in the buffer, it creates a new 
version of the
line. The original line is deleted logically, but continues to 
take up space in the
buffer. The same is true of lines deleted. For this reason, it is 
possible to
overflow the buffer when making a large number of changes to a 
file that by itself
would fit into the buffer. In practice this seldom happens; 
however, when it
does happen, a write command followed by an enter command causes 
the buffer
to be reorganized, squeezing out dead lines.<p>

Accessing Disk Files<p>

Three commands are provided for transferring text between the 
buffer and files
on disk. They are:<p>
<pre>
   <b>command                           description</b>

   e [file]              enter a file into the buffer
   r [file]              read a file into the buffer
   w [file]              write a file from the buffer<p>
</pre>
As mentioned above, the enter command replaces the contents of 
the buffer with
the contents of a file. The read command differs from the enter 
command in that
it inserts the contents of a file into the buffer at a designated 
point. The write
command, as mentioned above, transfers the contents of the buffer 
to a file; it
leaves the buffer unaffected by the operation. All or part of the 
buffer may be sent
to the file, but in every case the file contains only the text 
actually written.<p>

When you are performing extensive editing operations, you should
periodically issue the write command to save the current state of 
the buffer on disk. If
you do not do this and the computer loses power or the editor is 
accidentally
exited, the contents of the buffer will be lost. If you attempt 
to exit the editor
(Quit command) but forget to write to disk first, the warning 
&quot;didn't write to
disk&quot; will appear on the console and you will be prompted 
for another
command. A second attempt to exit the editor will silently 
succeed even if you do
not write to disk first. If the buffer contains no changes, no 
warning is given.<p>

The Default Filename<p>

The filename in the enter, read, and write commands is optional. 
EDIT
remembers which file it is working with. If any of these commands 
is issued without a
filename, EDIT assumes the remembered name. This reduces the 
chance of
error in repeatedly naming the same file; it also reduces the 
number of keystrokes
in the editing session.<p>

Whenever an enter command specifies a filename, that name becomes 
the
new default filename. The filename given with a read or write 
command
becomes the new default filename only if none of these three 
commands has been
issued since the start of the program.<p>

The file command f [file] may be used either to display or set 
the default
filename. When no name is given, it simply displays the default 
name. When a
name is given, it becomes the new default name.<p>

The Current Line<p>

The current line is the line in the buffer that will be the 
target of the next
command if that command is given without any line number(s). 
Usually the
last line affected by a command becomes the current line for 
future commands.
In some cases the first line affected becomes the current line. 
The description of
each command tells how it affects the current line setting.<p>

The Flag Column<p>

The left-most column of the console display is not used for 
displaying text; it is
reserved for the current line flag, an asterisk, and the 
command-prompt
character, a sharp sign. The flag on the current line, keeps you 
aware of your position
within the buffer.<p>

Line Numbers<p>

Most commands operate on a single line or a contiguous group of 
lines. To
designate the target line(s), you may place one or more line 
numbers immediately
before the command if the default line numbers would not be 
appropriate.
When you specify multiple line numbers, separate them by a comma 
or a
semi-colon. The use of a semicolon causes the first number to 
become the current
line before the second number is evaluated. If you specify more 
line numbers
than the command requires, the right-most number(s) are used.<p>

A line number always corresponds to the position of a line in the 
buffer:
line 1 is always the first line in the buffer, line 253 is the 
253rd line in the buffer.
This means that line numbers change as editing takes place. If, 
for example, line
25 is deleted, then line 26 becomes 25, line 27 becomes 26, and 
so on. If a line is
inserted before line 5, then line 5 becomes line 6, line 6 
becomes line 7, and so
on. This does not prove difficult to keep up with, however, since 
you may
specify line numbers symbolically by using special characters and 
search patterns.
You seldom specify actual numeric line numbers.<p>

The line command 1 displays the number of the current line so 
that it may
be used in a subsequent command. You may specify a period (.) or 
a vertical bar
| in place of a line number. The period stands for the current 
line and the
vertical bar stands for the last line in the buffer.<p>

A line number may be expressed as a search pattern delimited with 
slashes
or backslashes. The line number /abc/ is the number of the first 
line following
the current line that contains the pattern abc. The line number 
<i>\' func()\</i> is the
number of the last line preceding the current line that contains 
the pattern
<i>func()</i> at the beginning of the line.<p>

You may specify line numbers as the sum or difference of line 
numbers; for
example, the expression .+5 specifies the fifth line after the 
current line, and
the expression |-213 specifies the 213th line before the last 
line. The expression
/John Doe/-1 is the number of the line preceding the next line 
containing the
pattern &quot;John Doe.&quot; Any number of terms may appear in a 
line number
expression. If the value on the left of the + or - sign is 
omitted, it defaults to &quot;.&quot;. If the
value on the right is omitted, it defaults to &quot;1&quot;. 
Thus, the following expressions
are valid:<p>
<pre>
      .+12-5           is equivalent to       .+7
      +5-2-11          is equivalent to       .-8
      .+7+             is equivalent to       .+8
      ++++++++         is equivalent to       .+8
      -----            is equivalent to       .-5<p>
</pre>
The following commands illustrate the use of line numbers:<p>
<pre>
     1,|p              Print every line in the buffer.

     1,.d              Delete every line from the beginning of
                       the buffer through the current line.

     \`1.\,`12./p       Print all lines from the previous line
                       containing the string &quot;1.&quot; at its
                       beginning through the next line
                       containing &quot;12.&quot; at its beginning.

     .-2,.+2d          Delete the current line and two lines on
                       either side.

     +23               Make the 23rd line below the current
                       line become the new current line.

     -----             Make the 5th previous line become the
                       new current line.

     /abc/;.-1,.+1d    Find the next line containing &quot;abc&quot;,
                       make it the current line, and delete it
                       and one line on each side of it.<p>
</pre>
Search Patterns<p>

Search Patterns used with commands may be formed using all the 
facilities
described above. When search patterns are used for line numbers, 
you may use
only the delimiters / and \. When they appear in the substitute 
command or in
the global or exclude prefixes, the first character after the 
command or prefix
letter (s, g, or x) is used for the delimiter.<p>

Whenever a search pattern is given, it becomes the new default 
pattern.
The default pattern is referenced by the occurrence of two 
successive
delimiters.<p>

Edit Commands<p>

In the command descriptions that follow, the line numbers in 
square brackets
are the default line numbers. You may override them by supplying 
different line
numbers in their places. If only one line number is given for a 
command that
takes two, the number given is taken for both numbers. If more 
than the
required number of line numbers are given, the right-most numbers 
are used.<p>

The term designated line(s) in the command descriptions refers to 
the
effective line numbers, whether default or explicitly given as 
numbers, symbols (.
and |), search patterns (for example,/`abc/), or expressions 
composed of these
and arithmetic operators (+ or -). The term designated file 
refers to the
effective filename whether default or explicitly given.<p>

In the command formats shown below, the square brackets are not 
part of
the commands; they illustrate which parts of the commands are 
optional. The
symbol &lt;text&gt; stands for zero or more lines of text 
terminated with a period
by itself in column one. And the number sign # stands for a 
decimal integer.<p>

The command letters may be designated in uppercase or lowercase. 
An
optional print command (p) may be appended to the end of any 
command. This is
useful when automatic viewing of the buffer is turned off and you 
wish to see
the effect of a command without issuing a separate print command.
<p>

You can abort any iterative command, except Write, by pressing 
the Escape
key. Furthermore, you can terminate the print and zip commands by 
pressing
any key. (For a summary of edit commands, see Table 13-4.)<p>
<pre>
  [.+1]               The null command simply sets the current 
line
                      to the line number given. If no line number 
is
                      given, then the line following the current 
line
                      becomes the new current line. Thus a simple
                      carriage return drops the current line down 
one
                      place - a convenient way to browse.

  [.]a                Append &lt;text&gt; after the designated line.

  &lt;text&gt;              If the line number is 0, &lt;text&gt; is placed
                      before the first line in the buffer. Every
                      character in &lt;text&gt; is taken literally; that is,
                      no metacharacters or escape sequences are
                      recognized. Characters may be rubbed out,but
                      only in the line currently being entered. (BS
                      or DEL deletes the last character, and ^X
                      deletes the entire line.) To correct prior
                      lines, it is necessary to terminate the Append
                      command. A line consisting of just an
                      isolated period terminates &lt;text&gt;, but is not
                      a part of &lt;text&gt;.

  [.,.]c              Change the designated line(s) to &lt;text&gt;.
  &lt;text&gt;              Upon completion, the first line of &lt;text&gt;
                      becomes the new current line. A line
                      consisting of just an isolated period
                      terminates &lt;text&gt;, but is not a part of &lt;text&gt;.

  [.,.]d              Delete designated line(s).
                      The line following the last line deleted
                      becomes the new current line. When the last
                      line in the buffer is deleted, the last
                      remaining line becomes the current line.

  e [file]            Enter the designated file into the buffer.
                      Anything that might have been in the buffer
                      before the command was issued is lost. If the
                      buffer contains changes, the warning &quot;didn't
                      write to disk&quot; is given and the command is
                      ignored. A second attempt to enter new text
                      will be successful. The first line of the
                      buffer becomes the new current line.

  f [file]            Display or set the default filename. If a
                      filename is given, it becomes the new default
                      filename. In either case, the effective
                      default filename is displayed. This command
                      also displays the number of unused bytes
                      remaining in the edit buffer.

  [.]i                Insert &lt;text&gt; before the designated line.
  &lt;text&gt;              The last line of &lt;text&gt; becomes the new
                      current line. Insert differs from Append
                      only in the placement of &lt;text&gt;. A line
                      consisting of just an isolated period
                      terminates &lt;text&gt;, but is not a part of &lt;text&gt;.

  [.,.+1]j            Join the designated lines into one line.
                      The joined line becomes the new current line.

  l                   The current line number is displayed.

  [.,.]m#             Move designated line(s) to follow line #. The
                      last line moved becomes the new current line.

  [.,.]p[#]           Print the designated line(s) on the console.
                      If only the current line is designated, then
                      the context surrounding the current line is
                      also printed. The context of the line is the
                      # lines above and below it. The default
                      context is 7. Any time # is given, however,
                      it becomes the new default context for future
                      print operations. If the console device is a
                      video screen, it is cleared before the
                      printing commences. The last line printed
                      becomes the new current line. However, if 
ESC
                      aborts the printing, the current line is
                      backed up by the context value.

  q                   Quit editing. Control is returned to the
                      operating system. If the buffer contains
                      changes, the warning &quot;didn't write to disk&quot; is
                      given and the command is ignored. A second
                      attempt to quit will be successful.

  [.]r [file]         Read the designated file into the buffer. The
                      new text is placed after the designated line.
                      The last line read becomes the new current
                      line. Line number 0 may be given to cause
                      text to be inserted before the first line of
                      the buffer.

  [.,.]s/pat/rep/[g]  Substitute rep for first or all pat in
                      line(s). If the global flag g appears after
                      the command, all occurrences of the search
                      pattern pat are replaced; otherwise, only
                      the first occurrence in each line is replaced.
                      A circumflex (^) appearing in the replacement
                      string rep represents the entire string
                      matching the search pattern. It may appear
                      any number of times. Thus the command
                      &quot;s/abc/^-^-^/&quot; yields &quot;abc-abc-abc&quot;. The
                      escape sequence :n appearing in the
                      replacement string splits the line into
                      separate lines at each such occurrence. The
                      last line changed becomes the current line.

  v                   View the current line in context
                      automatically. By default, whenever the
                      buffer is altered or the current line is
                      changed, the new current line is printed in
                      its context. This action may be turned off
                      and on by issuing the v command. Each v
                      toggles it to the opposite state.

  [1,|]w [file]       Write designated lines to the designated file.
                      If the target file does not exist, a new file
                      is created. If it exists, it is first renamed
                      to a .$$$ extension, then if the operation is
                      successful the .$$$ file is deleted. If, by
                      chance, a .$$$ version of the file already
                      exists, it is retained and the original file
                      is ovewritten directly. Then, after a
                      successful operation, the .$$$ file is
                      deleted. If a write error occurs, the probable
                      cause is insufficient space on the diskette or
                      in its directory. In such cases, an error
                      message is issued, the editor continues to run,
                      and the original file is retained with
                      a .$$$ extension.

  [.,|]z              Zip through the edit buffer. The designated
                      lines are printed on the screen until any key
                      is pressed. This allows quick browsing
                      through the buffer.<p>
</pre>
Two prefixes may be attached to any of the commands listed above 
except
append, change, insert, and quit; they are:<p>
<pre>
  [1,|]g/pat/command  The global prefix searches the designated
                      lines for lines containing the search pattern
                      pat. Each such line is then made the
                      current line and the command (indicated by the
                      word command) is executed. The default
                      pattern seen by the command is just the search
                      pattern in the prefix. The current line upon
                      completion is determined by the last iteration
                      of the command.

  [1,|]x/pat/command  The exclude prefix operates exactly like the
                      global prefix, except that lines that do not
                      contain the pattern are selected for processing.<p>
</pre>

The commands used with the global and the exclude prefixes may 
have their
own line numbers as usual; however, no intervening space or 
punctuation is
allowed between the right-most pattern delimiter and the command.
<p>

Messages:
<pre>
 <b> message                              explanation
</b>
  didn't write to disk    Attempt to &quot;enter&quot; another file or delete the entire
                          buffer before the changes in the buffer have been
                          written to disk.

  error                   A command was not entered correctly or a line
                          number was entered as a search string and the
                          search failed.

  memory overflow         The editing buffer in memory cannot hold any
                          more lines. This occurs while attempting to enter or
                          read a file that will not fit or attempting to make
                          too many changes to a file already in memory.

  open error              An attempt to open a file specified in an Enter or
                          Read command failed because no such file exists on
                          the diskette in question.

  write error             An error occurred while writing into a disk file.<p>
</pre>
<b>ENTAB<p></b>
<pre>
             ENTAB [#]... [+#]<p>
</pre>
Description:<p>

ENTAB (<a href="#list13-7">Listing 13-7</a>) is used to replace 
blanks in a standard text file with tab characters. It
exactly reverses the effect of DETAB.<p>

Input comes from the standard input file, and output goes to the 
standard
output file.<p>

If no parameters are given in the command line, tab stops are 
assumed to
exist at every eight columns, starting with column 9. If this 
default setting is not
correct, you may specify a list of numbers in the command line. 
Each number
specifies a column in which a tab stop exists. You may prefix the 
last number by
a plus sign to indicate that tab stops occur every # columns 
after the previous
tab stop. If no unsigned numbers precede + #, the first tab stop 
is at # plus 1.<p>

Examples:<p>
<pre>
  <b>command                             comment</b>

  ENTAB &lt;ABC &gt;DEF        Copy file ABC to DEF, replacing consecutive spaces
                         with equivalent tabs, assuming tab stops at every 8
                         positions starting with 9.

  ENTAB &lt;XYZ &gt;LST: 5     Copy file XYZ to the LST: device that has tab stops
  +3                     set at positions 5, 8, 11, and so on.<p>
</pre>
Messages:
<pre>
 <b> message                              explanation</b>

  tab stop beyond 192    Attempt to set a tab stop beyond the last position in
                         the maximum size line.<p>
</pre>
<b>FIND<p></b>
<pre>
               FIND [~]pattern<p>
</pre>
Description:<p>

FIND (<a href="#list13-8">Listing 13-8</a>) copies the standard 
input file to the standard output file. In the process, it
scans the text for occurrences of a search pattern. Only lines 
containing or not
containing the search pattern are output; that is, FIND selects 
from a file just
those lines containing a search pattern or just those lines not 
containing it.<p>

The search pattern is given in the command line and is formed 
according
to the rules described above. Full use of metacharacters and 
escape sequences is
allowed.<p>

If the pattern is prefixed by a tilde symbol (~), then lines not 
containing the
pattern are output, otherwise lines containing the pattern are 
selected.<p>

Examples:<p>
<pre>
  <b>command                              comment</b>

  FIND &lt;ABC `[~:s:t]     Display upon the console all lines in the file ABC
                         that begin with a nonblank, nontab character.

  FIND &lt;ABC &gt;DEF ~`'     Copy file ABC to DEF, removing all null lines.<p>
</pre>
Messages:<p>
<pre>
     <b>message                           explanation</b>

     pattern too long    The expanded internal form of the pattern is too
                         large to fit into its reserved memory space.<p>
</pre>
<b>FONT<p></b>
<pre>
                     FONT [device]<p>
</pre>
Description:<p>

This program (<a href="#list13-9">Listing 13-9</a>) selects 
optional print fonts for a printer. In its distribution form, it
selects from the options available on the Epson FX-80 printer. 
However, it is a
simple program and can be modified easily to work with other 
printers.<p>

Without a file (or logical device) name in the command line, it 
sends its
output to the LST: device.<p>

FONT presents the menu in Table 13-3 to the standard output file 
(defaults
to screen) and waits for a response from the standard input file 
(defaults to the
keyboard).<p>
<center>
<b>Table 13-3. Select Epson FX Options</b>
</center>
<pre>
        <b>set   clear      mode</b>

         1      2        condensed
         3      4        double strike
         5      6        elite
         7      8        emphasized
         9     10        enlarged
        11     12        italics
        13     14        pica
        15     16        subscript
        17     18        superscript
        19     20        proportional

        select...<p>
</pre>
A valid response is translated into the required sequence of 
control characters,
and the menu is again presented for another selection. A null 
response (carriage
return) exits the program. Provision is made for setting and 
clearing each option
individually.<p>

Examples:<p>
<pre>
     <b>command                           comment</b>

     FONT                  Send output to the LST: device.

     FONT PUN:             Send output to the PUN: device.<p>
</pre>
Messages: none<p>

<b>FORMAT<p></b>
<pre>
                FORMAT [mergefile] [-BC#] [-EC#]
                 [-BP#] [-EP#] [-PO#] [-NP] [-NR]
                 [-T] [-I] [-U] [-S] [-BS#]<p>
</pre>
Description:<p>

FORMAT (<a href="#list13-10">Listing 13-10</a>) is the 
Small-Tools text formatter. It converts text files containing
embedded commands into formatted documents ready for printing.<p>

FORMAT obtains its primary input from the standard input file. 
Input
may, therefore, be directed to come from disk files or the 
keyboard. Output goes
to the standard output file, so it may be directed to go to a 
disk file, the console
screen, or a printer.<p>

You may also specify a second input file, the merge file. In that 
case, a copy
of the primary input file is produced for each line in the merge 
file. You may
break each line of the merge file into any number of fields by 
using a delimiter
character (default |) between fields, but not at the ends of the 
line. You can
reference these fields, in the primary file, by placing a number 
between two
occurrences of the delimiter. For example, |3| appearing in the 
primary file
refers to the third field in the current line of the merge file.
<p>

When FORMAT finds such a reference, it replaces it by the 
designated field
from the current line of the merge file. The result is a 
customized copy of the
document for each line of the merge file. The most obvious 
application of the
merge feature is mailing-list processing, but other uses are 
possible.<p>

Since it is often necessary to do just part of a print job, 
switches are
provided to control the starting and stopping of output. The 
switch -BC12 means to
begin on copy 12; -EC25 means to end on copy 25. Copy here refers 
to complete
copies of the primary file, one for each line in the merge file. 
If these switches
are given without a merge file, then the indicated number of 
copies of the
primary file are produced. In such cases the -BC# switch is 
useless and, since it
defaults to the value 1, it may be omitted, causing # in the -EC# 
switch to be
the actual number of copies produced.<p>

The switch -BP2 means to begin on page 2; -EP112 means to end on 
page
112. Pages here refer to formatted pages within a copy of the 
primary file. If the
switches -BC13 and -BP2 are both given, printing begins with page 
2 of copy 13,
then continues for all pages of subsequent copies. If the 
switches -EC24 and -EP1
are both given, printing ends after page 1 of copy 24.<p>

A page offset may be specified in the command line. The switch 
-PO5 tells
FORMAT to shift odd-numered pages five spaces to the right and
even-numbered pages five spaces to the left. This provides a wide 
margin for binding
material that will have printing on both sides of the paper.

By default, FORMAT will pause before printing each page of the
document. It displays the message &quot;set page # ...&quot; and 
then waits for a response
indicating that the next page is in place and the printer is 
ready. This gives
you an opportunity to load the next sheet of paper. A control-N 
from the
keyboard causes FORMAT to skip to the next page; it again issues 
the &quot;set
page # ...&quot; message before proceeding. Any other response 
causes FORMAT
to commence printing.<p>

The switch -NP tells FORMAT to print with no pauses; that is, 
after an
initial &quot;ready printer...&quot; prompt, printing continues 
without pauses between
pages. This option is used with continuous forms.<p>

The -NR switch tells FORMAT to negate the ready prompt. This is 
useful
when FORMAT is used in a SUBMIT file that you wish to run without
interruption.<p>

Two modes are provided for controlling the method of handling
Underline, Boldface, and Italicize commands. They are Epson (or 
dot-matrix)
mode, and TTY (or dumb printer) mode. In Epson mode (the default
mode), control-character sequences cause the printer to 
underline, boldface,
and italicize with a minimum of head movement. Double width 
printing is
also possible. In TTY mode (specified with the -T switch), 
underlining and
boldfacing are done by multistriking; italicizing and double-wide 
printing
are not done at all.<p>

The -I switch causes underline commands to be treated as italic 
commands.<p>

The -U command causes italic commands to be treated as underline
commands.<p>

The -S switch causes FORMAT to show in the output the names of 
files
included with the &quot;.so file&quot; command. This helps 
identify file boundaries in
draft copies of large documents.<p>

The -BS# switch overrides the default number of boldface strikes 
used in
TTY mode. The symbol # is the number of strikes to use.<p>

Commands:<p>

Commands instructing FORMAT what to do are embedded in the text 
being
processed. Every line beginning with a period (or other 
designated character) is
taken as a command. Each command consists of two letters 
immediately
following the period. The letters are chosen for mnemonic value 
and thus are not
difficult to remember.<p>

Most commands take optional numeric or character string 
parameters in
the same line. One or more spaces separate the command from its 
value. You
may specify commands in lowercase or uppercase letters.<p>

Instead of a period, the command flag may be changed to another 
character
by giving the command character command .cc ? where ? stands for 
the new
command flag. You may use the command ?cc . later to return to 
the period for
a command flag. Changing the command flag permits you to process 
text with a
leading period in the lines.<p>

Every command that takes a numeric value will accept it as either 
an
absolute value or a relative value. If an unsigned number is 
given, it is taken for the
new value. If a plus or minus sign prefixes the number, however, 
then it is
added to or subtracted from the original value to arrive at the 
new value.<p>

For example, if a section of text is to be indented four places, 
after which
normal indenting is to be resumed, you may give:<p>
<pre>
     .in +4
       .
       .
       .
     .in -4<p>
</pre>

This arrangement permits you to make local formatting changes 
independently
of global considerations. You may then place global 
specifications at the
beginning of the file, where you can easily find and change them. 
For instance, you
should not have to search throughout a file to find every 
occurrence of a
command that may need changing when you wish to reprint an 
existing document
with different margin settings.<p>

The Page Layout:<p>

Pages produced by FORMAT have the format shown in Figure 13-1.<p>

The dimensions that specify the page layout are specified as 
number of
lines (vertical) and number of columns (horizontal). Each 
dimension is shown
with its corresponding default value in parentheses.<p>

Notice that the top and bottom margins are each five lines high. 
That is the
effective size of the margins; actually, the default sizes for 
margins 1 and 4 are 1
and 9 respectively. The margins are equalized by setting the 
paper in the printer
such that the first line of print, margin 1, starts about four 
lines down from the
top edge of the paper. This is a natural setting for the 
top-of-page position of
paper in a printer.<p>

When you use continuous forms in the printer, you should usually 
specify
the -NP switch. In that case, FORMAT prints without pausing 
between pages.
The bottom margin skips over the perforations between pages, 
leaving equal
margins at the top and the bottom.<p>
<center>
<b>Figure 13-1. Page layout in FORMAT.<p></b>
</center>
<pre>
  -------------------------............................
  |                        |  margin 1 (5 lines)  :
  | xxxxxx header xxxxxxxx |.........             :
  |                        |  margin 2 (2 lines)  :
  |                        |.........             :
  | xxxxxxxxxxxxxxxxxxxxxx |                      :
  | xxxxxxxxxxxxxxxxxxxxxx |                      :
  | xxxxxxxxxxxxxxxxxxxxxx |                 page length
  | xxxxxxxx body xxxxxxxx |                  (66 lines)
  | xxxxxxxxxxxxxxxxxxxxxx |                      :
  | xxxxxxxxxxxxxxxxxxxxxx |                      :
  | xxxxxxxxxxxxxxxxxxxxxx |..........            :
  |                        |  margin 3 (2 lines)  :
  |                        |..........            :
  | xxxxxxx footer xxxxxx  |  margin 4 (5 lines)  :
  |                        |                      :
  --------------------------......................:....
    :                    :
    :                    right margin (column 74)
    :
    left margin (column 11)<p>
</pre>

If you are using cut sheets, you must mount them individually in 
the
printer, and you should not specify the -NP switch. In that case, 
FORMAT
pauses between pages, waiting for each sheet to be loaded. The 
pause comes
immediately after printing the footer. Printing resumes 
immediately with the
header of the next page. Thus, it is up to you to remove the old 
page and insert
the new one exactly where printing should resume.<p>

The following commands permit you to override the default page 
layout
values:<p>
<pre>

     .m1 #          margin 1
     .m2 #          margin 2
     .m3 #          margin 3
     .m4 #          margin 4
     .pl #          page length
     .lm #          left margin
     .rm #          right margin<p>
</pre>
You may give these commands at any point in the text, and they 
become
effective at that point. Normally, however, you give them at the 
start of the file and
leave them alone thereafter.<p>

Note: If you specify the page length as zero (.pl 0), then the 
document is
considered to be just one page of infinite length. In that case, 
formatting
proceeds as usual, except that there will be no page breaks and 
no headers or
footers. This is useful in formatting text for input to other 
programs.<p>

Headers and Footers:<p>

Header and footer lines are optional. Unless you specifically 
requested them,
they appear as blank lines within the first and fourth margins. 
Once specified,
header and footer lines automatically appear at the proper place 
on every page.
They remain in effect until you redefine them. Footers begin on 
the current
page and headers begin on the following page.<p>

Only one line is used for a header or footer. The header appears 
as the last
line of the first margin, and the footer appears as the first 
line of the fourth
margin. These margins must, therefore, be at least one line in 
size for the
headers and footers to appear.<p>

The .he [text] command is used to define a header consisting of 
the text, if
any, following the command. The .fo [text] command, likewise, 
defines a
footer. If no text is given, a null header or footer (that is, a 
blank line) is
indicated.<p>

FORMAT permits different headers and footers to be defined for 
odd- and
even-numbered pages. Altogether there are six commands:<p>
<pre>

     .he [text]     header
     .oh [text]     odd-page header
     .eh [text]     even-page header
     .fo [text]     footer
     .of [text]     odd-page footer
     .ef [text]     even-page footer<p>
</pre>

Two characters have special meaning within headers and footers. 
The number
sign # stands for the current page number. Whenever it appears in 
a header or
footer, it is replaced by the number of the current page. You may 
use the slash /
to break the text into sections that are equally spaced across 
the page from the
left margin to the right margin. The slashes are replaced by 
approximately equal
numbers of spaces such that the first character of text falls on 
the left margin
and the last character falls on the right margin. Judicious use 
of slashes can
produce centering of text, spreading of text, and one-sided 
justification.<p>

You may obtain a simple footer consisting of a page number 
centered
between and surrounded by hyphens with the command &quot;.fo /- # 
-/&quot;.<p>

Line Filling and Right-Margin Justifying:<p>

Unless told otherwise, FORMAT does not print a line in the body 
of a page until
it has gathered enough words to fill a line; that is, words are 
gathered into one
line until a word is encountered that would extend beyond the 
right margin.
That word is held and becomes the first word of the next line. 
This action is
called line filling. You may turn it off by the .nf command, 
meaning &quot;no
filling.&quot; You may turn it on again by the .fi command, 
meaning &quot;fill.&quot; If FORMAT
encounters contiguous spaces while gathering words, it ignores 
all but the first.
Two blanks are placed after the period that terminates a 
sentence.<p>

Another action taken automatically by FORMAT is to spread spaces
between words in a line so that the last character of the last 
word falls exactly on
the right margin. This action is called right-margin 
justification. It is turned off
by the .nj command, meaning &quot;no justifying.&quot; It may be 
turned on again by the
.ju command, meaning &quot;justify.&quot;<p>

Sometimes it is important that a certain number of blanks appear 
at a given
position within a line. Line filling and justification should not 
alter them. To
give added control over such circumstances, the tilde (~) is used 
to represent a
&quot;pseudo&quot; space. It is treated like any nonblank 
character for line filling and
justification purposes; however, it is changed to a blank just 
before it is output.<p>

If the tilde must appear as a tilde, then you may specify another 
character to
take its place as the pseudo-blank character. The command .bc x 
causes x to
become the pseudo-blank, and the command .bc ~ returns the tilde 
to its original
status.<p>

Line Breaks:<p>

Under certain conditions, while FORMAT is filling lines, it may 
print a line
that is not yet full. This is called a line break. In such cases, 
no right-margin
justifying takes place; that is, all excess blanks are to the 
right of the line.<p>

One thing that causes a break is a blank line in the text. When 
FORMAT
encounters a blank line, it prints the current line as is, then 
prints the blank line.
This is an easy way to break text into paragraphs separated by 
double spacing.<p>

Certain commands force a break to occur; they are:<p>
<pre>
     .fi           fill
     .nf           no filling
     .ju           justify right margin
     .nj           no justifying
     .br           break
     .sp #          space # lines
     .bp #          begin page
     .in #          indent # places
     .lm #          set left margin to #
     .ti #          temporary indent of # places
     .ce #          center the next # lines
     .sq #          squeeze margins # places each
     .ne #          need # lines together<p>
</pre>

The last thing that causes a break is a line with one or more 
leading blanks.
Such a line prints with its leading blanks in place; line filling 
and justification, if
in force, are applied to such a line.<p>

Page Breaks:<p>

As FORMAT processes text, it keeps track of how many lines have 
been placed
on the current page. When no more lines will fit, margins 3 and 
4, possibly
including a footer, are printed and a new page is started. If 
FORMAT is pausing
between pages (the default condition), you hear the audible alarm 
and see the
message &quot;set page # ...&quot; where # is the new page 
number. In this case, the
trailing lines of margin 4, following the footer, are not 
printed. This prevents the
bottom edge of the page from flipping up over the print mechanism 
and possibly
interfering with moving parts.<p>

If continuous printing is in effect, FORMAT proceeds 
uninterrupted with
the next page.<p>

Page breaks may be forced at any point in the text by using the 
.bp #
command, meaning begin page. If a number appears with the 
command, it sets
the value of the new page number; otherwise, the new page is 
numbered one
greater than the previous page.<p>

The value of the page numbers is significant in three ways. 
First, the page
number may be printed in headers and footers. Second, the page 
number
determines the direction of page offsets. And last, the page 
number may determine
the point in the document at which printing begins or ends.<p>

Indenting:<p>

An indent is a number of spaces added to or taken away from the 
left margin.
The default indent is zero. You may use the .in # command to set 
the indent
value for subsequent lines. You may use the .ti # command to set 
a temporary
indent for the following line only. This is handy for paragraph 
indention. The
default value for # in both commands is zero.<p>

The squeeze command .sq # is a special form of indent, causing 
FORMAT to
indent inward from both margins # places. This is handy for 
highlighting notes.
The default value for # is zero. Squeezed printing continues 
until FORMAT
encounters a .sq or .sq 0. On the left margin, the effect of 
squeezing is added to the
running indent and the temporary indent. A plus sign with # 
causes the current
squeeze value to be increased by #. A minus sign has the opposite 
effect.<p>

Centering:<p>

The command .ce # tells FORMAT to center the next # lines of 
text. The
default value for # is one, so the command .ce centers just the 
following line.
The command .ce 0 means to stop centering lines; it is handy when 
an
indefinite number of lines are to be centered. First give .ce 
1000 (or any number larger
than needed but no greater than 32767) followed by the text to be 
centered; end
with a .ce 0 command.<p>

Centering is done between the left and right margins; the indent 
value has
no effect on centering.<p>

Underlining:<p>

Text may be underlined by means of either of two underline 
commands. The
command .ul # instructs FORMAT to underline the next # lines of 
input text;
gaps between words are not underlined. The command .cu # is used 
for
continuous underlining; that is, gaps between words are 
underlined. Special characters
are not normally underlined; the continuous underline, however, 
does
underline parentheses, brackets, braces, colons, and semicolons.
<p>

The .ul and .cu commands are mutually exclusive. Whenever one is 
given,
it overrides the other in case the other one was in effect.<p>

As with the centering command, you may specify that an indefinite
number of lines be underlined by placing an arbitrarily large 
value on a .ul # or
.cu # command. After the text to be underlined, you may use a .ul 
0 or .cu 0 to
terminate underlining. Another way to terminate underlining is to 
issue the .nu
command, which means &quot;no underline.&quot; Any one of these 
three commands can
terminate either type of underlining.<p>

FORMAT operates in either of two modes as far as underlining (and 
italicizing
and boldfacing) is concerned. In Epson mode (the default) 
underlining is
accomplished by generating the proper sequences of control 
characters before and after
the text to be underlined; the printer (Epson or other 
dot-matrix) then underlines
it prints. In Teletype (switch -t) mode, underlining is 
accomplished by preceding
each character to be underlined with an underscore, backspace 
sequence.
Depending on the type of print mechanism you have, this mode can 
be pretty slow and
can create a great deal of jerky, back-and-forth head motion.<p>

The Note Command:<p>

The command . text causes text to be displayed on the console 
when the
program encounters it. First the audible alarm is sounded, then 
the word note: is
displayed, followed by the text in the command. The note line is 
ignored as far
as text formatting is concerned. You may use notes to give the 
operator special
instructions related to the handling of particular documents. For 
instance, you
may place a note at the end of a text file, giving the operator 
instructions as to
what to do next.<p>

Erroneous Commands:<p>

Unrecognizable commands are treated as notes. They sound the 
alarm and
appear on the console as notes, but are ignored as far as text 
formatting is
concerned. This signals the operator that something is wrong and 
shows the
questionable line. This happens if text to be formatted has a 
command flag
(usually a period) in the first position of a line.<p>

Operator Prompting:<p>

The .pr text command is used to prompt the operator for 
information to be
manually entered at some point in the document. It sounds the 
alarm, then displays the
word enter: followed by the text in the command. If the operator 
is to manually
supply the date for a letter, for instance, then the command 
&quot;.pr date&quot; would be
placed at the point in the text file where the date should 
appear. It must be on a
line by itself, however, just like all formatting commands. When 
this command is
encountered, the operator hears the alarm and sees &quot;enter:
 date&quot; on the console.<p>

At that point the program begins taking lines of text from the 
keyboard. It
is processed as if it were actually in the input file instead of 
the prompt
command. Input is terminated, as with the text editor, by a line 
containing only a
period. In the case illustrated above, only a single line of 
input would be given.
This would be followed by a terminator line. The terminating 
period is ignored
for text formatting purposes.<p>

Formatting commands may be entered manually during a response to 
a
prompt. Also, you may use the delete (DEL or RUB) and backspace 
(BS) keys to
delete the last remaining character in the line currently being 
entered, and a
control-X to delete the entire line being entered.<p>

Text from Alternate Sources:<p>

It is often convenient to create and save segments of text that 
you can call up
later for inclusion into various documents as they are being 
formatted. To do
this, use the text editor to enter the text and save it on disk 
under some
descriptive filename. Then place at the appropriate location in 
the calling document
the command &quot;.so file&quot; meaning the named file is the 
source for text to be
processed at this point. FORMAT will copy the entire contents of 
the named file
into the input stream just as though it were in the main file.<p>

This command is analogous to the prompt command except that the 
text
comes from a file rather than from the keyboard.<p>

The &quot;.so file&quot; command is handy for use in preparing 
legal documents (or
whatever) composed largely of standard paragraphs. The text in 
the named file
may contain embedded formatting commands, including the prompt 
command.<p>

Line Spacing:<p>

By default, FORMAT generates single-spaced output. This may be 
changed by
giving the .ls # command to change line spacing to # lines. A 
value of 2 gives
double spacing; that is, one blank line between printed lines.<p>

Occasionally, extra blank lines are desired at selected places in 
the
document. The space command .sp # may be used to obtain them. The 
command
.sp 11 causes a line break followed by 11 blank lines.<p>

<p>Another way to get the same effect is to enter eleven blank 
lines into the
text. This approach is not desirable, however, when more than one 
blank line is
needed, because it is difficult to tell how many blank lines will 
be generated by
looking at the screen. Six blank lines look about like five.<p>

Keeping Text Together:<p>

Two methods exist to prevent splitting sections of text between 
pages.
Sometimes, a table or list should be printed intact on a single 
page. To guarantee
enough space, you may issue the need command .ne #, meaning that 
# lines
are needed for the text that immediately follows. If the current 
page contains
enough space, no special action is taken. If, on the other hand, 
insufficient space
remains, FORMAT forces a page break and the following text begins 
a new page.<p>

The second method concerns avoiding orphan lines at the bottom of 
pages.
The minimum paragraph space command .mp # determines the minimum
number of lines that must remain in the body of a page before a 
new paragraph
will be printed. If insufficient space remains, a new page is 
begun. The default
value for this is 2. This value may be changed at any point in 
the text file.<p>

FORMAT has no automatic means of preventing widow lines at the 
top of a
page. After you have proofed the document, you may insert .ne # 
commands
for this purpose.<p>

Formatting Commands:<p>

Formatting commands (Table 13-5) are placed within the text files 
being
processed. Each one resides on a line by itself. You may give 
commands in
uppercase or lowercase letters.<p>

The square brackets appearing in the following command 
descriptions are
not actually a part of the commands; they only indicate that the 
enclosed field
is optional. Number signs (#) stand for decimal numbers between 0 
and 32767.
Any numeric value may be preceded with a minus or plus sign. The 
effect of a
sign is to cause the number to be taken as a change to an 
existing value rather
than an absolute new value. For example, .lm 5 means to set the 
left margin to
column 5; .lm + 5 means to move the left margin to the right five 
places. The
question mark stands for any printable character. The words text 
and file are
generic terms representing a line of text and a filename, 
respectively.<p>

The formatting commands follow in alphabetical order:<p>
<pre>
  .bc ?       blank character
              Use ? for the new pseudo-blank character. Occurrences
              of ? in the text will be treated as nonblanks for line
              filling and right margin justifying purposes, but will
              be converted to spaces before being output.

  .bf #       boldface
              Print the next # lines of source text in boldface. The
              default value for # is 1. The command .bf 0
              terminates boldface printing.

  .bp [#]     begin page
              Force a page break. If a number is given, it determines
              the number of the next page; otherwise, the current page
              number plus 1 is assumed.

  .br         break
              Force a line break; that is, the line being filled is
              printed as is, without right margin justification, and a
              new line is started.

  .cc ?       command character
              Use ? in the future for the character that identifies
              commands. Following commands must be prefixed by ?
              rather than the customary period.

  .ce [#]      center
              Force a line break, then cause the next # lines of text
              to be centered. The default value for # is 1.

  .cu [#]      continuous underline
              Underline the following # lines of text including the
              blank spaces between words. If # is zero, underlining
              is terminated. The default for # is 1.

  .dw [#]      double width
              Print the next # lines of source text in double width
              characters. The default value for # is 1. The command
              dw 0 terminates double width printing. Double width
              printing works only in Epson mode.

  .ef [text]  even-page footer
              Use text as a footer on even-numbered pages beginning
              with the current page. If no text is given, the even-page
              footer becomes null; that is, a blank line prints.

  .eh [text]  even-page header
              Use text as a header on even-numbered pages beginning
              with the next page. If no text is given, the even-page
              header becomes null; that is, a blank line is printed.

  .fi         fill
              Force a line break, then start line filling with the
              following text. Line filling is the default mode of
              operation, so this command would be used to reinstate
              line filling after it had been turned off.

  .fo [text]  footer
              Use text for a footer on all following pages beginning
              with the current page. If no text is given, suppress
              all footers beginning with the current page. Suppressed
              footers appear as blank lines.

  .he [text]  header
              Use text for a header on all pages after the current
              page. If no text is given, suppress all headers after
              the current page. Suppressed headers appear as blank lines.

  .in [#]      indent
              Force a line break, then indent the following text #
              places to the right of the left margin. If # is signed,
              however, the current indent value is to be changed by
              the indicated amount in the indicated direction (minus
              to the left, plus to the right). If the new indent
              value becomes negative, printing begins before the left
              margin. The default value for # is 0.

  .it #        italicize
              Print the next # lines of source text in italics. The
              default value for # is 1. The command .it 0
              terminates italicized printing. In TTY mode, this
              command is ignored (unless the -U switch causes it to
              be interpreted as an underline command).

  .ju         justify
              Force a line break, then begin justifying the right
              margin on the following lines. Since the justify mode
              is the default condition, this command would be used to
              reinstate justifying after it had been turned off.

  .lm [#]      left margin
              Force a page break, then use # to determine a new value
              for the left margin. The left margin is the column in
              which the first character of a line appears if no
              indenting is effective. The default value for # is 11.

  .ls [#]      line spacing
              Use # to determine a new value for line spacing. The
              default value for # is 1.

  .m1 [#]      margin 1
              Use # to determine the number of lines in margin 1, the
              top margin. The default value for # is 1. This command
              should precede the .pl # command.

  .m2 [#]      margin 2
              Use # to determine the number of lines in margin 2, the
              margin between margin 1 and the body of the page. The
              default value for # is 2. This command should precede
              the .pl # command.

  .m3 [#]      margin 3
              Use # to determine the number of lines in margin 3, the
              margin between the body of the page and margin 4. The
              default value for # is 2. This command should precede
              the .pl # command.

  .m4 [#]      margin 4
              Use # to determine the number of lines in margin 4, the
              bottom margin. The default value for # is 9. This
              command should precede the .pl # command.

  .mc ?       merge character
              Use ? as the field separator within lines of the merge
              file. Unless specified otherwise, the vertical bar is used.

  .mp [#]      minimum paragraph space
              Use # to determine the number of lines that must be
              available in the page before beginning a new paragraph.
              If insufficient space remains on the page, force a page
              break before beginning a new paragraph. The default
              value for # is 2.

  .ne [#]      need
              Force a line break, then ensure that at least # lines
              are available together. If insufficient space exists on
              the current page, force a page break. The default value
              for # is 0; that is, the command is ignored.

  .nf         no filling
              Force a line break, then discontinue filling lines.
              This implies a cessation of right margin justification
              also. If justification is in effect, it will be
              reinstated when line filling is again resumed.

  .nj         no justifying
              Force a line break, then discontinue right margin
              justifying. This command has no effect on line filling;
              it simply results in a ragged right margin.

  .nu         no underlining
              Terminate underlining of text. If either normal or
              continuous underlining is in effect, it will be
              discontinued.

  .of [text]  odd-page footer
              Use text as a footer on odd-numbered pages beginning
              with the current page. If no text is given, the
              odd-page footer becomes null; a blank line prints for a
              null footer.

  .oh [text]  odd-page header
              Use text as a header on odd-numbered pages beginning
              with the next page. If no text is given, the odd-page
              header becomes null; a blank line prints for a null header.

  .pl [#]      page length
              Use # to determine the page length. The default value
              for # is 66. The minimum page length is the sum of the
              margins .m1, .m2, .m3, and .m4 plus 1. So these margins
              must be set before issuing this command.

  .po [#]      page offset
              Use # to determine a new value for the page offset.
              Printing on odd-numbered pages is shifted right by this
              amount, and printing on even-numbered pages is shifted
              left. You may specify the same function by giving the
              -PO# switch in the command line that invokes format.
              The default value for # is 0.

  .pr [text]  prompt
              Prompt the operator for input. The audible alarm is
              sounded and the message &quot;enter: text,&quot; where the word
              text stands for the text following the command, is
              displayed on the console. Input from the keyboard is
              then processed as though it were in the input stream in
              place of the prompt command. Input from the keyboard is
              terminated by entering a line containing just a period;
              the terminator line is ignored for text formatting purposes.

  rm [#]       right margin
              Use # to determine a new value for the right margin;
              that is, the column where the last character is printed
              when right margin justifying is in effect. The default
              value for # is 74.

  .rs [#]      reserve space
              Reserve # lines of white space. If insufficient lines
              exist on the present page, force a page break and then
              skip over the required number of lines. At most one
              page may be reserved.

  .so file    source
              Use the named file as the source of text at this point
              in the process. When no more text remains in the
              designated file, continue with the next line.

  .sq [#]      squeeze
              Force a line break, then indent inward from both margins
              the number of places indicated by #. The default value
              for # is 0. The command .sq returns to normal
              printing. The command .sq +# adds to the existing squeeze
              value and .sq -# subtracts from it.

  .sp [#]      space
              Force a line break, then skip # blank lines. The
              default value for # is 1.

  .ti [#]      temporary indent
              Force a line break, then override the running indent
              value with # for only the next printed line. Subsequent
              printed lines will obey the running indent value. A
              plus or minus sign with # causes it to be added to or
              subtracted from the running indent value to obtain the
              temporary indent value. The default value for # is 0;
              that is, the command is ignored.

  .ul [#]      underline
              Underline the following # lines of input text; spaces
              between words are not underlined. If # is 0,
              underlining is terminated. The default value for # is 1.

  .. [text]   comment
              Two successive command characters identify a comment
              line that is to be ignored by FORMAT. You can
              temporarily deactivate a command by placing an extra
              command character before it.<p>
</pre>
Messages:<p>
<pre>
  <b>message                              explanation</b>

  ready printer...          The operator should make sure paper is in the
                            printer and it is ready to accept data from the
                            computer, then press return or enter.

  set page #                The operator should load the next page into the
                            printer, make it ready, then press Return or Enter.
                            (Control-N will skip to the next page.)

  copy # ready printer      Prepare the printer for copy number #. (Control-N
                            will skip to the next copy.)

  page #                    Informs the operator which page is being printed, so
                            a restart on the last page printed will be possible.

  enter: &lt;description&gt;      The operator should enter data, as described, from
                            the keyboard then terminate input with a line
                            containing only a period in position 1.

  note: &lt;line&gt;              The displayed line is either an operator note, an
                            unrecognizable formatting command, or a text line
                            that inadvertently begins with a period (or other
                            command flag).

  error: &lt;line&gt;             The displayed line contains a formatting command
                            with a numeric argument that cannot be evaluated.<p>
</pre>
<b>LIST<p></b>
<pre>
               LIST [file] [-C#] [-PL#] [-PW#] [-NB] [-NN] [-NP]
<p>
</pre>
Description:<p>

LIST (<a href="#list13-11">Listing 13-11</a>) copies an input 
file to the standard output file. If a file is named in the
command line, it is taken for input; otherwise, the standard 
input file is
assumed. It optionally numbers lines, arranges the output in 
multiple columns per
output page, and pauses between pages. The primary intent of LIST 
is for listing
text files on the console screen; however, you may use it 
directly or in
combination with FORMAT or PRINT to produce line-numbered and/or 
multicolumn
listings on the printer.<p>

The -C# switch tells LIST how many columns are to be placed on 
each
output page. The default column count is one.<p>

LIST divides the page width by # to determine the width of each 
column.
If a line of input is too long to fit in a column's width, it 
wraps around to the
next line in the same column. Normally, all lines will be shorter 
than the
column width; if a line is exactly the width of a column, 
however, a column
overflow occurs before the end of the line is detected. This 
results in a blank line in
the column. You may strip out blank lines by specifying the -NB 
switch,
meaning no blanks.<p>

The -PL# switch tells LIST the page length in lines. This is not 
the physical
size of a page, but the number of lines LIST will place on a 
page. The default
page length depends on whether or not the output is redirected to 
a disk file. If
it is, then the length is computed as PTRHIGH-PTRSKIP-PTRHDR (the 
same as
PRINT uses); otherwise, CRTHIGH-1 lines (one less than the length 
of the video
screen) is assumed. These symbols are defined in TOOLS.H and can 
be changed
to suit your requirements.<p>

The -PW# switch tells LIST the page width in character positions. 
The
default value for page width is also determined by whether or not 
the output is
redirected to a disk file. If it is, then PTRWIDE-1 is assumed; 
otherwise,
CRTWIDE-1 is assumed. These symbols are defined in TOOLS.H and 
can be
changed to suit your requirements.<p>

Unless LIST is told otherwise, it numbers input lines. The switch 
-NN,
meaning &quot;no numbers,&quot; negates line numbering. Line 
numbers reside right
justified and blank-filled in a four-character field in the 
beginning of each
column. If line numbering is suppressed, the full column width is 
used for
text.<p>

Unless told otherwise, LIST pauses between pages and awaits your 
response
before proceeding. This is intended to give you time to study the 
contents of the
screen before it is scrolled away. If output is to a printer, it 
allows you to load
cut sheets individually into the printer. To make LIST continue 
printing
nonstop, specify the -NP switch, meaning &quot;no pauses.&quot; 
In this case, LIST continues
automatically from one page to the next without giving any blank 
lines between
pages. The output is still organized into (possibly) multicolumn 
pages, but there
is no break between the pages. When the output is redirected to a 
disk file, there
are never pauses between pages. It is not necessary, in that 
case, to specify the
-NP switch.<p>

The last line of a page is at the bottom of the right-most 
column, and the
first line of the next page is at the top of the left-most 
column.<p>

If you desire page breaks before printing, then send the output 
to a
temporary disk file and use that as input to PRINT. The default 
page length matches
the PRINT program, so page breaks will fall in exactly the right 
places.<p>

LIST is especially useful when listing short lines of text such 
as the
one-word lines typically found in a dictionary file. It saves a 
great deal of paper and
makes viewing on the console screen much easier, too.<p>

Examples:<p>
<pre>
  <b>command                              comment</b>

  LIST &lt;ABC -C3          List on the console the contents of the file ABC in a
                         3-column format with line numbering and pausing
                         with each screenful.

  LIST &lt;ABC &gt;DEF -C8 -   Copy file ABC into DEF, counting lines and placing
  PW132 -NP              them into an 8-column format on pages 132
                         columns wide. PRINT may then be used to print
                         DEF with page breaks and page headers.<p>

</pre>
Messages:
<pre>
  <b>message                              explanation</b>

  waiting...             LIST is waiting until the operator responds with
                         Return or Enter before proceeding to list the next
                         page.<p>
</pre>
<b>MERGE<p></b>
<pre>
            MERGE file [file] [-1|-2|-3|-F]<p>
</pre>
Description:<p>

MERGE (<a href="#list13-12">Listing 13-12</a>) takes two sorted 
text files, merges them, and outputs the result.<p>

The input files must be sorted in ascending sequence on the 
entire line.
Comparisons are made on a lexicographical basis; that is, 
uppercase and
lowercase letters have equal value, and special characters 
compare lower than
alphabetics.<p>

Output may consist of the contents of both files, lines unique to 
the first
file, or lines unique to the second file.<p>

The first file named in the command file is known as the first 
file. The next
file listed is the second file. If a second file is not listed, 
then the standard input
file is assumed in its place. Of course, the standard input may 
be redirected to
come from a disk file; in that case, the redirection 
specification (second file)
may appear anywhere in the command line--even before the first 
file.<p>

Unless specified otherwise, MERGE outputs the entire merged 
contents of
the two input files. Matching lines in the two files will not be 
duplicated in the
output, however.<p>

If you specify the -1 switch, then the lines in the first file 
that do not match
the second file are output; no lines from the second file 
survive.<p>

If you specify the -2 switch, then the lines in the second file 
that do not
match the first file are output; no lines from the first file 
survive.<p>

If you specify the -3 switch, then lines common to both files are 
output. If
multiple occurrences of identical lines exist in both files, then 
as many
occurrences of the line will be output as exist in the file that 
has the least number of
such lines.<p>

The -F switch calls for a formatted output of all lines. The 
format places
lines unique to the first file at the left-most margin. Lines 
unique to the second
file are indented two places. Finally, lines common to both files 
are indented
another two places. Prefixes of 1), 2), and 3) are attached to 
each of these
columns of output to clearly identify the type of line, since it 
is possible for lines of
only one type to be output.<p>

Examples:<p>
<pre>
  <b>command                              comment</b>

  MERGE ABC DEF -1        Merge files ABC and DEF, showing on the console
                          only those lines in ABC not found in DEF.

  MERGE ABC DEF -F        Merge files ABC and DEF, placing a formatted listing
  &gt;LST:                   of all lines on logical device LST:.

  MERGE ABC DEF &gt;GHI      Merge files ABC and DEF, placing the combined
                          contents of both into the file GHI.<p>
</pre>
Messages: none<p>

<b>PRINT<p></b>
<pre>
       PRINT [file]... [.?] [-NN] [-NH|-NS] [-LM#] [-BP#] [-EP#]
                      [-P] [-NR]<p>
</pre>
Description:<p>

PRINT (<a href="#list13-13">Listing 13-13</a>) copies one or more 
text files to the standard output file. If standard
output is not redirected away from the console, it is closed and 
reopened on device
LST:. So LST: is the default output for PRINT. It normally 
numbers the lines,
breaks the output into pages of 56 lines each, and puts a heading 
at the top of
each page showing the filename and page number. Default input is 
from the
standard input file, which, as usual, may be redirected. If a 
list of filenames is
given in the command line, they are printed in the order listed 
with a page
break between each file. In this case, the standard input file is 
not used.<p>

If so directed, PRINT will also copy included text. Inclusion 
statements for
the C language (# include file) and for the Small-Tools text 
formatter (.so file)
will be followed by the contents of the named file. In this case 
line numbering
restarts at 1 for each included file, but continues uninterrupted 
for the primary
file. Include statements may be nested to any desired 
level--limited only by
available memory.<p>

The parameters you may specify with PRINT are:<p>
<pre>
   [file]...  Print the named files instead of standard input.

   .[?]       Print included files with an extension of ? where ?, if
              present, is a string of 1 to 3 characters. If ? is
              null, all included files are printed.

   -NN        No Line numbering.

   -NH        No page headings.

   -NS        No page skips (and no headings).

   -LM#       Left margin of # spaces. The default margin is 0 spaces.

   -BP#       Begin printing on page #.

   -EP#       End printing on page #.

   -P         Pause at the end of each page. The default mode is
              continuous printing.

   -NR        No &quot;ready printer...&quot; prompt.<p>
</pre>

Examples:<p>
<pre>
  <b>command                              comment</b>

  PRINT ABC DEF &gt;PUN:    Print files ABC and DEF on logical device PUN:
                         placing a header on each page and giving a page
                         break between files.

  PRINT SORT.C .C        Print SORT.C together with any .C files it includes.
                         Output goes to LST:.<p>
</pre>
Messages:<p>

  <b>message                               explanation</b>

  ready printer...         PRINT is waiting for you to load paper into the
                           printer and make it ready to accept data from the
                           computer.

  page #                   Tells which page is currently printing so that a
                           restart will be possible.<p>
</pre>
<b>SORT<p></b>
<pre>
         SORT [-C#|-F#?] [-D] [-U] [-Tx] [-Q]<p>
</pre>
Description:<p>

SORT (<a href="#list13-14">Listing 13-14</a>) reads the standard 
input file, sorts it line-by-line, and writes the sorted
data to the standard output file. It works only with standard 
text files; binary
data may not be sorted. Files of any size are accepted.<p>

If no sort key is specified, the entire line is taken for the 
sort key; that is,
the comparing process starts with the first character of the two 
lines being
compared and proceeds from left to right, comparing corresponding 
characters until
a difference is detected. The line whose mismatched character is 
lower
lexicographically is output first for ascending sorts, and last 
for descending sorts.<p>

Uppercase letters are considered equal to their lowercase 
counterparts.
Special characters have the same relative position with respect 
to each other as they
have in the ASCII colating sequence, but they all precede the 
alphabetics; the
ASCII DEL character (value 127 decimal) compares higher than any 
other
character, however.<p>

If one line is longer than the other and no difference is found 
by the time
the end of the shorter line is reached, then the shorter line is 
considered &quot;less
than&quot; the longer line.<p>

The default sort sequence is ascending. However, if the 
descending switch
-D appears in the command line, the sequence is reversed.<p>

If only part of a line is to used for comparison purposes, one of 
two
switches may be used to indicate where the sort key is to be 
found. The column
switch -C# informs SORT that the sort key begins in column # and 
continues
to the end of the line. If # is larger than the number of 
characters in a line,
then the sort key is considered to be null and such lines sort 
first in the
ascending sequence.<p>

The field switch -F#? tells SORT that the #th field in a line is 
to be used
for the sort key. A field may have varying lengths in different 
lines and may
start in different columns in different lines. Fields are defined 
by the presence of
delimiter characters. SORT knows what the delimiter character is 
by looking at
the first character in the switch following the field number. The 
first field is
everything in a line up to, but not including, the first 
delimiter. The second
field is everything between the first and second delimiters. The 
end of the line is
an implied delimiter for the last field.<p>

When two lines are being compared, the sort key fields will 
generally occur
in different positions and have different lengths. The method of 
comparison is
the same as for whole lines. If one field is shorter than the 
other and the two
fields match up to the delimiter of the shorter field, then the 
shorter field is
considered lower in the sorting sequence. If two delimiter 
characters appear
back-to-back, then they delimit the null field between; that is, 
the zero-length
field between counts as a field. If it is used as a sort key, it 
will be considered
&quot;less than&quot; any field of nonzero length.<p>

A special &quot;white space&quot; delimiter is assumed in cases 
where the delimiter
character is not given in the switch; that is, ? is omitted. The 
white space
delimiter consists of all nonprinting characters falling between 
fields of printable
characters. Think of it as a &quot;fat&quot; delimiter. The white 
space delimiter, in a text
file, separates words. Thus the switch -F5 tells SORT to use the 
fifth word of
each line of a file as its sort key.<p>

Since the output of SORT brings together identical lines (when no 
sort key
is specified), SORT is a natural place to weed out unwanted 
duplicate lines. The
unique switch -U instructs SORT to do just that. When this switch 
is specified,
only unique lines are output. The matching process for uniqueness 
always
considers the entire line, even though a sort key may have 
specified.<p>

Since files larger than memory may be sorted, it is often 
necessary for SORT
to use temporary work files on disk to hold parts of the input 
file that have been
sorted while it proceeds to sort the remainder of its input. To 
meet this
requirement, SORT automatically creates as many temporary files 
as it needs. When it
reaches the end of the input, it merges the temporary files to 
write the final
output. The temporary files are then deleted. The names of the 
work files are
SORT01.$$$, SORT02.$$$, SORT03.$$$, and so on. If you interrupt a 
sort
operation, these files may be left on disk; you should delete 
them when you find
them.<p>

Unless specified otherwise, temporary files are created on the 
default drive.
The temporary switch -Tx (where x stands for a drive designator 
A-G) specifies
a particular drive for temporary files.<p>

SORT normally uses the Shell Sort algorithm for arranging lines 
in memory.
A second algorithm, the Quick Sort, is also available. The quick 
switch -Q
invokes the Quick Sort algorithm. The advantage of Quick Sort is 
faster sorting,
but it does have some drawbacks. When the input is already in 
sequence, Quick
Sort becomes much slower than the Shell Sort algorithm, and uses 
up more
memory, sometimes causing a memory allocation error. When this 
happens, the
console displays &quot;M&quot; and the run aborts.<p>

Since most of the time in a sort run is spent in the input and 
output phases,
the improved speed of the Quick Sort algorithm is no great 
advantage; however,
it has been kept as an option for the future when it might be 
used on systems
with large amounts of memory and/or fast hard disks.<p>

Examples:<p>
<pre>
  <b>command                                 comment
</b>
  SORT &lt;ABC &gt;DEF -F5|      Sort file ABC on the 5th field separated by the
                           character |, placing the output into the file DEF.

  SORT &lt;ABC -U             Sort the file ABC on whole lines, displaying only
                           unique lines on the console.<p>
</pre>
Messages:<p>
<pre>
  <b>message                                explanation</b>

  file too large           The input file is too large to sort since it would
                           require more than 99 temporary files (no problem
                           with floppy disks).<p>
</pre>
<b>TRANS<p></b>
<pre>
                TRANS [~]from [to]<p>
</pre>
Description:<p>

TRANS (<a href="#list13-15">Listing 13-15</a>) copies the 
standard input file to the standard output, transliterating
selected characters to new values. The from parameter is a list 
of the characters
to be changed. No spaces may appear between the characters in the 
list. The
parameter to is a list of the new values to be assumed by the 
characters
designated in the from list. Occurrences of the first from 
character are changed to the
first to character. Occurrences of the second from character are 
changed to the
second to character, and so on.<p>

Thus, the command &quot;TRANS &lt;FILE1 &gt;FILE2 abc ABC&quot; 
would copy FILE1
to FILE2, capitalizing the lowercase letters a, b, and c.<p>

Note: Patches to the CCP and the SUBMIT utility are required to 
make
them accept lowercase letters. They are documented on the 
distribution
diskette.<p>

To make it easier to specify all or part of the alphabet in a 
from or to list,
just the first and last letter in a list of letters may be given 
and connected by a
hyphen. This abbreviated notation represents all of the letters 
between. Thus,
the command &quot;TRANS &lt;FILE1 &gt;FILE2 a-z A-Z&quot; would 
copy FILE1 to FILE2,
transliterating all lowercase letters to uppercase. And the 
command &quot;TRANS
a-zA-Z A-Za-z &lt;FILE1 &gt;FILE2&quot; would change all 
lowercase letters to uppercase
and vice versa as it copies from FILE1 to FILE2. The command 
&quot;TRANS &lt;FILE1
a-c d-f &gt;FILE2&quot; would change a to d, b to e, and c to f 
as it copies FILE1 to FILE2.<p>

Escape sequences may be used freely in the from and to lists. 
Since both of
these lists would be terminated a space or tab character, these 
values must be
specified in the lists as :s and :t, respectively. A colon must 
be given as two
consecutive colons.<p>

If the to list is longer than the from list, the unmatched 
characters at the
end of the to list are ignored.<p>

On the other hand, if the to list is shorter than the from list, 
TRANS
operates in collapse mode. The to list is automatically extended 
to the length of the
from list by repeating the last character of the to list. Then 
TRANS collapses all
consecutive occurrences of that character in the output to a 
single occurrence.
Suppose, for instance, you wanted to place every word in a 
document on a line
by itself. The command &quot;TRANS &lt;DOC1 &gt;DOC2 :s:t 
:n&quot; would do the job.
Spaces and tabs would both be changed to new-line characters, 
then consecutive
runs of new lines would be collapsed to single occurrences of the 
new-line
character. This prevents having blank lines in the output.<p>

To repeat, TRANS collapses occurrences of the last character of 
the to list
when the to list is shorter than the from list. Since this may be 
true while the to
list contains more than one character, it is possible to 
translate some characters
while translating and collapsing others.<p>

In the special case where the to list is omitted altogether, 
characters
matching the from list are deleted in the output.<p>

Sometimes you may want to delete or collapse all but a selected 
set of
characters. The tilde character (~), meaning not, may be prefixed 
to the from list to
achieve this effect. The from list then becomes all but the 
characters listed.<p>

Since an isolated hyphen following the program name in the 
command line is
taken for a null switch (meaning that the usage message is to be 
displayed), to
eliminate hyphens from a file, you must escape the hyphen in the 
command line.<p>

Examples:<p>
<pre>
  <b>command                             comment</b>

  TRANS &lt;ABC &gt;DEF         Copy file ABC to DEF, collapsing all nonalphabetic
  ~[a-z][A-Z] :n          characters into newline characters (that is,
                          eliminating everything but words and placing them
                          one to a line).

  TRANS &lt;ABC ~:[:]{}()    Display on the console only the brackets, braces,
                          and parentheses in the file ABC.<p>
</pre>
Messages:<p>
<pre>
  <b>message                             explanation</b>

  from-list too large     The internal expanded form of the from list is too
                          large to fit into its reserved memory- space.

  to-list too large       The internal expanded form of the to list is too
                          large to fit into its reserved memory space.<p>
</pre>
<b>Installation<p>
</b>

All the programs include the files STDIO.H and TOOLS.H at compile 
time.
STDIO.H is supplied with the Small-C compiler and should be used 
without
change by every Small-C program. TOOLS.H, however, is common only 
to
the Small-Tools programs and may be changed to suit your 
particular
requirements. It defines (1) the maximum length of a text line, 
(2) the
character sequence that clears your CRT screen, (3) the sizes of 
your CRT screen
and printer page, and (4) which characters serve as 
metacharacters. Make
any needed changes to this file before starting to compile the 
programs.
Your keyboard layout and the type of word processing you do will 
greatly
affect the ease of use of the metacharacters. Give a lot of 
thought before
changing them, and annotate the documentation according to your 
changes.<p>

The source code for each program is in a file bearing the name of 
the
program and having a .C extension. EDIT is broken into two parts: 
EDIT.C and
EDIT2.C (which is included into EDIT.C at compile time). FORMAT 
is broken
into three parts: FORMAT.C, FORMAT2.C, and FORMAT3.C. The latter 
two
are included into FORMAT.C at compile time. The remaining .C 
files are
common functions that are included in the programs. All the 
include statements in
the programs assume that the included files are on the default 
drive. If you
operate differently, then change the include statements in the 
programs before
starting to compile them.<p>

FONT is written for use with the Epson FX-80 printer. You should 
study its
source code and modify it to work with your own printer.<p>

Several of the programs take command-line arguments that are text
patterns. Unfortunately, the standard CP/M command processor 
(CCP) forces the
entire command line to uppercase, thus defeating your attempts to 
specify
lowercase letters. Furthermore, SUBMIT.COM does the same thing. 
These
deficiencies are easily corrected, however, with the following 
patches.<p>

CCP patch to allow lowercase letters: using SYSGEN and DDT, get a 
copy
of CP/M in memory and look for:
<pre>
     0130  CP    61
     0132  RC
     0133  CPI   7B
     0135  RNC
     0136  ANI   5F    &lt;---
     0138  RET<p>
</pre>
The indicated instruction should be at offset 136H within the 
CCP. Change the
5F at 137H to FF and rewrite CP/M back onto the system tracks.<p>

SUBMIT.COM patch to allow lowercase letters: execute DDT on
SUBMIT.COM. Look for the code:<p>
<pre>
     0362  LDA   0675
     0365  SUI   61
     0367  CPI   1A
     0369  JNC   0374
     036C  LDA   0675
     036F  ANI   5F    &lt;---
     0371  STA   0675
     0374  LDA   0675
     0377  RET<p>
</pre>
Change the 5F to FF, exit DDT and &quot;SAVE 5 SUBMIT.COM&quot;.
<p>

These patches will permit you to fully utilize the features of 
the
Small-Tools programs; however, you can also create filenames with 
lowercase names.
Small-C programs always force filenames to uppercase, but PIP 
expects the CCP
to do this. Sometimes PIP has trouble with lowercase filenames. 
For that reason,
and because drive indicators and built-in commands must be 
uppercase, it is
best to lock your terminal in uppercase except when entering a 
text pattern or
working with the text editor. Switches passed to the Small-Tools 
programs may
be uppercase or lowercase.<p>
<center>
<b>Table 13-4. Reference List of Editing Commands<p></b>
</center>
<pre>
  [.+1]               null command (implied print)
    [.]a              append &lt;text&gt; after line       &lt;text&gt;
       .
  [.,.]c              change line(s) to &lt;text&gt;       &lt;text&gt;
       .
  [.,.]d              delete line(s)
       e [file]       enter named or default file into buffer
       f [file]       display or set default file name
    [.]i              insert &lt;text&gt; before line
       &lt;text&gt;
       .
[.,.+1]j              join lines into one line
       l              display current line number
  [.,.] m#            move line(s) to follow line #
  [.,.]p[#]           print line(s) and set context to # lines
    [.]r [file]       read named/default file into buffer after
                      line

  [.,.]s/pat/rep/[g]  substitute rep for 1st or all pat in line(s)

       q              quit editing
       v              turn automatic viewing off or on
  [1,l]w [file]       write line(s) into named or default file
  [.,l]z              zip through buffer until any key pressed

Command Prefixes

[1,|]g/pat/           global search of lines containing pattern
[1,|]x/pat/           global search of lines not containing 
pattern<p>
</pre>

<center>
<b>Table 13-5. Reference List of Formatting Commands<p></b>
</center>
<pre>
.bc ?        blank character (pseudo-blank)
.bf [1]      boldface
.bp [#+1]    begin page
.br          break
.ce [1]      center
.cc ?        command character
.cu [1]      continuous underline
.dw [1]      double wide characters
.ef [text]   even-page footer
.eh [text]   even-page header
.fi          fill
.fo [text]   footer
.he [text]   header
.in [0]      indent
.it [1]      italicize
.ju          justify right margin
.lm [11]     left margin
.ls [1]      line spacing
.m1 [1]      margin 1 (header in last line)
.m2 [2]      margin 2 (between m1 and body)
.m3 [2]      margin 3 (between body and m4)
.m4 [9]      margin 4 (footer in first line)
.mc ?        merge character (merge-file field
             delimiter)
.mp [2]      minimum paragraph space
.ne [0]      need space on one page
.nf          no filling
.nj          no justifying
.nu          no underline
.of [text]   odd-page footer
.oh [text]   odd-page header
.pl [66]     page length
.po [0]      page offset
.pr [text]   prompt
.rm [74]     right margin
.rs [0]      reserve space
.so file     source file for text
.sp [1]      space
.sq [0]      squeeze
.ti [0]      temporary indent
.ul [1]      underline (discontinuous)<p>
</pre>


<b><a name="list13-1">LISTING 13-1</a><p></b>
<pre>
  /*
  ** change.c -- change occurrences of &quot;from&quot; to &quot;to&quot;
  **
  ** Copyright 1982 J. E. Hendrix. All rights reserved.
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  #define MAXARG 49
  #define MAXLIN1 (MAXLINE+1)
  char lin[MAXLIN1], new[MAXLIN1], pat[MAXPAT], sub[MAXPAT];
  char arg[MAXARG];
  int i, k, lastn, n;
  main(argc, argv) int argc, *argv; {
    if((getarg(1, arg, MAXARG, argc, argv)==EOF)
      |((arg[O]=='-')&amp;(arg[1]==O)))
      error(&quot;usage: CHANGE pattern [replacement]\n&quot;);
    if(makpat(arg, O, NULL, pat)==ERR)
      error(&quot;pattern too long\n&quot;);
    if(getarg(2, arg, MAXARG, argc, argv)==EOF)
      arg[0]=NULL;
    if(maksub(arg, 0, NULL, sub)==ERR)
      error(&quot;replacement too long\n&quot;);
    auxbuf(stdin, 4096); /** alloc aux buffer to stdin **/
    while(fgets(lin, MAXLIN1, stdin)!=NULL) {
      poll(YES);
      lastn = -1;
      i=0; k=0;
      trim(lin);
      while(YES) {
        n=amatch(lin, i, pat);
        if((n&gt;=0)&amp;(lastn!=n)) {   /** replace matched text **/
          catsub(lin, i, n, sub, new, &amp;k, MAXLIN1);
          lastn=n;
          }
        if(lin[i]==NULL) break;
        if((n==-l)|(n==i)) {      /** no match or null match **/
          addset(lin[i], new, &amp;k, MAXLIN1);
          ++i;
          }
        else i=n;                 /** skip matched text **/
        }
      if(addset(NULL, new, &amp;k, MAXLIN1)==NO) {
        k=MAXLIN1-1;
        addset(NULL, new, &amp;k, MAXLIN1);
        sout(&quot;\7line truncated: &quot;, stderr);
        lout(new, stderr);
        }
      lout(new, stdout);
      }
    fclose(stdout);
    }

  #include &quot;pat.c&quot;
  #include &quot;maksub.c&quot;
  #include &quot;catsub.c&quot;
  #include &quot;index.c&quot;
  #include &quot;error.c&quot;
  #include &quot;out.c&quot;
  #include &quot;trim.c&quot;<p>
</pre>
<b><a name="list13-2">LISTING 13-2</a><p></b>
<pre>
  /*
  ** copy.c -- copy named files to standard output
  **
  ** Copyright 1982 J. E. Hendrix. All rights reserved.
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  #define MAXARG 12
  int fin, i, j;
  int status;
  int binary, striplf, stripcr, from, to;
  char name[MAXFN], inclext[MAXFN];
  main(argc, argv) int argc, *argv; {
    auxbuf(stdout, 4096);
    doargs(argc, argv);
    if((binary==YES)&amp;(inclext[0])!=NULL)) {
      fputs(&quot;cannot include files during binary copy&quot;, stderr);
      abort(7);
      }
    fin=99;
    i=0;
    while(getarg(++i, name, MAXFN, argc, argv)!=EOF) {
      if((name[0]=='-')|(name[0]==EXTMARK)) continue;
      if((fin=fopen(name, &quot;r&quot;))==NULL) cant(name);
      if(binary) bcopy(fin, stdout);
      else       fcopy(fin, stdout);     fclose(fin);
      }
    if(fin==99) {
      if(binary) bcopy(stdin, stdout);
      else       fcopy(stdin, stdout);
      }
    fclose(stdout);
    }

  doargs(argc, argv) int argc, *argv; {
    int len;
    char arg[MAXARG], error;
    inclext[0]=from=to=NULL;
    binary=striplf=stripcr=error=NO;
    i=0;
    while(getarg(++i, arg, MAXARG, argc, argv)!=EOF) {
      if(arg[0]==EXTMARK) {
        j=0;
        while(inclext[j]=arg[j]) ++j;
        continue;
        }
      if(arg[0]!='-') continue;
      if(arg[2]==NULL) {
        if(same(arg[1], 'b')) binary=YES;
        else error=YES;
        }
      else if(arg[4]==NULL) {
        if(same(arg[1], 'n')) {
          if(same(arg[2], 'c') &amp; same(arg[3], 'r'))
            stripcr=binary=YES;
          else if(same(arg[2], 'l') &amp; same(arg[3], 'f'))
            striplf=binary=YES;
          else error=YES;
          }
        else error=YES;
        }
      else if(same(arg[1], 't')) {
        binary=YES;
        len=utoi(arg+2, &amp;from);
        if((len&lt;1)|(arg[len+2]!=',')) error=YES;
        else {
          j=len+3;
          len=utoi(arg+j, &amp;to);
          if((len&lt;1)|(arg[len+j]!=NULL)) error=YES;
          }
        }
      else error=YES;
      if(error) {
        fputs(&quot;usage: COPY [file]... [.?] [-B] [-NCR] [-NLF] [-T#,#]\n&quot;, stderr);
        abort(7);
        }
      }
    }

  bcopy(in, out) int in, out; {
    char c[1];
    while(YES) {
      status=read(in, c, 1);
      if(status==0) break;
      if(isatty(in)&amp;(c[O]==4)) break;
      if(status &lt; 1) {
        fputs(&quot;input error\n&quot;, stderr);
        fclose(out);
        abort(7);
        }
      if((c[0]==CR)&amp;(stripcr)) continue;
      if((c[0]==LF)&amp;(striplf)) continue;
      if((from!=to)&amp;((c[0]&amp;255)==from)) c[0]=to;
      status=write(out, c, 1);
      if(status &lt; 1) {
        fputs(&quot;output error\n&quot;, stderr);
        fclose(out);
        abort(7);
        }
      poll(YES);
      }
    }

  fcopy(in, out) int in, out; {
    int i, loc, in2;
    char buf[MAXLINE+1], str[MAXLINE+1];
    while(fgets(buf, MAXLINE+1, in)!=NULL) {
      poll(YES);
      if(inclext[0]==NULL) {
        sout(buf, out);
        continue;
        }
      loc=0;
      getwrd(buf, &amp;loc, str);
      if((lexcmp(str, &quot;#include&quot;)!=0) &amp;&amp;
        (lexcmp(str, &quot;.so&quot;)!=0)) {
        sout(buf, out);
        continue;
        }
      getwrd(buf, &amp;loc, str);
      strip(str);
      i=0;
      while((str[i]!=EXTMARK) &amp;&amp; str[i]) ++i;
      if(inclext[1] &amp;&amp; lexcmp(str+i, inclext)) {
        sout(buf, out);
        continue;
        }
      if((in2=fopen(str, &quot;r&quot;))==NULL) cant(str);
      copy(in2, out);
      fclose(in2);
      }
    }

  #include &quot;out.c&quot;
  #include &quot;cant.c&quot;
  #include &quot;same.c&quot;
  #include &quot;strip.c&quot;
  #include &quot;getwrd.c&quot;<p>
</pre>
<b><a name="list13-3">LISTING 13-3</a><p></b>
<pre>
  /*
  ** count.c -- count characters, words, and/or lines
  **
  ** Copyright 1982 J. E. Hendrix. All rights reserved.
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  char strc[6], strw[6], strl[6];
  main(argc, argv) int argc, *argv; {
    char arg[MAXFN], *nc, *nl, *nw;
    int c, f, i, fd, inword;
    fd=stdin;
    i=f=0;
    while(getarg(++i, arg, MAXFN, argc, argv) != EOF) {
      if(arg[0] != '-') {
        if((fd = fopen(arg, &quot;r&quot;)) == 0) cant(arg);
        continue;
        }
      switch(f = tolower(arg[1])) {
        case 'c': case 'w': case 'l': continue;
        default:
          fputs(&quot;usage: COUNT [file] [-C|-W|-L]\n&quot;, stderr);
          abort(7);
        }
      }
    nc=nl=nw=0;
    inword=NO;
    while((c=fgetc(fd))!=EOF) {
      poll(YES);
      if(c=='\n') {
        ++nl;
        }
      else ++nc;
      if(isspace(c)) inword=NO;
      else if(inword==NO) {
        inword=YES;
        ++nw;
        }
      }
    itou(nc, strc, 6);
    itou(nw, strw, 6);
    itou(nl, strl, 6);
    switch(f) {
      case 'c': lout(strc, stdout); break;
      case 'w': lout(strw, stdout); break;
      case 'l': lout(strl, stdout); break;
      default:
        sout(strc, stdout); lout(&quot; characters&quot;, stdout);
        sout(strw, stdout); lout(&quot; words&quot;, stdout);
        sout(strl, stdout); lout(&quot; lines&quot;, stdout);
      }
    fclose(stdout);
    }
  #include &quot;cant.c&quot;
  #include &quot;out.c&quot;<p>
</pre>
<b><a name="list13-4">LISTING 13-4</a><p></b>
<pre>
  /*
  ** crypt.c -- encrypt or decrypt ASCII or binary files
  **
  ** Copyright 1982 J. E. Hendrix. All rights reserved.
  */
  #include &lt;stdio.h&gt;
  #define NOCCARGC
  #define MAXKEY 81
  #define CTLZ 26
  main(argc, argv) int argc, *argv; {
    char c, key[MAXKEY];
    int i, keylen;
    auxbuf(stdin, 4096);
    keylen=getarg(1, key, MAXKEY, argc, argv);
    if((keylen==EOF)|(key[0]=='-')) {
      fputs(&quot;usage: CRYPT key\n&quot;, stderr);
      abort(7);
      }
    i=1;
    while(read(stdin, &amp;c, 1) &gt; 0) {
      poll(YES);
      if(isatty(stdin) &amp;&amp; (c==CTLZ)) break;
      c=c^key[i-1];
      if(write(stdout, &amp;c, 1) !=1 ) {
        fputs(&quot;output error\n&quot;, stderr);
        abort(7);
        }
      i=(i%keylen)+1;
      }
    }<p>
</pre>
<b><a name="list13-5">LISTING 13-5</a><p></b>
<pre>
  /*
  ** detab.c -- convert tabs to equivalent blanks
  **
  ** Copyright 1982 J. E. Hendrix. All rights reserved.
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  #define MAXLIN1 (MAXLINE+1)
  main(argc,argv) int argc, *argv; {
    char c, tabs[MAXLIN1];
    int col, i;
    auxbuf(stdin, 4096);
    if(settab(tabs, argc, argv)==ERR) {
      fputs(&quot;usage: DETAB [#]... [+#]\n&quot;, stderr);
      abort(7);
      }
    col=1;
    while((c=getchar())!=EOF) {
      poll(YES);
      if(c=='\t')
        while(YES) {
          cout(' ', stdout);
          ++col;
          if(tabpos(col, tabs)==YES) break;
          }
      else if(c=='\n') {
        cout('\n', stdout);
        col=1;
        }
      else {
        cout(c, stdout);
        ++col;
        }
      }
    fclose(stdout);
    }
  #include &quot;settab.c&quot;
  #include &quot;tabpos.c&quot;
  #include &quot;out.c&quot;<p>
</pre>
<b><a name="list13-6">LISTING 13-6</a><p></b>
<pre>
  /*
  ** edit.c -- edit text
  **
  ** Copyright 1982 J. E. Hendrix. All rights reserved.
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  #define OK 1
  #define RESERVE 600
  #define PREV 0
  #define NEXT 2
  #define MARK 4
  #define TEXT 5
  #define INTEGER 2
  #define LONG 4
  #define LINEO 0
  #define NOSTATUS 0
  #define CURLINE '.'
  #define LASTLINE '|'
  #define SCAN '/'
  #define BACKSCAN '\\'
  #define FORWARD 1
  #define BACKWARD 0
  #define PERIOD '.'
  #define COMMA ','
  #define SEMICOL ';'
  #define PLUS '+'
  #define MINUS '-'
  #define BLANK ' '
  #define TAB '\t'
  #define ESC 27
  #define PROMPT '#'
  #define CLFLAG '*'

  #define PRINT 'p'
  #define LINE 'l'
  #define GLOBAL 'g'
  #define EXCLUDE 'x'
  #define APPEND 'a'
  #define CHANGE 'c'
  #define DELETE 'd'
  #define INSERT 'i'
  #define JOIN 'j'
  #define MOVE 'm'
  #define SUBSTITUTE 's'
  #define ENTER 'e'
  #define FILE 'f'
  #define READ 'r'
  #define WRITE 'w'
  #define QUIT 'q'
  #define VIEW 'v'
  #define ZIP 'z'

  int
    line1,    /* first line number */
    line2,    /* second line number */
    nlines,   /* number of line numbers given */
    curln,    /* current line (value of dot) */
    lastln;   /* last line (value of $) */

  char *buf;     /* buffer for pointers and text */
  /*
  ** buf[k+0] PREV      (2 bytes) previous line
  ** buf[k+2] NEXT      (2 bytes) next line
  ** buf[k+4] MARK      (1 byte) mark for global commands
  ** buf[k+5] TEXT
  */
  int lastbf;   /* last element used in buf */
  char *txt,    /* text line for matching and output */
       *savfil, /* remembered file name */
       *file;
  int
    scr,        /* scratch file id */
    scrend[2];  /* end of info on scratch file */
  char *lin, *pat, *sub, updtflag, nbrstr[7];
  int cursav, i, status, maxbuf, context, view;

  main(argc, argv) int argc, *argv; {
    if(isatty(stdin)) view=1; else view=0;
    txt=malloc(MAXLINE);
    lin=malloc(MAXLINE);
    pat=malloc(MAXPAT);
    sub=malloc(MAXPAT);
    file=malloc(MAXFN);
    savfil=malloc(MAXFN);
    maxbuf=avail(YES)-RESERVE;
    if(maxbuf &lt; 0) maxbuf=32767;
    buf=malloc(maxbuf);
    setbuf();
    updtflag=NO;
    pat[0]=savfil[0]=nbrstr[6]=NULL;
    context=7;
    i=0;
    while(getarg(++i, txt, MAXFN, argc, argv)!=EOF) {
      if(txt[0]=='-') {
        if(same(txt[1], 'v')&amp;(txt[2]==NUUL)) view = 1 - view;
        else {
          fputs(&quot;usage: EDIT [file] [-V]\n&quot;, stderr);
          abort(7);
          }
        }
      else scopy(txt, 0, savfil, 0);
      }
    if(*savfil) {
      if(enter(savfil)==ERR) {
        fputs(&quot;error\n&quot;, stderr);
        }
      }
    if(isatty(stdin))
      fputc(PROMPT, stderr);
    while(fgets(lin, MAXLINE, stdin)!=NULL) {
      poll(YES);
      trim(lin);
      i:0;
      cursav:curln;
      if(getlst()==OK) {
        if(ckglob()==OK)
          status=doglob();
        else if(status!= ERR)
          status=docmd(NO);
        /* else error, do nothing */
        }
      if(status==ERR) {
        fputs(&quot;\7error\n&quot;, stderr);
        curln=cursav;
        }
      else if(status==EOF) break;
      /* else OK, then loop */
      if(isatty(stdin)) fputc(PROMPT, stderr);
      }
    }

  /*
  ** docmd -- handle all commands except globals
  */
  docmd(glob) int glob; {
    int gflag, line3, pflag;
    pflag=NO;
    status=ERR;
    switch(tolower(lin[i])) {
      case APPEND:
        if(ckp(lin, i+1, &amp;pflag)==OK)
          status=append(line2, glob);
        break;
      case CHANGE:
        if(ckp(lin, i+1, &amp;pflag)==OK) {
          if(defalt(curln, curln)==OK) {
            if((status=append(line2, glob))!=ERR) {
              kill(line1, line2);
              ++curln;
              }
            }
          }
        break;
      case DELETE:
        if(ckp(lin, i+1, &amp;pflag)==OK) {
          if(defalt(curln, curln)==OK) {
            kill(line1, line2);
            if(curln &lt; lastln) curln=nextln(curln);
            }
          }
        break;
      case INSERT:
        if(ckp(lin, i+1, &amp;pflag)==OK)
          status=append(prevln(line2), glob);
        break;
      case LINE:
        if(lin[i+1]==NULL) {
          itou(curln, nbrstr, 6);
          puts(nbrstr);
          status=OK;
          }
        break;
      case JOIN:
        if(ckp(lin, i+1, &amp;pflag)==OK) {
          if(defalt(curln, curln+1)==OK) {
            if((status=join(line1, line2))==OK) {
              curln=line2;
              if((status=inject(txt))==OK)
                kill(line1, line2);
                ++curln;
              }
            }
          }
        break;
      case MOVE:
        ++i;
        if(getone(&amp;line3)==EOF) status=ERR;
        if(status==OK) {
          if(ckp(lin, i, &amp;pflag)==OK) {
            if(defalt(curln, curln)==OK) status=move(line3);
            }
          }
        break;
      case SUBSTITUTE:
        ++i;
        if(optpat()==OK) {
          if(getrhs(lin, &amp;i, sub, &amp;gflag)==OK) {
            if(ckp(lin, i+1, &amp;pflag)==OK) {
              if(defalt(curln, curln)==OK)
                status=subst(sub, gflag);
              }
            }
          }
        break;
      case ENTER:
        if(chkupdt()==ERR) status=OK;
        else if(nlines==0) {
          if(getfn(lin, i, file, MAXFN)==OK) {
            scopy(file, 0, savfil, 0);
            clrbuf();
            setbuf();
            status=enter(file);
            }
          }
        break;
      case FILE:
        if(nlines==0) {
          if(getfn(lin, i, file, MAXFN)==OK) {
            scopy(file, 0, savfil, 0);
            puts(savfil);
            }
          itou(maxbuf-lastbf, nbrstr, 6);
          puts(nbrstr);
          status=OK;
          }
        break;
      case READ:
        if(getfn(lin, i, file, MAXFN)==OK)
          status=doread(line2, file);
        pflag=view;
        break;
      case WRITE:
        if(getfn(lin, i, file, MAXFN)==OK) {
          if(defalt(1, lastln)==OK)
            status=dowrit(line1, line2, file);
          }
        break;
      case ZIP:
        if(defalt(curln, lastln)==OK)
          status=doprnt(line1, line2, glob);
        break;
      case PRINT:
        if(defalt(curln, curln)==OK)
          status=doprnt(line1, line2, glob);
        break;
      case NULL:
        if((nlines==0)&amp;(glob==NO)) line2=nextln(curln);
        if(view) status=doprnt(line2, line2, glob);
        else {
          curln=line2;
          status=OK;
          }
        break;
      case QUIT:
        if((lin[i+1]==NULL)&amp;(nlines==0)&amp;(glob==NO)) {
          if(chkupdt()==ERR) status=OK;
          else status=EOF;
          }
        break;
      case VIEW:
        view=1-view;
        status=OK;
      }
    /* else status is ERR */
    if(curln &lt; 1) curln = nextln(0);
    if((status==OK)&amp;(pflag==YES))
      status=doprnt(curln, curln, glob);
    return status;
    }

  /*
  ** chkupdt -- warn if update not written to disk
  */
  chkupdt() {
    if(updtflag) {
      fputs(&quot;didn't write to disk!\n&quot;, stderr);
      updtflag=NO;
      return ERR;
      }
    return OK;
    }

  /*
  ** ctoi -- convert string at in[*i] to integer, bump *i
  */
  ctoi(in, i) char in[]; int *i; {
    int dd, num;
    char *digits;
    digits=&quot;0123456789&quot;;
    while((in[*i]==BLANK)|(in[*i]==TAB)) *i = *i + 1;
    num=0;
    while(in[*i]!=NULL) {
      dd=index(digits, in[*i]);
      if(dd &lt; 0) break;
      num = 10*num + dd;
      *i = *i + 1;
      }
    return num;
    }

  /*
  ** skipbl -- skip blanks and tabs
  */
  skipbl(lin, i) char lin[]; int *i; (
    while((lin[*i]==' ')|(lin[*i]=='\t')) *i = *i + 1;
    }

  /*
  ** nextln -- get line after ln
  */
  nextln(ln) int ln; {
    if(++ln &gt; lastln) return 0;
    return ln;
    }

  /*
  ** prevln -- get line before ln
  */
  prevln(ln) int ln; {
    if(--ln &lt; 0) return lastln;
    return ln;
    }

  /*
  ** join -- put line1 thru line2 together into txt
  */
  join(ln1, ln2) int ln1, ln2; {
    int i, j;
    j=0;
    while(ln1 &lt;= ln2) {
      i=getind(ln1++)+TEXT;
      while(txt[j++]=buf[i++])
        if(j &gt;= MAXLINE) return ERR;
      --j;
      }
    return OK;
    }

  /*
  ** doread -- read &quot;file&quot; after &quot;line&quot;
  */
  doread(line, file) int line; char file[]; {
    int fd, stat;
    if((fd=fopen(file, &quot;r&quot;))==NULL) {
      fputs(&quot;open &quot;, stderr);
      return ERR;
      }
    curln=line;
    stat=input(fd);
    fclose(fd);
    return stat;
    }

  /*
  ** getlst -- collect line numbers (if any) at lin[i], bump i
  */
  getlst() {
    int num;
    line2=0;
    nlines=0;
    while(getone(&amp;num)==OK) {
      line1=line2;
      line2=num;
      ++nlines;
      if((lin[i]!=COMMA)&amp;(lin[i]!=SEMICOL)) break;
      if(lin[i]==SEMICOL) curln=num;
      ++i;
      }
    if(nlines&gt;2) nlines=2;
    if(nlines==0) line2=curln;
    if(nlines&lt;=1) line1=line2;
    if(status!=ERR) status=OK;
    return status;
    }

  /*
  ** getone -- evaluate one line number expression
  */
  getone(num) int *num;{
    int istart, mul, pnum;
    skipbl(lin, &amp;i);
    istart=i;
    if((lin[i]==PLUS)|(lin[i]==MINUS)) *num=curln;
    else *num=0;
    if(getnum(num)==OK)
      while(YES) {
        skipbl(lin, &amp;i);
        if((lin[i]!=PLUS)&amp;(lin[i]!=MINUS)) {
          status=EOF;
          break;
          }
        if(lin[i]==PLUS) mul = 1;
        else mul = -1;
        ++i;
        skipbl(lin, &amp;i);
        pnum=1;
        getnum(&amp;pnum);
        *num = *num + mul*pnum;
        if(status==EOF) status=ERR;
        if(status!=OK) break;
        }
    if((*num&lt;0)|(*num&gt;lastln)) return (status=ERR);
    if(i&lt;=istart) return (status=EOF);
    return (status=OK);
    }

  #include &quot;edit2.c&quot;
  #include &quot;same.c&quot;
  #include &quot;pat.c&quot;
  #include &quot;buf.c&quot;
  #include &quot;error.c&quot;
  #include &quot;index.c&quot;
  #include &quot;maksub.c&quot;
  #include &quot;catsub.c&quot;
  #include &quot;scopy.c&quot;
  #include &quot;trim.c&quot;

  /*
  ** edit2.c -- edit part 2
  */

  /*
  ** getnum -- convert one term to a line number
  */
  getnum(pnum) int *pnum; {
    int stat;
    char *digits;
    digits=&quot;0123456789&quot;;
    stat=OK;
    if(index(digits, lin[i]) &gt;= 0) {
      *pnum=ctoi(lin, &amp;i);
      --i; /** backup then bump at end **/
      }
    else if(lin[i]==CURLINE) *pnum=curln;
    else if(lin[i]==LASTLINE) *pnum=lastln;
    else if((lin[i]==SCAN)|(lin[i]==BACKSCAN)) {
      if(optpat()==ERR) stat=ERR;
      else if(lin[i]==SCAN) stat=ptscan(FORWARD, pnum);
      else stat=ptscan(BACKWARD, pnum);
      }
    else if((lin[i]==PLUS)|(lin[i]==MINUS)) --i;
    else stat=EOF;
    if(stat==OK) ++i;
    return (status=stat);
    }

  /*
  ** optpat -- make pattern if specified at lin[i]
  */
  optpat() {
    if(lin[i]==NULL) i = ERR;
    else if(lin[i+1]==NULL) i = ERR;
    else if(lin[i+1]==lin[i]) ++i;
    else i = makpat(lin, i+1, lin[i], pat);
    if(pat[0]==NULL) i = ERR;
    if(i==ERR) {
      pat[0]=NULL;
      return ERR;
      }
    return OK;
    }

  /*
  ** ptscan -- scan for next occurrence of pattern
  */
  ptscan(way, num) int way, *num; {
    *num = curln;
    while(YES) {
      if(poll(YES)==ESC) return (ERR);
      if(way==FORWARD) *num=nextln(*num);
      else *num=prevln(*num);
      if(match(buf+getind(*num)+TEXT, pat)==YES) return OK;
      if(*num==curln) break;
      }
    return ERR;
    }

  /*
  ** ckglob -- if global prefix, mark lines to be affected
  */
  ckglob() {
    int gflag, k, line;
    if((same(lin[i], GLOBAL)==NO)&amp;(same(lin[i], EXCLUDE)==NO))
      return (status=EOF);
    if(same(lin[i], GLOBAL)) gflag=YES;
    else gflag=NO;
    ++i;
    if((optpat()==ERR)|(defalt(1, lastln)==ERR))
      return (status=ERR);
    ++i;
    line=line1;
    while(line&lt;=line2) {
      if(poll(YES)==ESC) return (status=ERR);
      k=gettxt(line++);
      if(match(txt, pat)==gflag) buf[k+MARK]=YES;
      else buf[k+MARK]=NO;
      }
    line=nextln(line2);
    while(line!=line1) {
      if(poll(YES)==ESC) return (status=ERR);
      k=getind(line);
      buf[k+MARK]=NO;
      line=nextln(line);
      }
    return (status=OK);
    }

  /*
  ** defalt -- set defaulted line numbers
  */
  defalt(def1, def2) int def1, def2; {
    if(nlines==0) {
      line1=def1;
      line2=def2;
      }
    if((line1&gt;line2)|(line1&lt;=0)|(line2&gt;lastln))
      return (status=ERR);
    return (status=OK);
    }

  /*
  ** doglob -- do command at lin[i] on all marked lines
  */
  doglob() {
    int count, istart, k, line;
    status=OK;
    count=0;
    line=line1;
    istart=i;
    while(YES) {
      if(poll(YES)==ESC) return (status=ERR);
      k=getind(line);
      if(buf[k+MARK]==YES) {
        buf[k+MARK]=NO;
        cursav=curln=line;
        i=istart;
        if(getlst()==OK) {
          if(docmd(YES)==OK) count=0;
          }
        }
      else {
        line=nextln(line);
        ++count;
        }
      if((count&gt;lastln)|(status!=OK)) break;
      }
    return status;
    }

  /*
  ** append -- append lines after ln
  */
  append(ln, glob) int ln, glob; {
    int stat;
    if(glob==YES) return ERR;
    curln=ln;
    stat=NOSTATUS;
    while(stat==NOSTATUS) {
      fputc(' ', stderr);
      if(fgets(lin, MAXLINE, stdin)==NULL) stat=EOF;
      else {
        trim(lin);
        if((lin[0]==PERIOD)&amp;(lin[1]==NULL)) stat=OK;
        else if(inject(lin)==ERR) stat=ERR;
        }
      }
    return stat;
    }

  /*
  ** kill -- delete lines from through to
  */
  kill(from, to) int from, to; {
    int k1, k2;
    if((from==1)&amp;(to==lastln)) {
      setbuf();
      updtflag=NO;
      return (status=OK);
      }
    if(from&lt;=0) return (status=ERR);
    k2=getind(nextln(to));
    k1=getind(prevln(from));
    /** leaves gotline &amp; gotind below affected area **/
    lastln=lastln-(to-from+1);
    curln=prevln(from);
    relink(k1, k2, k1, k2);
    return (status=OK);
    }

  /*
  ** ckp -- check for &quot;p&quot; after command
  */
  ckp(lin, i, pflag) char lin[]; int i, *pflag; {
    if(same(lin[i], PRINT)) {
      *pflag=YES;
      ++i;
      }
    else *pflag=NO;
    if(view) *pflag=YES;
    if(lin[i]==NULL) status=OK;
    else status=ERR;
    return status;
    }

  /*
  ** move -- move line1 through line2 after line3
  */
  move(line3) int line3; {
    int k0, k1, k2, k3, k4, k5;
    if((line1&lt;=0)|((line1&lt;=line3)&amp;(line3&lt;=line2))) 
return ERR;
    k1=getind(line1);
    k2=getind(line2);
    k3=getind(nextln(line2));
    k0=getind(prevln(line1));
    /** leaves gotline &amp; gotind below affected area **/
    relink(k0, k3, k0, k3);
    if(line3&gt;line1) {
      curln=line3;
      line3=line3-(line2-line1+1);
      }
    else curln=line3+(line2-line1+1);
    k5=getind(nextln(line3));
    k4=getind(line3);
    /** leaves gotline &amp; gotind below affected area **/
    relink(k4, k1, k2, k5);
    relink(k2, k5, k4, k1);
    return OK;
    }

  /*
  ** getrhs -- get substitution string for &quot;s&quot; command
  */
  getrhs(lin, i, sub, gflag) char lin[], sub[]; int *i, *gflag; {
    if(lin[*i]==NULL) return ERR;
    if(lin[*i+1]==NULL) return ERR;
    *i=maksub(lin, *i+1, lin[*i], sub);
    if(*i==ERR) return ERR;
    if(same(lin[*i+1], GLOBAL)) {
      *i = *i + 1;
      *gflag=YES;
      }
    else *gflag=NO;
    return OK;
    }

  /*
  ** subst -- substitute &quot;sub&quot; for occurrences of pattern
  */
  subst(sub, gflag) char sub[]; int gflag; {
    char new[MAXLINE];
    int j, k, lastn, line, n, subbed;
    if(line1&lt;=0) return ERR;
    line=line1;
    while(line&lt;=line2) {
      if(poll(YES)==ESC) return (ERR);
      j=0;
      subbed=NO;
      gettxt(line);
      lastn=-1;
      k=0;
      while(YES) {
        if((gflag==YES)|(subbed==NO)) n=amatch(txt, k, pat);
        else n=-1;
        if((n&gt;=0)&amp;(lastn!)=n)) {   /** replace matched text **/
          subbed=YES;
          catsub(txt, k, n, sub, new, &amp;j, MAXLINE);
          lastn=n;
          }
        if(txt[k]==NULL) break;
        if((n==-1)|(n==k)) {       /** no match or null match **/
          addset(txt[k], new, &amp;j, MAXLINE);
          ++k;
          }
        else k=n;                  /** skip matched text **/
        }
      if(subbed==YES) {
        if(addset(NULL, new, &amp;j, MAXLINE)==NO) return ERR;
        curln=prevln(line);
        if(inject(new)==ERR) {
          curln=line;
          return ERR;
          }
        kill(curln+1, curln+1);
        }
      ++line;
      }
    return OK;
    }

  /*
  ** getfn -- get file name from lin[i]
  */
  getfn(lin, i, file, max) char lin[], file[]; int i, max; {
    int j, k, stat;
    stat=ERR;
    if(lin[i+1]==BLANK) {
      j=i+2; /** get new file name **/
      skipbl(lin, &amp;j);
      k=0;
      while(file[k++]=lin[j++]) if(--max &lt; 1) break;
      if((k &gt; 1)&amp;(max &gt; 0)) stat=OK;
      }
    else if((lin[i+1]==NULL)&amp;(savfil[0]!=NULL)) {
      scopy(savfil, 0, file, 0);
      stat=OK;
      }
    if((stat==OK)&amp;(savfil[0]==NULL))
      scopy(file, 0, savfil, 0); /** save if no old one **/
    return stat;
    }

  /*
  ** dowrit -- write &quot;from&quot; through &quot;to&quot; into file
  */
  dowrit(from, to, file) int from, to; char file[]; {
    char tmp[MAXFN], *ptr;
    int fd, line;

    strcpy(tmp, file);
    if((ptr = strchr(tmp, '.')) == 0) ptr = tmp + strlen(tmp);
    strcpy(ptr, &quot;.$$$&quot;);
    rename(file, tmp);

    if((fd=fopen(file, &quot;w&quot;))==NULL) return ERR;
    line=from;
    while(line&lt;=to) {
      fputs(buf+getind(line++)+TEXT, fd);
      if(fputc('\n', fd)==EOF) {
        fputs(&quot;write &quot;, stderr);
        fclose(fd);
        return ERR;
        }
      }
    if(fclose(fd)) return ERR;
    unlink(tmp);
    updtflag=NO;
    return OK;
    }

  /*
  ** doprnt -- print lines from through to
  */
  doprnt(from, to, glob) int from, to, glob; {
    int j, k;
    char pref;
    if(from&lt;=0) return OK;
    if(same(lin[i], PRINT)) {
      ++i;
      if((lin[i]&gt;='0')&amp;(lin[i]&lt;='9')) {
        if(lin[i+1]==NULL) context=lin[i]-'0';
        else return ERR;
        }
      else if(lin[i]!=NULL) return ERR;
      }
    if((from==to)&amp;(glob==NO)) {
      j=from-context;
      k=to+context;
      }
    else {
      j=from;
      k=to;
      }
    if(j &lt; 1) j=1;
    if(k &gt; lastln) k=lastln;
    if(glob==NO) fputs(CLEAR, stdout);
    while(j &lt;= k) {
      if(poll(YES)) {
        /* underflow handled in docmd() */
        curln = j - context;
        return OK;
        }
      if((j==to)&amp;(glob==NO)) pref=CLFLAG;
      else pref=' ';
      gettxt(j++);
      fputc(pref, stdout);
      fputs(txt, stdout);
      fputc('\n', stdout);
      }
    curln=to;
    return OK;
    }

  /*
  ** enter -- enter a new file
  */
  enter(name) char name[]; {
    int err;
    err=doread(0, name);
    if(view) doprnt(1, 1, NO);
    curln=1;
    updtflag=NO;
    return err;
    }<p>
</pre>
<b><a name="list13-7">LISTING 13-7</a><p></b>
<pre>
  /*
  ** entab.c -- replace blanks with tabs and blanks
  **
  ** Copyright 1982 J. E. Hendrix. All rights reserved.
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  #define MAXLIN1 (MAXLINE+1)
  main(argc, argv) int argc, *argv; {
    char c, tabs[MAXLIN1];
    int col, newcol;
    auxbuf(stdin, 4096);
    if(settab(tabs, argc, argv)==ERR) {
      fputs(&quot;usage: ENTAB [#]... [+#]\n&quot;, stderr);
      abort(7);
      }
    col=1;
    while(YES) {
      poll(YES);
      newcol=col;
      while((c=getchar())==' ') {
        ++newcol;
        if(tabpos(newcol, tabs)==YES) {
          cout('\t', stdout);
          col=newcol;
          }
        }
      if(c=='\t') {
        while(tabpos(newcol, tabs)==NO) ++newcol;
        cout('\t', stdout);
        col=newcol;
        continue;
        }
      while(col&lt;newcol) {
        cout(' ', stdout);
        ++col;
        }
      if(c==EOF) break;
      cout(c, stdout);
      if(c=='\n') col=1;
      else if(c=='\b') --col; /* ok if it goes neg */
      else ++col;
      }
    fclose(stdout);
    }
  #include &quot;settab.c&quot;
  #include &quot;tabpos.c&quot;
  #include &quot;out.c&quot;<p>
</pre>
<b><a name="list13-8">LISTING 13-8</a><p></b>
<pre>
  /*
  ** find.c -- find patterns in text file
  **
  ** Copyright 1982 J. E. Hendrix. All rights reserved.
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  #define MAXARG 49
  #define MAXLIN1 (MAXLINE+1)
  char arg[MAXARG], lin[MAXLIN1], pat[MAXPAT];
  int err, argi;
  main(argc, argv) int argc, *argv; {
    auxbuf(stdin, 4096);
    err=NO;
    if((getarg(1, arg, MAXARG, argc, argv)==EOF)|(arg[0]=='-'))
      error(&quot;usage: FIND [~]pattern\n&quot;);
    if(arg[0]==NOT) argi=1; else argi=0;
    if(getpat(arg+argi, pat)==ERR) error(&quot;pattern too long\n&quot;);
    while(fgets(lin, MAXLIN1, stdin)!=NULL) {
      poll(YES);
      trim(lin);
      if(match(lin, pat)) {
        if(argi==0) lout(lin, stdout);
        }
      else if(argi==1) lout(lin, stdout);
      }
    fclose(stdout);
    }
  getpat(arg, pat) char arg[], pat[]; {
    return(makpat(arg, 0, NULL, pat));
    }

  #include &quot;pat.c&quot;
  #include &quot;error.c&quot;
  #include &quot;index.c&quot;
  #include &quot;out.c&quot;
  #include &quot;trim.c&quot;<p>
</pre>
<b><a name="list13-9">LISTING 13-9</a><p></b>
<pre>
  /*
  ** font.c -- choose FX printer font
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  char
     condensed[]={27, 15, 0},
    xcondensed[]={ 18, 0},
     double[]={27, 'G', 0},
    xdouble[]={27, 'H', 0},
     elite[]={27, 'M', 0},
    xelite[]={27, 'P', 0},
     emphasized[]={27, 'E', 0},
    xemphasized[]={27, 'F', 0},
     enlarged[]={27, 'W', 49, 0},
    xenlarged[]={27, 'W', 48, 0},
     italics[]={27, '4', 0},
    xitalics[]={27, '5', 0},
     pica[]={27, 'P', 0},
    xpica[]={27, 'M', 0},
     subscript[]={27, 'S', 49, 0},
    xsubscript[]={27, 'T', 0},
     superscript[]={27, 'S', 48, 0},
    xsuperscript[]={27, 'T', 0},
     proportional[]={27, 'p', 49, 0},
    xproportional[]={27, 'p', 48, 0};
  char str[15], *ptr=&quot;LST:&quot;;
  int i, fd;
  main(argc, argv) int argc, *argv; {
    if(getarg(1, str, 15, argc, argv) != EOF) ptr = str;
    if(*str == '-') {
      fputs(&quot;usage: FONT [device]&quot;, stderr);
      abort(7);
      }
    if((fd=fopen(ptr, &quot;w&quot;)) == 0) cant(ptr);
    do {
      fputs(CLEAR, stdout);
      fputs(&quot; Select Epson FX Option (RETURN to exit)\n\n&quot;, stdout);
      fputs(&quot;set    clear      mode\n\n&quot;, stdout);
      fputs(&quot; 1       2        condensed \n&quot;, stdout);
      fputs(&quot; 3       4        double strike\n&quot;, stdout);
      fputs(&quot; 5       6        elite\n&quot;, stdout);
      fputs(&quot; 7       8        emphasized \n&quot;, stdout);
      fputs(&quot; 9      10        enlarged\n&quot;, stdout);
      fputs(&quot;11      12        italics\n&quot;, stdout);
      fputs(&quot;13      14        pica\n&quot;, stdout);
      fputs(&quot;15      16        subscript\n&quot;, stdout);
      fputs(&quot;17      18        superscript\n&quot;, stdout);
      fputs(&quot;19      20        proportional\n&quot;, stdout);
      fputs(&quot;\nselect...      &quot;, stdout);
      fgets(str, 10, stdin);
      ptr = str;
      while(*ptr) {
        if(*ptr == '\n') *ptr=NULL;
        ++ptr;
        }
      if(utoi(str, &amp;i)) {
        switch(i) {
          case 1:  {fputs( condensed, fd); break;}
          case 2:  {fputs(xcondensed, fd); break;}
          case 3:  {fputs( double, fd); break;}
          case 4:  {fputs(xdouble, fd); break;}
          case 5:  {fputs( elite, fd); break;}
          case 6:  {fputs(xelite, fd); break;}
          case 7:  {fputs( emphasized, fd); break;}
          case 8:  {fputs(xemphasized, fd); break;}
          case 9:  {fputs( enlarged, fd); break;}
          case 10: {fputs(xenlarged, fd); break;}
          case 11: {fputs( italics, fd); break;}
          case 12: {fputs(xitalics, fd); break;}
          case 13: {fputs( pica, fd); break;}
          case 14: {fputs(xpica, fd); break;}
          case 15: {fputs( subscript, fd); break;}
          case 16: {fputs(xsubscript, fd); break;}
          case 17: {fputs( superscript, fd); break;}
          case 18: {fputs(xsuperscript, fd); break;}
          case 19: {fputs( proportional, fd); break;}
          case 20: {fputs(xproportional, fd); break;}
          }
        }
      } while (*str);
    }
  #include &quot;cant.c&quot;<p>
</pre>
<b><a name="list13-10">LISTING 13-10</a><p></b>
<pre>
  /*
  ** format.c -- text formatter
  **
  ** Copyrignt 1982 J. E. Hendrix. All rights reserved.
  */

  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  #define KILL 14 /* control-N */
  #define INSIZE 396
  #define MAXOUT 579
  #define COMMAND '.'
  #define PAGENUM '#'
  #define TTLDELIM '/'
  #define MRGCHAR '|'
  #define SUBCHAR '/'
  #define SUPCHAR '\\'
  #define BLANK '~'
  #define DEFM1 1
  #define DEFM2 2
  #define DEFM3 2
  #define DEFM4 9
  /**** LM is effectively one greater ****/
  #define DEFLM 9
  #define DEFRM 73
  #define DEFMP 2
  #define PAGELEN 66
  #define HUGE 32000
  #define NDIM 5
  #define NWIDTH 4

  int
    ttymode, /* tty mode if YES */
    itsub,   /* italic subs for underlines */
    ulsub,   /* underline subs for italics */
    pass,    /* pass counter */
    fill,    /* fill if YES */
    just,    /* justify if YES */
    lsval,   /* line spacing */
    inval,   /* indent value */
    lmval,   /* left margin value */
    rmval,   /* right margin value */
    pagekill,/* kill page if YES */
    pospec,  /* page offset specification */
    poval,   /* page offset for current page */
    tival,   /* temporary indent */
    ceval,   /* number of lines to center */
    ulval,   /* number of lines to underline */
    bfval,   /* number of lines to boldface */
    itval,   /* number of lines to italicize */
    dwval,   /* number of lines to double-wide */
    dwact,   /* double-wide is active */
    bfstrikes,  /* number of boldface strikes */
    cuact,   /* continuous underline active if &gt; 0 */
    mpcnt,   /* lines printed since last .mp page break */
    mpval,   /* minimum lines required for paragraphs */
    sqval,   /* squeeze indents */
    bline,   /* blank line flag */
    curpag,  /* current page number */
    newpag,  /* next page number */
    lineno,  /* next line to be printed */
    plval,   /* page length in lines */
    m1val,   /* margin before and including header */
    m2val,   /* margin after header */
    m3val,   /* margin after last text line */
    m4val,   /* bottom margin including footer */
    bottom,  /* last live line on page */
    outp,    /* last character position in outbuf */
    outw,    /* width of text in outbuf */
    outwds,  /* number of words in outbuf */
    pause,   /* pause on page breaks if YES */
    ready,   /* prompt &quot;ready printer...&quot; if YES */
    show,    /* show source file names */
    begin,   /* beginning page to print */
    end,     /* ending page to print */
    bcopy,   /* beginning copy */
    ecopy,   /* ending copy */
    mrgfd,   /* merge file fd */
    sentend, /* YES for plausible end of sentence */
    dir;     /* direction for spreading blanks */

  char
         sbpref[]={27,'S',49,1},  /* nontty subscript prefix */
         sbsuff[]={27,'T', 1,0},  /* nontty subscript suffix */
         sppref[]={27,'S',48,1},  /* nontty superscript prefix */
         spsuff[]={27,'T', 1,0},  /* nontty superscript suffix */
        *ulon, *uloff,
         ulpref[]={27,'-',49,1},  /* nontty underline prefix */
         ulsuff[]={27,'-',48,1},  /* nontty underline suffix */
        *bfon, *bfoff,
         bfpref[]={27,'E',1,0},   /* nontty boldface prefix */
         bfsuff[]={27,'F',1,0},   /* nontty boldface suffix */
        *dson, *dsoff,
         dspref[]={27,'G',1,0},   /* nontty dbl strike prefix */
         dssuff[]={27,'H',1,0},   /* nontty dbl strike suffix */
        *iton, *itoff,
         itpref[]={27,'4',1,0},   /* nontty italics prefix */
         itsuff[]={27,'5',1,0},   /* nontty italics suffix */
        *dwon, *dwoff,
         dwpref[]={27,'W',49,1},  /* nontty dbl wide prefix */
         dwsuff[]={27,'W',48,1};  /* nontty dbl wide suffix */

  char
     cmd,         /* command character */
     mrg,         /* merge field delimiter */
     blank,       /* literal blank character */
    *ulskips,     /* specific characters to skip underlining */
    *oheader,     /* odd page header */
    *eheader,     /* even page header */
    *ofooter,     /* odd page footer */
    *efooter,     /* even page footer */
    *outbuf,      /* output buffer */
    *ttlbuf,      /* buffer for titles */
    *mrgbuf,      /* buffer for merged text */
    *inbuf,       /* input buffer */
    *wrdbuf,      /* space for one word */
    *nbrstr;      /* number string */

  main(argc, argv) int argc, *argv; {
    oheader=malloc((MAXLINE+1));
    eheader=malloc((MAXLINE+1));
    ofooter=malloc((MAXLINE+1));
    efooter=malloc((MAXLINE+1));
    mrgbuf=malloc((MAXLINE+1));
    outbuf=malloc(MAXOUT);
    ttlbuf=malloc(MAXOUT);
    wrdbuf=malloc(MAXOUT);
    inbuf=malloc(INSIZE);
    nbrstr=malloc(NDIM);
    nbrstr[NWIDTH]=NULL;
    doargs(argc, argv);
    mpcnt=99;
    pass=0;
    if(mrgfd) {
      while(fgets(mrgbuf, (MAXLINE+1), mrgfd) &amp;&amp; (pass &lt; ecopy)) {
        if(++pass &lt; bcopy) continue;
        trim(mrgbuf);
        nextpass();
        }
      }
    else if(ecopy == HUGE) nextpass();
    else for(pass = bcopy; pass &lt;= ecopy; ++pass) nextpass();
    fclose(stdout);
    }

  /*
  ** nextpass -- make next pass on stdin text
  */
  nextpass() {
    char c, str[6];
    init();
    if(mrgfd || ecopy != HUGE) {
      cseek(stdin, 0, 0);
      left(itod(pass, str, 6));
      fputs(&quot;copy &quot;, stderr);
      fputs(str, stderr);
      fputs(&quot;   &quot;, stderr);
      }
    c=NULL;
    if(((pass &lt;= bcopy) || (pause==YES)) &amp;&amp;
       ready &amp;&amp; isatty(stdout)) {
      fputs(&quot;ready printer... &quot;, stderr);
      c=fgetc(stderr);
      }
    if(c!=KILL) {
      process(stdin);
      if((lineno &gt; 0)|(outp &gt; -1)) space(HUGE);
      }
    else fputc('\n', stderr);
    }

  /*
  ** process -- process text from fd
  */
  process(fd) int fd; {
    while(fgets(inbuf, INSIZE, fd)!=NULL) {
      poll(YES);
      trim(inbuf);
      if((fd==stderr)&amp;(inbuf[0]==cmd)&amp;(inbuf[1]==NULL))
        return;
      if(inbuf[0]==cmd) command(inbuf);
      else {
        if(merge()==NO) continue;
        text(inbuf);
        }
      }
    }

  /*
  ** include -- process included text (nexting allowed)
  */
  include() {
    int i, fd;
    char fname[INSIZE];
    i=0;
    while((inbuf[i]!=' ')&amp;(inbuf[i]!=NULL)) ++i;
    getwrd(inbuf, &amp;i, fname);
    if((fd=fopen(fname, &quot;r&quot;))==NULL) cant(fname);
    lout(fname, stderr);
    if(show) {
      brk();
      put(fname);
      brk();
     }
    process(fd);
    fclose(fd);
    }

  /*
  ** prompt -- prompt operator for input
  */
  prompt() {
    fputs(&quot;\7enter: &quot;, stderr);
    fputs(inbuf+3, stderr);
    fputc('\n', stderr);
    process(stderr);
    }

  /*
  ** init -- initialize parameters
  */
  init() {
    cmd=COMMAND;
    mrg=MRGCHAR;
    blank=BLANK;
    sentend=NO;
    fill=just=YES;
    lsval=1;
    inval=tival=sqval=0;
    lmval=DEFLM;
    rmval=DEFRM;
    bfval=itval=ceval=ulval=cuact=0;
    curpag=0;
    newpag=1;
    lineno=0;
    mpval=DEFMP;
    bline=NO; /** prevents a blank first page **/
    plval=PAGELEN;
    m1val=DEFM1;
    m2val=DEFM2;
    m3val=DEFM3;
    m4val=DEFM4;
    bottom=plval-m3val-m4val;
    oheader[0]=eheader[0]=NULL;
    ofooter[0]=efooter[0]=NULL;
    outp=-1;
    outw=outwds=0;
    dir=0;
    }

  /*
  ** command -- process commands
  */
  command(buf) char buf[]; {
    int argtyp, spval, val;
    if(buf[1] == cmd) return; /* comment */
    val=getval(buf, &amp;argtyp);
    switch((toupper(buf[1]) &lt;&lt; 8) + toupper(buf[2])) {
      default: {
        fputs(&quot;\7note: &quot;, stderr);
        fputs(buf, stderr);
        fputc('\n', stderr);
        return;
        }
      case 'FI': {
        brk();
        fill=YES;
        break;
        }
      case 'NF': {
        brk();
        fill=NO;
        break;
        }
      case 'JU': {
        brk();
        just=YES;
        break;
        }
      case 'NJ': {
        brk();
        just=NO;
        break;
        }
      case 'BR':{
        brk();
        break;
        }
      case 'LS': {
        setvalue(&amp;lsval, val, argtyp, 1, 1, HUGE);
        break;
        }
      case 'HE': {
        gettl(buf, oheader);
        gettl(buf, eheader);
        break;
        }
      case 'OH': {
        gettl(buf, oheader);
        break;
        }
      case 'EH': {
        gettl(buf, eheader);
        break;
        }
      case 'FO': {
        gettl(buf, ofooter);
        gettl(buf, efooter);
        break;
        }
      case 'OF': {
        gettl(buf, ofooter);
        break;
        }
      case 'EF': {
        gettl(buf, efooter);
        break;
        }
      case 'SP': {
        setvalue(&amp;spval, val, argtyp, 1, 0, HUGE);
        space(spval);
        bline=YES;
        break1;
        }
      case 'BP': {
        if((lineno &gt; 0)|(outp &gt; -1)) space(HUGE);
        setvalue(&amp;curpag, val, argtyp, newpag, -HUGE, HUGE);
        newpag=curpag;
        break;
        }
      case 'PL': {
        if(val==0) {
          lineno=1;
          plval=0;
          }
        else {
          setvalue(&amp;plval, val, argtyp,
              PAGELEN, m1val+m2val+m3val+m4val+1, HUGE);
          bottom=plval-m3val-m4val;
          }
        break;
        }
      case 'IN': {
        brk();
        setvalue(&amp;inval, val, argtyp, 0, -lmval, rmval-lmval-1);
        break;
        }
      case 'LM': {
        brk();
        setvalue(&amp;lmval, val-1, argtyp, DEFLM, 0, rmval-1);
        break;
        }
      case 'RM': {
        setvalue(&amp;rmval, val, argtyp, DEFRM, lmval+1, HUGE);
        break;
        }
      case 'TI': {
        brk();
        setvalue(&amp;tival, val, argtyp, 0,
            -(lmval+inval), rmval-(lmval+inval)-1);
        break;
        }
      case 'SQ': {
        brk();
        setvalue(&amp;sqval, val, argtyp, 0, 0, HUGE);
        break;
        }
      case 'CE': {
        brk();
        setvalue(&amp;ceval, val, argtyp, 1, 0, HUGE);
        break;
        }
      case 'BF': {
        setvalue(&amp;bfval, val, argtyp, 1, 0, HUGE);
        ulval=0;
        break;
        }
      case 'IT': {
        setvalue(&amp;itval, val, argtyp, 1, 0, HUGE);
        break;
        }
      case 'DW': {
        setvalue(&amp;dwval, val, argtyp, 1, 0, HUGE);
        break;
        }
      case 'UL': {
        setvalue(&amp;ulval, val, argtyp, 1, 0, HUGE);
        cuact=0;
        ulskips=&quot; ()[]{}\t\b,.;:?!_'\&quot;&quot;;
        bfval=0;
        break;
        }
      case 'CU': {
        setvalue(&amp;ulval, val, argtyp, 1, 0, HUGE);
        if(ulval==0) cuact=0;
        else cuact=1; /* becomes 2 after next putwrd */
        if(ttymode) ulskips=&quot; \t\b&quot;;
        else        ulskips= &quot;\t\b&quot;;
        break;
        }
      case 'NU': {
        ulval=cuact=0;
        break;
        }
      case 'MP': {
        setvalue(&amp;mpval, val, argtyp, DEFMP, 0, HUGE);
        break;
        }
      case 'NE': {
        if(((bottom-lineno) &lt; val) &amp; (lineno &gt; 0))
          space(HUGE);
        break;
        }
      case 'RS': {
        if(((bottom-lineno) &lt; val) &amp; (lineno &gt; 0))
          space(HUGE);
        space(val);
        break;
        }
      case 'SO': {
        include();
        break;
        }
      case 'PR': {
        prompt();
        break;
        }
      case 'CC': {
        val=0;
        getwrd(buf, &amp;val, wrdbuf);
        if(getwrd(buf, &amp;val, wrdbuf)=1) cmd=wrdbuf[0];
        break;
        }
      case 'MC': {
        val=0;
        getwrd(buf, &amp;val, wrdbuf);
        if(getwrd(buf, &amp;val, wrdbuf)==1) mrg=wrdbuf[0];
        break;
        }
      case 'BC': {
        val=0;
        getwrd(buf, &amp;val, wrdbuf);
        if(getwrd(buf, &amp;val, wrdbuf)==1) blank=wrdbuf[0];
        break;
        }
      case 'M1': {
        setvalue(&amp;m1val, val, argtyp, DEFM1, 0, HUGE);
        break;
        }
        case 'M2': {
        setvalue(&amp;m2val, val, argtyp, DEFM2, 0, HUGE);
        break;
        }
      case 'M3': {
        setvalue(&amp;m3val, val, argtyp, DEFM3, 0, HUGE);
        bottom=plval-m3val-m4val;
        break;
        }
      case 'M4': {
        setvalue(&amp;m4val, val, argtyp, DEFM4, 0, HUGE);
        bottom=plval-m3val-m4val;
        break;
        }
      case 'PO': {
        setvalue(&amp;pospec, val, argtyp, 0, 0, HUGE);
        break;
        }
      }
    }

  #include &quot;format2.c&quot;
  #include &quot;format3.c&quot;
  #include &quot;scopy.c&quot;
  #include &quot;getwrd.c&quot;
  #include &quot;cant.c&quot;
  #include &quot;page.c&quot;
  #include &quot;index.c&quot;
  #include &quot;same.c&quot;
  #include &quot;trim.c&quot;
  #include &quot;out.c&quot;

  /*
  ** format2.c -- text formatter part 2
  */

  /*
  ** getval -- evaluate optional numeric argument
  */
  getval(buf, argtyp) char buf[]; int *argtyp; {
    int i;
    i:0;
    while((buf[i]!=' ')&amp;(buf[i]!='\t')&amp;(buf[i]!=NULL)) ++i;
    skipbl(buf, &amp;i);
    *argtyp=buf[i];
    if((*argtyp=='+')|(*argtyp=='-')) ++i;
      [2 if(utoi(buf+i, &amp;i) &lt; 0) {
      fputs(&quot;\7error: &quot;, stderr);
      fputs(inbuf, stderr);
      fputc('\n', stderr);
      return 0;
      }
    return i;
    }

  /*
  ** skipbl -- skip blanks and tabs
  */
  skipbl(lin, i) char lin[]; int *i; {
    while((lin[*i]==' ')|(lin[*i]=='\t')) *i = *i + 1;
    }

  /*
  ** setvalue -- set parameter and check range
  */
  setvalue(param, val, argtyp, defval, minval, maxval)
    int *param, val, argtyp, defval, minval, maxval; {
    if(argtyp==NULL) *param=defval;
    else if(argtyp=='+') *param=*param+val;
    else if(argtyp=='-') *param=*param-val;
    else *param=val;
    if(*param &gt; maxval) *param=maxval;
    if(*param &lt; minval) *param=minval;
    }

  /*
  ** text -- process text lines
  */
  text(inbuf) char inbuf[]; {
    int i;
    char c1, c2;
    if((inbuf[O]==' ')|(inbuf[O]==NULL)) leadbl(inbuf);
    if(bfval &gt; 0) {
      bold(inbuf, wrdbuf, INSIZE);
      --bfval;
      }
    dwact = NO;
    if(dwval &gt; 0) {
      if(!ttymode) {
        dwact = YES;
        double(inbuf, wrdbuf, INSIZE);
        }
      --dwval;
      }
    if(ulval &gt; 0) {
      if(itsub) italic(inbuf, wrdbuf, INSIZE);
      else      underl(inbuf, wrdbuf, INSIZE);
      --ulval;
      }
    if(itval &gt; 0) {
      if(ulsub) underl(inbuf, wrdbuf, INSIZE);
      else      italic(inbuf, wrdbuf, INSIZE);
      --itval;
      }
    supersub(inbuf, wrdbuf, INSIZE);
    if(ceval &gt; 0) {
      center(inbuf);
      put(inbuf);
      --ceval;
      }
    else if(inbuf[0]==NULL) put(inbuf);
    else if(fill==NO) put(inbuf);
    else {
      i=0;
      wrdbuf[0]=' ';
      while(getwrd(inbuf, &amp;i, wrdbuf+1) &gt; 0) {
        
if((sentend==YES)&amp;(isupper(wrdbuf[1])==YES)&amp;(wrdbuf[2]!='.'))
          putwrd(wrdbuf); /** leading space **/
        else putwrd(wrdbuf+1);
        if(inbuf[i-1]=='&quot;') {
          c1=inbuf[i-3];
          c2=inbuf[i-2];
          }
        else {
          c1=inbuf[i-2];
          c2=inbuf[i-1];
          }
        if((inbuf[i]!='\t')&amp;(isupper(c1)==NO)&amp;
           ((c2=='.')|(c2=='?')|(c2=='!'))) sentend=YES;
        else sentend=NO;
        }
      }
    if(ulval==0) cuact=0;
    }

  /*
  ** format3.c -- text formatter part 3
  */

  /*
  ** put -- put out line with proper spacing and indenting
  */
  put(buf) char buf[]; {
    int i;
    if((buf[0]==NULL)|(buf[0]==' ')) bline=YES;
    else {
      if(((bottom-lineno+1) &lt; (mpval*lsval)) &amp;&amp;
         (bline==YES) &amp;j
         (mpcnt &gt;= mpval)) {
        mpcnt=0;
        skip(bottom-lineno+1);
        lineno=bottom+1;   /* force footing */
        }
      bline=NO;
      }
    ++mpcnt;
    if(lineno&gt;bottom) pfoot();
    if(lineno==0) phead();
    i=poval; /** minus on odd pages **/
    while(++i &lt;= (lmval+tival+inval+sqval))
      print(&quot; &quot;, NO);
    tival=0;
    print(buf, NO);
    if((lsval-1) &lt; (bottom-lineno)) skip(lsval);
    else skip(bottom-lineno+1);
    if(plval &gt; 0) lineno=lineno+lsval;
    if(lineno &gt; bottom) pfoot();
    }

  /*
  ** print -- print output to stdout if not skipping pages
  */
  print(str, title) char *str; int title; (
    while(*str) {
      if(*str == 1) {
        if(!title) onoff(*(str-1));
        }
      else {
        /* skip output of control sequence terminator */
        if((plval==0)|((curpag &gt;= begin)&amp;(pagekill==NO))) {
          begin=1; /** future copies begin on page 1 **/
          if(*str != blank) cout(*str, stdout);
          else cout(' ', stdout);
          }
        else if(*str == 27) {
          while(*str != 1) cout(*str++, stdout);
          continue;
          }
        }
      ++str;
      }
    }

  /*
  ** onoff -- set and clear xxon and xxoff pointers
  */
  onoff(ch) int ch; {
         if(ch == ulpref[2]) {ulon=ulpref; uloff=ulsuff;}
    else if(ch == ulsuff[2]) ulon=uloff=0;
    else if(ch == bfpref[1]) {bfon=bfpref; bfoff=bfsuff;}
    else if(ch == bfsuff[1]) bfon=bfoff=0;
    else if(ch == dspref[1]) {dson=dspref; dsoff=dssuff;}
    else if(ch == dssuff[1]) dson=dsoff=0;
    else if(ch == itpref[1]) {iton=itpref; itoff=itsuff;}
    else if(ch == itsuff[1]) iton=itoff=0;
    else if(ch == dwpref[1]) {dwon=dwpref; dwoff=dwsuff;}
    else if(ch == dwsuff[1]) dwon=dwoff=0;
    }

  /*
  ** skip -- output n blank lines
  */
  skip(n) int n; {
    while((n--) &gt; 0) print(&quot;\n&quot;, NO);
    }

  /*
  ** phead -- put out header
  */
  phead() {
    pagekill=NO;
    if((curpag=newpag++) &gt;= begin) {
      if(page(curpag, pause, sdout)==KILL) {
        pagekill=YES;
        fputc('\n', stderr);
        }
      }
    if(curpag%2) poval = -pospec;
    else poval = pospec;
    if(m1val &gt; 0) {
      skip(m1val-1);
      if(curpag%2) puttl(oheader, curpag);
      else puttl(eheader, curpag);
      }
    skip(m2va1);
    lineno=mlval+m2val+1;
    }

  /*
  ** pfoot -- put out footer
  */
  pfoot() {
    skip(m3val);
    if(m4val &gt; 0) {
      if(curpag%2) puttl(ofooter, curpag);
      else puttl(efooter, curpag);
      }
    if((curpag &gt;= end)&amp;((ecopy==HUGE)|(ecopy==pass))) {
      fclose(stdout);
      exit(0);
      }
    if(pause==NO) skip(m4val-1);
    lineno=0;
    }

  /*
  ** puttl -- put out title line with optional page number
  */
  puttl(buf, pageno) char buf[]; int pageno; {
    char str[2];
    int i, j, k ,parts;
    str[1]=NUlL;
    i=poval; /** minus on odd pages **/
    while(++i &lt;= lmval) print( &quot; &quot;, YES);
    parts=1;
    i=k=0;
    while(buf[i])=NULL) {
      if(buf[i]==PAGENUM) {
        itod(pageno, nbrstr, - NWIDTH);
        j=0;
        while(nbrstr[j]==' ') ++j;
        while(j &lt; NWIDTH) {
          if(k &lt; (MAXOUT-1)) ttlbuf[k++]=nbrstr[j];
          ++j;
          }
        }
      else {
        if(buf[i]==TTLDELIM) ++parts;
        if(k &lt; (MAXOUT-1)) ttlbuf[k++]=buf[i];
        }
      ++i;
      }
    ttlbuf[k]=NULL;
    spread(ttlbuf, k+1, MAXOUT, rmval-lmval-k, parts, TTLDELIM);
    /* disable running ul, it, dw, ds, or bf */
    if(uloff) print(uloff, YES);
    if(itoff) print(itoff, YES);
    if(dsoff) print(dsoff, YES);
    if(bfoff) print(bfoff, YES);
    if(dwoff) print(dwoff, YES);
    print(ttlbuf, YES);
    /* reenable running ul, it, dw, ds, or bf */
    if(ulon) print(ulon, YES);
    if(iton) print(iton, YES);
    if(dson) print(dson, YES);
    if(bfon) print(bfon, YES);
    if(dwon) print(dwon, YES);
    print(&quot;\n&quot;, YES);
    }

  /*
  ** gettl -- copy title from buf to ttl
  */
  gettl(buf, ttl) char *buf, *ttl; {
    int i;
    i0;
    wh; te((buf[i]!=' ')&amp;(buf[i]!='\t')&amp;(buf[i]!=NULL)) ++i;
    skipbl(buf, &amp;i);
    if((buf[i]=='\&quot;)|(buf[i]=='&quot;')) ++i; /** strip leading quote **/
    buf=buf+i;
    while(*ttl++ = *buf++);
    }

  /*
  ** space -- space n lines or to bottom
  */
  space(n) int n; {
    brk();
    if(lineno &gt; bottom) return;
    if(lineno==0) {
      phead();
      if(n==HUGE) return;
      }
    if(n &lt; (bottom+1-lineno)) skip(n);
    else skip(bottom+1-lineno);
    if(plval &gt; 0) lineno=lineno+n;
    if(lineno &gt; bottom) pfoot();
    }

  /*
  ** leadbl -- delete leading blanks, set tival
  */
  leadbl(buf) char buf[]; {
    int i, j;
    brk();
    i=0;
    while(buf[i]==' ') ++i;
    if(buf[i]!=NULL) tival = tival + i;
    j=0;
    while(buf[j++]=buf[i++]);
    }

  /*
  ** width -- compute width of character string
  */
  width(buf) char *buf; {
    int wide;
    wide=0;
    while(*buf) {
      if(*buf==27) {
        while(*buf++ != 1) ;
        continue;
        }
      if(*buf == '\b') --wide;
      else if(*buf != '\n') {
        ++wide;
        if(dwact &amp;&amp; !isspace(*buf)) ++wide;
        }
      ++buf;
      }
    return (wide);
    }

  /*
  ** brk -- end current filled line
  */
  brk() {
    if(outp &gt; -1) {
      outbuf[outp]=NULL;
      outp=-1;
      put(outbuf);
      }
    outw=outwds=0;
    }

  /*
  ** putwrd -- put a word in outbuf (does margin justification)
  */
  putwrd(wrdbuf) char wrdbuf[]; {
    int last, llval, nextra, w, i;
    w=width(wrdbuf);
    last=strlen(wrdbuf)+outp+1;
    llval=rmval-lmval-tival-inval-(sqval&lt;&lt;1);
    if((outp &gt; -1)&amp;((outw+w &gt; llval)|(last &gt;= MAXOUT))) (
      last=last-outp-1;
      if(just!=YES) nextra=0;
      else nextra=llval-outw+1;
      spread(outbuf, outp, MAXOUT, nextra, outwds, ' ');
      if((nextra &gt; 0)&amp;(outwds &gt; 1)) outp=outp+nextra;
      brk();
      }
    if(outp &gt; 0 &amp;&amp; cuact &gt; 1 &amp;&amp; !itsub &amp;&amp; ttymode)
      outbuf[outp]='';
    else {
      ++outwds;
      if(cuact==1) cuact=2;
      }
    if((outp &lt; 0)&amp;(wrdbuf[0]==' ')) i=1; else i=0;
    scopy(wrdbuf+i, 0, outbuf, outp+1);
    outp=last-i;
    outbuf[outp]=''
    outw=outw+w+1-i;
    }

  /*
  ** spread -- spread words to justify right margin
  */
  spread(buf, outp, max, nextra, outwds, gapid)
    char buf[], gapid; int outp, max, nextra, outwds; {
    int i, j, nb, nel nholes;
    if((nextra &lt;= 0)|(outwds &lt;= 1)) return;
    dir=1-dir; /* reverse prey direction */
    ne=nextra;
    nholes=outwds-1;
    i=outp-1;
    if((max-2) &lt; (i+ne)) j=max-2;
    else j=i+ne;
    while(i &lt; j) {
      if(buf[i]==gapid) {
        buf[j]=' ';
        if(dir==0) nb=(ne-1)/nholes + 1;
        else nb=ne/nholes;
        ne=ne-nb;
        nholes=nholes-1;
        while((nb--) &gt; 0)
          buf[--j]=' ';
        }
      else buf[j]=buf[i];
      --i;
      --j;
      }
    }

  /*
  ** center -- center a line by setting tival
  */
  center(buf) char buf[]; {
    int i, j;
    j = -lmval - inval - sqval;
    if((i=((rmval-lmval-width(buf))/2)-inval-sqval) &lt; j)
         tival = j;
    else tival = i;
    }

  /*
  ** underl -- underline a line
  */
  underl(buf, tbuf, size) char buf[], tbuf[]; int size; {
    char c, *ptr;
    int prefixed, i, j;
    if(*buf == 0) return;
    if(!ttymode) prefixed=NO;
    else prefixed=9; /* neither YES nor NO */
    i=j=0;
    while((buf[i]!=NUlL)&amp;(j&lt;(size-2))) {
      c=buf[i++];
      if(index(ulskips, c) &lt; 0) {
        if(prefixed==NO) {
          prefixed=YES;
          ptr=ulpref;
          while((tbuf[j++]=*ptr++) != 1) ;
          }
        else if(ttymode) {
          tbuf[j++]=''-;
          tbuf[j++]='\b';
          }
        }
      else {
        if(prefixed==YES) {
          prefixed=NO;
          ptr=ulsuff;
          while((tbuf[j++]=*ptr++) != 1) ;
          }
        if(cuact&gt;0 &amp;&amp; fill==NO &amp;&amp; c==' ' &amp;&amp; ttymode) c='_';
        }
      tbuf[j++]=c;
      }
    if(prefixed==YES) {
      ptr=ulsuff;
      while((tbuf[j++]=*ptr++) != 1) ;
      }
    tbuf [j]=NULL;
    scopy(tbuf, 0, buf, 0);
    }

  /*
  ** bold -- boldface a line
  */
  bold(buf, tbuf, size) char buf[], tbuf[]; int size; {
    char *ptr;
    int c, i, j;
    if(*buf == 0) return;
    i=j=0;
    if(!ttymode) {
      ptr=bfpref;
      while((tbuf[j++]=*ptr++) != 1);
      ptr=dspref;
      while((tbuf[j++]=*ptr++) != 1) ;
      }
    while((buf[i]!=NULL)&amp;(j&lt;(size-2))) {
      c=tbuf[j++]=buf[i++]&amp;255;
      if(ttymode &amp;&amp; (c &gt; ' ') &amp;&amp; (c &lt; 127)) 
{
        int i;
        i = bfstrikes;
        while (--i) {
          tbuf[j++]='\b';
          tbuf[j++]=c;
          }
        }
      }
    if(!ttymode) {
      ptr=bfsuff;
      while((tbuf[j++]=*ptr++) != 1);
      ptr=dssuff;
      while((tbuf[j++]=*ptr++) != 1) ;
      }
    tbuf[j]=NULL;
    scopy(tbuf, 0, buf, 0);
    }

  /*
  ** italic -- italicize a line
  */
  italic(buf, tbuf, size) char buf[], tbuf[]; int size; {
    char *ptr;
    int i, j;
    if(*buf == 0) return;
    if(ttymode) return;
    i=j=0;
    ptr=itpref;
    while((tbuf[j++]=*ptr++) != 1) ;
    ptr=bfpref;
    while((tbuf[j++]=*ptr++) != 1);
    while((buf[i]!=NULL)&amp;(j&lt;(size-2))) tbuf[j++]=buf[i++];
    ptr=itsuff;
    while((tbuf[j++]=*ptr++) != 1);
    ptr=bfsuff;
    while((tbuf[j++]=*ptr++) != 1);
    tbuf[j]=NULL;
    scopy(tbuf, 0, buf, 0);
    }

  /*
  ** double -- double-wide a line (nontty mode only)
  */
  double(buf, tbuf, size) char buf[], tbuf[]; int size; {
    char *ptr;
    int space, i, j;
    if(!*buf || ttymode) return;
    space = YES;
    i = j = 0;
    while(buf[i] &amp;&amp; j &lt; (size-3)) {
      if(isspace(buf[i])) {
        if(!space) {
          ptr=dwsuff;
          while((tbuf[j++]=*ptr++) != 1) ;
          }
        space = YES;
        }
      else {
        if(space) {
          ptr=dwpref;
          while((tbuf[j++]=*ptr++) != 1) ;
          }
        space = NO;
        }
      tbuf[j++]=buf[i++];
      }
    if(!space) {
      ptr=dwsuff;
      while((tbuf[j++]=*ptr++) != 1) ;
      }
    tbuf[j]=NULL;
    scopy(tbuf, 0, buf, 0);
    }

  /*
  ** supersub -- process super- &amp; sub-scripts
  */
  supersub(buf, tbuf, size) char buf[], tbuf[]; int size; {
    char *pref, *suff, *ptr;
    int i, j;
    if(!*buf) return;
    i = j = suff = 0;
    while(buf[i] &amp;&amp; j &lt; (size-3)) {
      if(isspace(buf[i]) &amp;&amp; suff) {
        while((tbuf[j++] = *suff++) != 1);
        suff = 0;
        }
      if(buf[i] == SUBCHAR &amp;&amp; buf[i+1] == SUBCHAR) {
        if(!ttymode) {
          if(suff) {ptr = suff; suff = 0;}
          else     {ptr = sbpref; suff = sbsuff;}
          while((tbuf[j++] = *ptr++) != 1);
          }
        i += 2;
        }
      else if(buf[i] == SUPCHAR &amp;&amp; buf[i+1] == SUPCHAR) {
        if(!ttymode) {
          if(suff) {ptr = suff;   suff = 0;}
          else    {ptr  = sppref; suff = spsuff;}
          while((tbuf[j++] = *ptr++) != 1);
          }
        i += 2;
        }
      else tbuf[j++] = buf[i++];
      }
    if(suff) while((tbuf[j++] = *suff++) != 1);
    tbuf[j] = NULL;
    scopy(tbuf, 0, bur, 0);
    }

  /*
  ** doargs -- process command line arguments
  */
  doargs(argc, argv) int argc, *argv; (
    char arg[MAXFN];
    int i, err;
    show=err=ttymode=itsub=ulsub=NO;
    pause=ready=YES;
    bfstrikes=3;
    pospec=mrgfd=0;
    mrgbuf[0]=NULL;
    begin=bcopy=1;
    end=ecopy=HUGE;
    i=0;
    while(getarg(++i, arg, MAXFN, argc, argv)!=EOF) {
    if(arg[0]=='-') {
      if(same(arg[1], 'n') &amp; same(arg[2], 'p')) {
        pause=NO;
        continue;
        }
      if(same(arg[1], 'n') &amp; same(arg[2], 'r')) {
        ready=NO;
        continue;
        }
      if(same(arg[1], 's') &amp; arg[2] == NULL) {
        show = YES;
        continue;
        }
      if(same(arg[1], 't') &amp; arg[2]==NULL) ( /** tty mode **/
        ttymode=YES;
        continue;
        }
      if(same(arg[1], 'i') &amp; arg[2] == NULL) (
        /* italics replace underlines */
        itsub=YES;
        continue;
        }
      if(same(arg[1], 'u') &amp; arg[2] == NULL) {
        /* underlines replace italics */
        ulsub=YES;
        continue;
        }
      if(same(arg[1], 'b')) {
        if(same(arg[2], 'p')) { /** begin page # **/
          if(utoi(arg+3, &amp;begin) &gt; 0) continue;
          }
        else if(same(arg[2], 'c')) { /** copy # **/
          if(utoi(arg+3, &amp;bcopy) &gt; 0) continue;
          }
        else if(same(arg[2], 's')) { /** boldface strikes **/
          if(utoi(arg+3, &amp;bfstrikes) &gt; 0) continue;
          }
        }
      if(same(arg[1], 'e')) {   /** end **/
        if(same(arg[2], 'p')) { /** page # **/
          if(utoi(arg+3, &amp;end) &gt; 0) continue;
          }
        else if(same(arg[2], 'c')) {  /** copy # **/
          if(utoi(arg+3, &amp;ecopy) &gt; 0) continue;
          }
        }
      if(same(arg[1], 'p') &amp; same(arg[2], 'o')) {  /** page offset **/
        if(utoi(arg+3, &amp;pospec) &gt; 0) continue;
        }
        err=YES;
        }
      else {
        if((mrgfd=fopen(arg, &quot;r&quot;))==NULL) cant(arg);
        continue;
        }
      err=YES;
      }
    if(err==YES) {
      fputs(&quot;usage: FORMAT [mergefile] [-BC#] [-EC#]\n&quot;,stderr);
      fputs(&quot;    [-BP#] [-EP#] [-PO#] [-NP] [-NR]\n&quot;,stderr);
      fputs(&quot;    [-T] [-I] [-U] [-S] [-BS#]\n&quot;,stderr);
      abort(7);
      }
    }

  /*
  ** merge -- merge fields from mrgbuf into inbuf
  */
  merge() {
    int i, j, k, l, m, merged;
    if(mrgbuf[0]==NULL) return YES;
    scopy(inbuf, 0, ttlbuf, 0);
    merged=NO;
    i=j=0;
    while(inbuf[i]=ttlbuf[j++]) {
      if(inbuf[i++]==mrg) {
        if((l=utoi(ttlbuf+j, &amp;k)) &lt; 1) continue;
        if(ttlbuf[j+t]!=mrg) continue;
        --i;
        j=j+l+1;
        m=0;
        while(--k) {
          while(mrgbuf[m]) {
            if(mrgbuf[m++]==mrg) break;
            }
          }
        while((mrgbuf[m]!=NULL)&amp;(mrgbuf[m]!=mrg)) {
          inbuf[i++]=mrgbuf[m++];
          if(i &gt;= (INSIZE-1)) break;
          }
        merged=YES;
        }
      }
    if(merged==NO) return YES;
    i = -1;
    while(inbuf[++i]) {
      if((inbuf[i]!=' ')&amp;(inbuf[i]!='\t')) return YES;
      }
    return NO;
    }<p>
</pre>
<b><a name="list13-11">LISTING 13-11</a><p></b>
<pre>
  /*
  ** list.c -- list text in columns on pages
  **
  ** Copyright 1982 J. E. Hendrix. All rights reserved.
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  int
    fd,     /* file descriptor for input */
    eof,    /* end of file if YES */
    cols,   /* number of cols */
    cwidth, /* col width */
    pwidth, /* page width */
    plength,/* page length */
    blanks, /* blank lines processed if YES */
    numbers,/* number lines if &gt; 0 */
    pause;  /* pause before each page if YES */
  main(argc, argv) int argc, *argv; {
    if(!isatty(stdout)) {        /* set default dimensions */
      pause=NO;
      pwidth=PTRWIDE-1;
      plength=PTRHIGH-PTRSKIP-PTRHDR;  /* page body height */
      }
    else {
      pause=YES;
      pwidth=CRTWIDE-1;
      plength=CRTHIGH-1;              /* allow for prompts */
      }
    blanks=YES;
    eof=NO;
    cols=1;
    numbers=1;
    fd=stdin;
    doargs(argc, argv);
    cwidth=pwidth/cols;
    while(eof==NO) {
      if(pause) {
        fputs(&quot;waiting... &quot;, stderr);
        fgetc(stderr);
        }
      eof=column(fd, stdout, cwidth, cols, plength, &amp;numbers);
      }
    fclose(stdout);
    }
  doargs(argc, argv) int argc, *argv; {
    int i, j, k, err;
    char arg[MAXFN];
    err=NO;
    i=0;
    while(getarg(++i, arg, MAXFN, argc, argv) != EOF) {
      if(arg[0] != '-') {
        if(!(fd=fopen(arg, &quot;r&quot;))) {err=YES; break;}
        continue;
        }
      if(same(arg[1], 'c')) {
        if((j=utoi(arg+2, &amp;cols)) &lt; 1) {err=YES; break;}
        if((cols &lt; 1)|(arg[j+2] &gt; ' ')) {err=YES; break;}
        continue;
        }
      if(same(arg[1], 'n')) {
        if(arg[3] &lt;= ' ') {
          if(same(arg[2], 'b')) {
            blanks=NO;
            continue;
            }
          if(same(arg[2], 'p')) {
            pause=NO;
            continue;
            }
          if(same(arg[2], 'n')) {
            numbers=0;
            continue;
            }
          err=YES;
          }
        }
      if(same(arg[1], 'p')) {
        if((j=utoi(arg+3, &amp;k)) &gt; 0) {
          if((k &gt; 0)&amp;(arg[j+3] &lt;= ' ')) {
            if(same(arg[2], '1')) {
              plength=k;
              continue;
              }
            if(same(arg[2], 'w')) {
              pwidth=k;
              continue;
              }
            }
          }
        }
      err=YES;
      }
    if(err) {
      fputs(&quot;usage: LIST [file] [-C#] [-PW#] [-PL#] [-NB] [-NN] [-NP]\n&quot;,
            stderr);
      abort(7);
      }
    }
  column(in, out, cwidth, cols, plength, number)
     int in, out, cwidth, cols, plength, *number; {
     int eof, lines, colcnt, lwidth, i, bufsz, linecnt;
    char *ptr, *stop, *eptr, *nexteptr, *buf, *bend;
    bufsz=cols*(cwidth+1)*plength;
    ptr=buf=malloc(bufsz);
    bend=buf+bufsz;
    eof=NO;
    while(ptr &lt; bend) {
      poll(YES);
      if(*number) {
        i=4;
        itou(*number, ptr, -i);
        ptr[i++]=' ';
        }
      else i=0;
      if(fgets(ptr+i, cwidth+1-i, in)==NULL) {
        eof=YES;
        break;
        }
      trim(ptr+i);
      if((blanks==NO) &amp;&amp; (ptr[i]==NULL)) continue;
      if(*number) ++(*number);
      ptr=ptr+cwidth+1;
      }
    stop=ptr;
    ptr=buf;
    lwidth=cols*(cwidth+1);
    lines=(stop-buf)/lwidth;
    if((stop-buf)%lwidth) ++lines;
    if(lines==0) return eof;
    linecnt=lines;
    while(linecnt--) {
      poll(YES);
      eptr=ptr;
      colcnt=cols;
      while(colcnt--) {
        sout(eptr, out);
        if((nexteptr=eptr+(lines*(cwidth+1))) &gt;= stop) break;
        if(colcnt &gt; 0) {
          if((i=strlen(eptr)) &lt; cwidth) {
            i=cwidth-i;
            while(i--) cout(' ', out);
            }
          }
        eptr=nexteptr;
        }
      cout('\n', out);
      ptr=ptr+cwidth+1;
      }
    free(buf);
    return eof;
    }
  #include &quot;out.c&quot;
  #include &quot;same.c&quot;
  #include &quot;trim.c&quot;<p>
</pre>

<b><a name="list13-12">LISTING 13-12</a><p></b>
<pre>
  /*
  ** merge.c -- compares two sorted text files
  **
  ** Copyright 1982 J. E. Hednrix. All rights reserved.
  **
  ** switch 1 = lines in first file only
  ** switch 2 = lines in second file only
  ** switch 3 = lines in both files
  ** switch f = lines in both files formatted
  **
  **          stdin defaults for second file
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  int cmpr, fd1, fd2, i;
  char *line1, *line2, column, arg[MAXFN];
  main(argc, argv) int argc, *argv; {
    int error;
    column='0';
    fd1=fd2=stdin;
    line1=malloc(MAXLINE+1);
    line2=malloc(MAXLINE+1);
    error=NO;
    i=0;
    while(getarg(++i, arg, MAXFN, argc, argv)!=EOF) {
      if(arg[0]!='-') {
        if(fd1==stdin) {
          if((fd1=fopen(arg, &quot;r&quot;))==NULL) cant(arg);
          }
        else if(fd2==stdin) {
          if((fd2=fopen(arg, &quot;r&quot;))==NULL) cant(arg);
          }
        else error=YES;
        }
      else if(((arg[1] &gt; '0')&amp;(arg[1] &lt; '4'))
              |(same(arg[1], 'f')))
        column=arg[1];
      else error=YES;
      }
    if((error)|(fd1==stdin)) {
      fputs(&quot;usage: MERGE file [file] [-1|-2|-3|-F]\n&quot;, stderr);
      abort(7);
      }
    auxbuf(fd1, 4096);
    auxbuf(fd2, 4096);
    getline(line1, fd1);
    getline(line2, fd2);
    while(YES) {
      poll(YES);
      cmpr=lexcmp(line1, line2);
      if(cmpr &lt; 0) {
        if(same(column, 'f')) fout(&quot;1)&quot;, line1);
        else if((column=='0')|(column=='1')) sout(line1, stdout);
        getline(line1, fd1);
        continue;
        }
      else if(cmpr &gt; 0) {
        if(same(column, 'f')) fout(&quot; 2)&quot;, line2);
        else if((column=='0')|(column=='2')) sout(line2, stdout);
        getline(line2, fd2);
        continue;
        }
      if(line1[0] == 127) break;
      if(same(column, 'f')) fout(&quot; 3) &quot;, line1);
      else if((column=='0')|(column=='3')) sout(line1, stdout);
      getline(line1, fd1);
      getline(line2, fd2);
      }
    fclose(stdout);
    }

  getline(line, fd) char *line; int fd; {
    if(fgets(line, MAXLINE+1, fd)==NULL) {
       line[0] = 127;
       line[1] = NULL;
      }
    }

  /*
  ** fout -- formatted output of a line
  */
  fout(header, data) char *header, *data; {
    sout(header, stdout);
    sout(data, stdout);
    }

  #include &quot;out.c&quot;
  #include &quot;cant.c&quot;
  #include &quot;same.c&quot;<p>
</pre>
<b><a name="list13-13">LISTING 13-13</a><p></b>
<pre>
  /*
  ** print.c -- print files with optional page skips, headings,
  **          and line numbers.
  **
  ** Copyright 1982 J. E. Hendrix. All rights reserved.
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define MARGIN1 0
  #define MARGIN2 1
  char name[MAXFN], inclext[MAXFN];
  int
    i,
    fin,
    files,
    headings,
    skips,
    numbers,
    begin,
    end,
    ready,
    pause;
  int lineno, pageno, margin;
  main(argc, argv) int argc, *argv; {
    headings=skips=numbers=YES;
    doargs(argc, argv);
    if(iscons(stdout)) freopen(&quot;LST:&quot;, &quot;w&quot;, stdout);
    if(ready &amp;&amp; isatty(stdout)) {
      fputs(&quot;ready printer... &quot;, stderr);
      fgetc(stderr);
      }
    files=NO;
    i=0;
    while(getarg(++i, name, MAXFN, argc, argv)!=EOF) {
      if((name[0]=='-')|(name[0]==EXTMARK)) continue;
      files=YES;
      fin=fopen(name, &quot;r&quot;);
      if(fin==0) cant(name);
      pageno=lineno=0;
      fprnt(name, fin);
      fclose(fin);
      if((lineno &gt; 0)&amp;(skips)) skip(PTRHIGH-lineno);
      }
    if(files==NO) {
      pageno=lineno=0;
      fprnt(&quot;&lt;stdin&gt;&quot;, stdin);
      if((lineno &gt; 0)&amp;(skips)) skip(PTRHIGH-lineno);
      }
    fclose(stdout);
    exit(0);
    }

  doargs(argc, argv) int argc, *argv; {
    int i, j;
    inclext[0]=NULL;
    begin=0;
    end=32767;
    ready=YES;
    pause=NO;
    margin=0;
    i=0;
    while(getarg(++i, name, MAXFN, argc, argv)!=EOF) {
      if(name[0]==EXTMARK) {
        j=0;
        while(inclext[j]=toupper(name[j])) ++j;
        continue;
        }
      if(name[0][='-') continue;
      if((same(name[1], 'b'))&amp;(same(name[2], 'p'))) {
        utoi(name+3, &amp;begin);
        continue;
        }
      if((same(name[1], 'e'))&amp;(same(name[2], 'p'))) {
        utoi(name+3, &amp;end);
        continue;
        }
      if((same(name[1], '['))&amp;(same(name[2], 'm'))) {
        utoi(name+3, &amp;margin);
        continue;
        }
      if((same(name[1], 'n'))&amp;(same(name[2], 'r'))) {
        ready=NO;
        continue;
        }
      if(same(name[1], 'p')) {
        pause=YES;
        continue;
        }
      if(same(name[1], 'n')) {
        if(same(name[2], 'h')) {headings=NO; continue;}
        if(same(name[2], 's')) { skips=NO; continue;}
        if(same(name[2], 'n')) { numbers=NO; continue;}
        }
      fputs(&quot;usage: PRINT [file]... [.?] [-NN] [-NH|-NS]\n&quot;,
            stderr);
      fputs(&quot;    [-LM#] [-BP#] [-EP#] [-P] [-NR]\n&quot;, stderr);
      abort(7);
      }
    }

  fprnt(name, fin)
    char name[]; int fin; {
    char line[MAXLINE+1], word[MAXLINE+1];
    int textline, fin2, i, temp;
    textline=0;
    while(fgets(line, MAXLINE+1, fin)!=NULL) {
      poll(YES);
      if((lineno==0)&amp;(skips)) {
        if(++pageno &gt; end) exit(0);
        if(pageno &gt;= begin) {
          page(pageno, pause, stdout);
          skip(MARGIN1);
          if(headings) {
            temp=margin;
            while(temp--) printf(&quot; &quot;, 0);
            if(numbers) printf(&quot;      &quot; , 0);
            printf(&quot;File: %s   Page: %d\n&quot;, name, pageno, 2);
            }
          else printf(&quot;\n&quot;,0);
          ++lineno;
          skip(MARGIN2);
          }
        lineno=lineno+MARGIN1+MARGIN2;
        }
      ++textline;
      ++lineno;
      if(pageno &gt;= begin) {
        temp=margin;
        while(temp--) printf(&quot; &quot;, 0);
        if(numbers)
          printf(&quot;%5d %s&quot;, textline, line, 2);
        else printf(&quot;%s&quot;, line, 1);
        }
      if((lineno &gt;= (PTRHIGH-PTRSKIP))&amp;(skips)) {
        skip(PTRHIGH-lineno);
        lineno=0;
        }
      if(inclext[0]!=EXTMARK) continue;
      i=0;
      getwrd(line, &amp;i, word);
      if((lexcmp(word, &quot;#include&quot;)==0) ||
         ([excmp(word, &quot;.so&quot;)==0)) {
        if(getwrd(line, &amp;i, word) &gt;= MAXFN) cant(word);
        strip(word);
        i=0;
        while((word[i]!=EXTMARK) &amp;&amp; (word[i])) ++i;
        if((inclext[1]) &amp;&amp;
           (lexcmp(word+i, inclext)!=0)) continue;
        if((fin2=fopen(word, &quot;r&quot;))==NULL) cant(word);
        fprnt(name, fin2);
        fclose(fin2);
        }
      }
    }

  skip(n) int n; {
    int i;
    if(pageno &lt; begin) return;
    i:0;
    while(++i &lt;= n) {
      poll(YES);
      fputc('\n', stdout);
      }
    }
  #include &quot;cant.c&quot;
  #include &quot;page.c&quot;
  #include &quot;same.c&quot;
  #include &quot;strip.c&quot;
  #include &quot;getwrd.c&quot;<p>
</pre>
<b><a name="list13-14">LISTING 13-14</a><p></b>
<pre>
  /*
  ** sort.c -- sort text lines
  **
  ** Copyright 1982 J. E. Hendrix. All rights reserved.
  **
  ** Each line in the buffer is preceeded by a 1-byte offset to
  ** the sort key. Line pointers designate the first data byte.
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  #define SHELL 1
  #define QUICK 2
  #define WRTMODE 2
  #define MAXRUNS 99
  #define LOGPTR 20
  #define AVGLIN 28
  #define RESERVE 2000
  #define MERGEORDER 5
  char *linbuf, outnam[MAXFN], tmpdrv;
  char lastline[MAXLINE+1];
  char *maxbuf, *maxlin; /**** fake unsigned int ****/
  char tmpout[]=&quot;X:sort00.$$$&quot;;
  char tmpinp[]=&quot;X:sort00.$$$&quot;;
  char tmpdel[]=&quot;X:sort00.$$$&quot;;
  char delim;
  int field;
  int tmpfd[MERGEORDER], *linptr, nlines;
  int low, lim, high, outfil, output, t, order, unique, typesort;
  main(argc, argv) int argc, *argv; {
    lastline[0]=outnam[0]=0;
    tmpdrv='X';
    doargs(argc, argv);
    if(tmpdrv == 'X') {
      strcpy(tmpout, tmpout+2);
      strcpy(tmpinp, tmpinp+2);
      strcpy(tmpdel, tmpdel+2);
      }
    else tmpout[0]=tmpinp[0]=tmpdel[0]=tmpdrv;
    output=stdout;
    if((lim=avail(YES))&lt;0) lim=32767;
    maxlin=(lim-RESERVE)/(2+AVGLIN);
    linptr=malloc(2*maxlin);
    if{(lim=avail(YES})&lt;0) lim=32767;
    maxbuf=lim - RESERVE;
    linbuf=malloc(maxbuf);

    high=0;
    while(YES) {
      if(++high &gt;= MAXRUNS) {
        fputs(&quot;file too large\n&quot;, stderr);
        abort(7);
        }
      t=gtext();

      sort(0, nlines-1);

      if(high==1) {
        if(t==NULL) {
          outfil=output;
          ptext();
          fclose(outfil);
          exit(0);
          }
        }
      maketmp();
      ptext();
      fclose(outfil);
      if(t==NULL) break;
      }

  /*
  ** Must deallocate in reverse order from allocation.
  ** Will allocate input tmp file buffers/FCBs over this space;
  ** these must not reach end of linbuf where output tmp file
  ** space was allocated, since that space stays with that fd.
  */
    free(linbuf);
    free(linptr);

    linptr=malloc(2*(MERGEORDER+1));
    linbuf=malloc(MERGEORDER*(MAXLINE+1));
    lastline[0]=0;
    low=1;
    while(low &lt; high) {               /*05*/
      lim=low+MERGEORDER-1;
      if(high &lt; lim) lim=high;
      t=0;
      while(t &lt;= (lim-low)) {
        bumptmp(tmpinp);
        if((tmpfd[t]=fopen(tmpinp, &quot;r&quot;))==NULL) cant(tmpinp);
        auxbuf(tmpfd[t++], 2048); /* redundant calls ignored */
        }
      if(lim==high) outfil=output;
      else maketmp();
      if(++high &gt;= MAXRUNS) {
        fputs(&quot;file too large\n&quot;, stderr);
        abort(7);
        }
      merge(lim-low+1);
      fclose(outfil);
      t=0;
      while(t &lt;= (lim-low)) {
        fclose(tmpfd[t++]);           /*02*/
        killtmp();
        }
      low=low+MERGEORDER;
      }
    }

  doargs(argc, argv) int argc, *argv; {
    char arg[MAXFN], c;
    int i, error, len;
    field=0;
    delim=NULL;    /** indicates column number in field **/
    order=1;
    typesort=SHELL;
    unique=error=NO;
    i:0;
    while(getarg(++i, arg, MAXFN, argc, argv)!=EOF) {
      c=arg[1];
      if(arg[0]!='-') error=YES;
      else if(same(c, 't') &amp;&amp;
             (toupper(arg[2]) &gt; 'A') &amp;&amp;
             (toupper(arg[2]) &lt; 'G') &amp;&amp;
             (arg[3]==NULL))
             tmpdrv=arg[2];
      else if(same(c, 'c')) {
        delim:NULL;
        if(arg[utoi(arg+2, &amp;field)+2] != NULL) error=YES;
        if(field) --field;
        }
      else if(same(c, 'f')) {
        if(arg[(len=utoi(arg+2, &amp;field))+2] &gt; ' ') {
          delim=arg[len+2];
          if(arg[len+3] != NULL) error=YES;
          }
        else delim=' ';
        if(field) --field;
        field = -field;
        }
      else if(arg[2]!=NULL) error=YES;
      else if(same(c, 'd')) order=-1;
      else if(same(c, 'u')) unique=YES;
      else if(same(c, 'q')) typesort:QUICK;
      else error=YES;
      if(error) {
        fputs(&quot;usage: SORT [-C#|-F#?] [-D] [-U] [-Tx] [-Q]\n&quot;, stderr);
        abort(7);
        }
      }
    }

  gtext() {
    int len;
    char *lbp;
    lbp=1; /** leave space for first sort key offset **/
    nlines=0;
    while(YES) {
      poll(YES);
      if((len=readline(linbuf+lbp, stdin))==NULL) break;
      linptr[nlines++]=lbp;
      lbp=lbp+len; /** has 2 bytes for NULL and next offset **/
      if(((lbp+1) &gt;= (maxbuf-(MAXLINE+1)))||(nlines &gt;= maxlin))
        break;
      }
    return len;
    }

  ptext() {
    int i;
    char *lbp;
    i:0;
    while(i &lt; nlines) {
      poll(YES);
      lbp=linbuf+linptr[i++];
      if(duptest(lbp)) continue;
      sout(lbp, outfil);
      }
    }

  duptest(line) char *line; {
    int diff;
    if(!unique) return (NO);          /*03*/
    diff = lexcmp(lastline, line);
    strcpy(lastline, line);
    return (!diff);
    }

  bumptmp(tmpname) char tmpname[]; {
    char *digit;
    digit = strchr(tmpname, '.') - 1;
    if(*digit == '9') {*digit = '0'; --digit;}
    ++*digit;
    }

  maketmp() {
    bumptmp(tmpout);
    if((outfil=fopen(tmpout,&quot;w&quot;))==NULL) cant(tmpout);
    }

  killtmp() {
    bumptmp(tmpdel);
    unlink(tmpdel);
    }

  sort(lv, uv) int lv, uv; {
    if(typesort==QUICK) quick(lv, uv);
    else                shell(lv, uv);
    }

  shell(lv, uv) int lv, uv; {
    int gap, i, j, jg;
    gap = (uv-lv+1) &gt;&gt; 1; /** divide by 2 **/
    while(gap &gt; 0) {
      poll(YES);
      i = gap + lv;
      while(i &lt;= uv) {
        j = i++ - gap;
        while(j &gt;= lv) {
          jg = j + gap;
          if(compare(linptr[j], linptr[jg]) &lt;= 0) break;
          exchange(j, jg);
          j = j - gap;
          }
        }
      gap = gap&gt;&gt;1; /** divide by 2 **/
      }
    }

  quick(lv, uv) int lv, uv; {
    int i, j, pivlin;
    avail(YES);
    poll(YES);
    if(lv &gt;= uv) return; /** only one element **/
    i=lv-1;
    j=uv;
    pivlin=linptr[j];
    while(i &lt; j) {
      ++i;
      while(compare(linptr[i], pivlin) &lt; 0) ++i;
      --j;
      while(i &lt; j) {
        if(compare(linptr[j], pivlin) &gt; 0) --j;
        else break;
        }
      if(i &lt; j) exchange(i, j);
      }
    j:uv;
    exchange(i, j);
    if((i-lv) &lt; (uv-i)) {
      quick(lv, i-1);
      quick(i+1, uv);
      }
    else {
      quick(i+1, uv);
      quick(lv, i-1);
      }
    }

  compare(p1, p2) int p1, p2; {
    char *ptr1, *ptr2;
    ptr1 = linbuf + (p1 - 1); ptr1 = ptr1 + *ptr1;
    ptr2 = linbuf + (p2 - 1); ptr2 = ptr2 + *ptr2;
    while(lexorder(*++ptr1, *++ptr2) == 0)
      if((*ptr1 == NULL)||(delimit(*ptr1))) return 0;
    if(delimit(*ptr1)) return -order;
    if(delimit(*ptr2)) return order;
    if(lexorder(*ptr1, *ptr2) &gt; 0) return order;
    return -order;
    }

  delimit(c) char c; {
    if(c &gt; delim)    return NO;
    if(delim == ' ') return YES;
    if(c &lt; delim)    return NO;
    return YES;
    }

  exchange(i, j) int i, j; {
    int k
    k=linptr[i]; linptr[i]=linptr[j]; linptr[j]=k;
    }

  merge(nfiles) int nfiles; {
    int i, inf, lbp, lp1, nf;
    char *ptr;
    lbp=1; /* leave space for first sort key offset **/
    nf=i=0;
    while(i &lt; nfiles) {    /** get one line from each file **/
      if(readline((linbuf+lbp), tmpfd[i++])!=NULL) {
        linptr[++nf]=lbp;
        lbp=lbp+(MAXLINE+1);
        }
      }

    sort(1, nf);    /** make initial heap **/ /*04*/

    while(nf &gt; 0) {
      poll(YES);
      lp1=linptr[1];
      ptr=linbuf+lp1;
      if(duptest(ptr)==NO) sout(ptr, outfil);
      inf=(lp1/(MAXLINE+1)); /** compute file index **/
      if(readline((linbuf+lp1), tmpfd[inf])==NULL)
        linptr[1]=linptr[nf--];
      reheap(nf);
      }
    }

  reheap(nf) int nf; {
    int i, j;
    i=1;
    while((j=(i&lt;&lt;1)) &lt;= nf) {
      if(j &lt; nf) {      /** find smaller child **/
        if(compare(linptr[j], linptr[j+1]) &gt; 0) ++j;
        }
      if(compare(linptr[i], linptr[j]) &lt;= 0) break;
      exchange(i, j);     /** percolate **/
      i=j;
      }
    }

  /*
  ** readline -- read next line, set its sort key offset,
  **         and return its length
  */
  readline(str, fd) char *str; int fd; {
    int fld;
    char *ptr, *offset;
    if(fgets(str, MAXLINE+1, fd)==NULL) return NULL;
    ptr=offset=str-1;     /** location of offset field **/
    fld=field;
    if(delim) {           /** must search for field'th field **/
      *offset = -1;
      while(*(++ptr)) {
        if(fld &lt; 0) {
          if(delim == ' ') {
            if((*ptr &gt; ' ')&amp;(*(ptr+1) &lt;= ' ')) ++fld;
            }
          else if(*ptr == delim) ++fld;
          }
        else if((fld == 0)&amp;((delim != ' ')|(*ptr &gt; ' '))) {
          *offset=(ptr-str);
          fld=1;
          }
        }
      if (*offset == -1) *offset=(ptr-str); /** end of line **/
      }
    else {  /** field is the column number of the sort key **/
      while(*(++ptr));
      if(field &lt; (ptr-str)) *offset=field;
      else                  *offset=(ptr-str);
      }
    return (ptr-str+2); /** includes NULL and next offset **/
    }

  #include &quot;out.c&quot;
  #include &quot;cant.c&quot;
  #include &quot;same.c&quot;<p>
</pre>
<b><a name="list13-15">LISTING 13-15</a><p></b>
<pre>
  /*
  ** trans.c -- map characters
  **
  ** Copyright 1982 J. E. Hendrix. All rights reserved.
  */
  #include &lt;stdio.h&gt;
  #include &quot;tools.h&quot;
  #define NOCCARGC
  #define MAXARG 80
  #define MAXSET 127
  main(argc, argv) int argc, *argv; {
    char arg[MAXARG+1], c, from[MAXSET+1], to[MAXSET+1];
    int allbut, collap, i, lastto, error;
    auxbuf(stdin, 4096);
    error=NO;
    if(getarg(1, arg, MAXARG, argc, argv)==EOF) error=YES;
    if(((arg[0]=='-')&amp;(arg[1]&lt;=' '))|(error==YES)) {
      fputs(&quot;usage: TRANS [~]from [to]\n&quot;, stderr);
      abort(7);
      }
    if(arg[0]==NOT) {
      allbut=YES;
      if(makset(arg, 1, from, MAXSET)==NO)
        error(&quot;from-list too large&quot;);
      }
    else {
      allbut=NO;
      if(makset(arg, 0, from, MAXSET)==NO)
        error(&quot;from-list too large&quot;);
      }
    if(getarg(2, arg, MAXARG, argc, argv)==EOF) to[0]=NULL;
    else if(makset(arg, 0, to, MAXSET)==NO)
      error(&quot;to-list too large&quot;);
    lastto=strlen(to)-1;
    if((strlen(from)&gt;(tastto+1))|(allbut==YES)) collap=YES;
    else collap=NO;
    while(1) {
      poll(YES);
      i=xindex(from, c=fgetc(stdin), allbut, lastto);
      if((colLap==YES)&amp;(i&gt;=lastto)&amp;(lastto&gt;-1)) { /* collapse */
        if(fputc(to[lastto], stdout)==EOF)
          error(&quot;output error&quot;);
        while(1) {
          i=xindex(from, c=fgetc(stdin), allbut, lastto);
          if(i&lt;lastto) break;
          }
        }
      if(c==EOF) break;
      if((i&gt;-1)&amp;(lastto&gt;-1)) {            /* translate */
        if(fputc(to[i], stdout)==EOF)
          error(output error&quot;);
        }
      else if(i&lt;0) {                      /* copy */
        if(fputc(c, stdout)==EOF)
          error(&quot;output error&quot;);
        }
      }                                   /* delete */
    fclose(stdout);
    }
  #include &quot;pat.c&quot;
  #include &quot;error.c&quot;
  #include &quot;index.c&quot;
  #include &quot;xindex.c&quot;
  #include &quot;makset.c&quot;<p>
</pre>
<b><a name="list13-16">LISTING 13-16</a><p></b>
<pre>
-----------------------------------------------------------FILE: STDIO.H
  /*
  ** STDIO.H -- Standard Small-C Definitions
  **
  ** Copyright 1983 L. E. Payne and J. E. Hendrix
  */
  #define stdin       0
  #define stdout      1
  #define stderr      2
  #define ERR      (-2)
  #define EOF      (-1)
  #define YES         1
  #define NO          0
  #define NULL        0
  #define CR         13
  #define LF         10
  #define BELL        7
  #define SPACE     ' '
  #define NEWLINE LF

-----------------------------------------------------------FILE: TOOLS.H
  /*
  ** Small-Tools definitions.
  **
  ** The metacharacter definitions do not completely
  ** follow UNIX or the Software-Tools definitions.
  **
  ** You may change anything to suit your preferences.
  */
  #define MAXFN      15  /* max file name space */
  #define EXTMARK    '.' /* file extension mark */
  #define MAXLINE   192  /* max text line space */

          /* WY-50, TV-920, HZ-1500, AD-VP */
  #define CLEAR &quot;\33\53&quot; /* screen erase */
  #define CRTWIDE    80  /* screen width */
  #define CRTHIGH    24  /* screen height */
  #define PTRWIDE    80  /* page width */
  #define PTRHIGH    66  /* page height */
  #define PTRSKIP     8  /* page perforation skips */
  #define PTRHDR      2  /* page header lines */

  #define MAXPAT    257  /* max pattern in internal format */
  #define CHAR       'c' /* identifies a character */
  #define BOL       ' ' /* beginning of line */
  #define EOL        '\&quot; /* end of line */
  #define ANY        '?' /* any character */
  #define CCL        '[' /* begin character class */
  #define NCCL       '~' /* negation of character class */
  #define CCLEND     ']' /* end of character class */
  #define CLOSURE    '*' /* zero or more occurrences */
  #define DITTO      '^' /* whatever string matches pattern */
  #define ESCAPE     ':' /* escape character */
  #define NOT        '~' /* negation character */

  #define DITCODE    -3
  #define COUNT       1
  #define PREVCL      2
  #define START       3
  #define CLOSIZE     4

-------------------------------------------------------------FILE: BUF.C
  /*
  ** buf.c -- buffer manipulation functions (memory version)
  */
  int gotline, gotind;
  char *bufptr;
  /*
  ** clrbuf -- initialize for new file (stub)
  */
  clrbuf() {
    return;
    }

  /*
  ** getind -- locate line index in buf
  */
  getind(ln) int ln; {
    int j;
    if((j=ln-gotline) &gt; 0)
      while(j--) getint(gotind+NEXT, &amp;gotind, INTEGER);
    else if(j &lt; 0)
      while(j++) getint(gotind+PREV, &amp;gotind, INTEGER);
    gotline=ln;
    return gotind;
    }

  /*
  ** getint -- obtain integer or long from buf at offset
  */
  getint(offset, dest, length) int offset, length; char *dest; {
    bufptr=buf+offset;
    while(length--) *dest++ = *bufptr++;
    }

  /*
  ** putint -- place integer or long into buf at offset
  */
  putint(offset, source, length) int offset, length; char *source; {
    bufptr=buf+offset;
    while(length--) *bufptr++ = *source++;
    }

  /*
  ** gettxt -- locate text for line and make available
  */
  gettxt(line) int line; {
    int i, j, k;
    i=(k=getind(line)) + TEXT;
    j=0;
    while(txt[j++]=buf[i++]);
    return k;
    }

  /*
  ** input -- input text from fd into buf
  */
  input(fd) int fd; {
    int k3;
    while(YES) {
      if(poll(YES)==ESC) return ERR;
      k3=lastbf;
      if(fgets(buf + (lastbf += TEXT), MAXLINE, fd)) {
        lastbf += trim(buf+lastbf) + 1;
        inlink(k3);
        if((lastbf+MAXLINE) &gt; maxbuf) {
          fputs(&quot;memory overflow &quot;, stderr);
          return ERR;
          }
        }
      else break;
      }
    lastbf -= TEXT;
    return OK;
    }

  /*
  ** inject -- put text from lin after curln
  */
  inject(lin) char lin[]; {
    int i, k3;
    if(*lin==NULL) {
      *lin='\n';
      *(lin+1)=NULL;
      }
    i=0;
    while(lin[i]!=NULL) {
      k3=lastbf;
      lastbf=lastbf+TEXT;
      while(lin[i]!=NULL) {
        if(lin[i]=='\n') {
          ++i;
          break;
          }
        addset(lin[i++], buf, &amp;lastbf, maxbuf);
        }
      if(addset(NUlL, buf, &amp;lastbf, maxbuf)==NO) {
        fputs(&quot;memory overflow &quot;, stderr);
        return ERR;
        }
      inlink(k3);
      }
    return OK;
    }

  /*
  ** inlink -- link injected line
  */
  inlink(k3) int k3; {
    int k1, k2;
    k1=getind(curln);
    /** leaves gotline &amp; gotind before affected area **/
    getint(k1+NEXT, &amp;k2, INTEGER);
    relink(k1, k3, k3, k2);
    relink(k3, k2, k1, k3);
    ++curln;
    ++lastln;
    }

  /*
  ** relink -- rewrite two half links
  */
  relink(a, x, y, b) int a, x, y, b; {
    putint(x+PREV, &amp;a, INTEGER);
    putint(y+NEXT, &amp;b, INTEGER);
    updtflag=YES;
    }

  /*
  ** setbuf -- initialize line storage buffer
  */
  setbuf() {
    relink(LINE0, LINE0, LINE0, LINE0);
    lastbf=LINE0+TEXT;
    addset(NULL, buf, &amp;lastbf, maxbuf);
    gotline=curln=lastln=0;
    gotind=LINE0;
    }

------------------------------------------------------------FILE: CANT.C
  /*
  ** cant.c -- abort with &quot;name: can't open&quot; message
  */
  cant(str) char *str; {
    fputs(str, stderr);
    fputs(&quot;: can't open\n&quot;, stderr);
    abort(7);
    }

----------------------------------------------------------FILE: CATSUB.C
  /*
  ** catsub.c -- add replacement text to end of new
  */
  catsub(lin, from, to, sub, new, k, maxnew)
    char lin[], new[], sub[];
    int from, to, *k, maxnew; {
    int i, j;
    i=0;
    while(sub[i]!=NULL) {
      if(sub[i]==DITCODE) {
        j=from;
        while(j &lt; to) addset(lin[j++], new, k, maxnew);
        }
      else addset(sub[i], new, k, maxnew);
      ++i;
      }
    }

-----------------------------------------------------------FILE: DIGIT.C
  /*
  ** digit.c -- return YES if c is a decimal digit, else NO
  */
  digit(c) char c; {
    if((c&gt;='0')&amp;(c&lt;='9')) return YES;
    return NO;
    }

-----------------------------------------------------------FILE: ERROR.C
  /*
  ** error.c -- display message str and abort
  */
  error(str) char *str; {
    fputs(str, stderr);
    fputc('\n', stderr);
    abort(7);
    }

----------------------------------------------------------FILE: GETWRD.C
  /*
  ** getwrd.c -- get non-blank word from in[i] into out, incr i
  */
  getwrd(in, i, out) char in[], out[]; int *i; {
    char c; int j;
    while(isspace(in[*i])) ++*i;
    j=0;
    while(c=in[*i]) {
      if(isspace(c)) break;
      out[j++]=c;
      ++*i;
      }
    out[j]=NULL;
    return j;
    }

-----------------------------------------------------------FILE: INDEX.C
  /*
  ** index.c -- find character c in string str
  */
  index(str, c) char str[], c; {
    int i;
    i=-1;
    while(str[++i]!=NULL) if(str[i]==c) return i;
    return -1;
    }

----------------------------------------------------------FILE: MAKSET.C
  /*
  ** makset.c -- make array into a set
  */
  makset(array, k, set, size) char array[], set[]; int k, size; {
    int i, j;
    i=k;
    j=0;
    filset(NULL, array, &amp;i, set, &amp;j, size);
    return addset(NULL, set, &amp;j, size);
    }

----------------------------------------------------------FILE: MAKSUB.C
  /*
  ** maksub.c -- make substitution string in sub
  */
  maksub(arg, from, delim, sub) char arg[], sub[], delim; int from; {
    int i, j;
    j=0;
    i=from;
    while((arg[i]!=delim)&amp;(arg[i]!=NULL)) {
      if(arg[i]==DITTO) addset(DITCODE, sub, &amp;j, MAXPAT);
      else addset(esc(arg, &amp;i), sub, &amp;j, MAXPAT);
      ++i;
      }
    if(arg[i]!=delim) return ERR; /**** missing delimiter ****/
    if(addset(NULL, sub, &amp;j, MAXPAT)==NO) return ERR; /** no room **/
    return i;
    }

-------------------------------------------------------------FILE: OUT.C
  /*
  ** out.c -- output to fd checking for errors
  */
  cout(c, fd) char c; int fd; {
    if(fputc(c, fd)==EOF) xout();
    }
  sout(string, fd) char *string; int fd; {
    if(fputs(string, fd)==EOF) xout();
    }

  lout(line, fd) char *line; int fd; {
    sout(line, fd);
    cout('\n', fd);
    }

  xout() {
    fputs(&quot;output error\n&quot;, stderr);
    abort(7);
    }

------------------------------------------------------------FILE: PAGE.C
  /*
  ** page.c -- tell stderr of new page and possibly pause
  */
  page(pageno, pause, fd) int pageno, pause, fd; {
    int i;
    char str[6];
    str[5]=NULL;
    itod(pageno, str, 5);
    i=0;
    while(str[i]==' ') ++i;
    if((pause==YES)&amp;&amp;(pageno&gt;1)&amp;&amp;isatty(fd)) {
      fputs(&quot;\7set page &quot;, stderr);
      fputs(str+i, stderr);
      fputs(&quot;... &quot;, stderr);
      return fgetc(stderr);
      }
    else {
      fputs(&quot;page &quot;, stderr);
      fputs(str+i, stderr);
      fputc('\n', stderr);
      return NULL;
      }
    }

-------------------------------------------------------------FILE: PAT.C
  /*
  ** pat.c -- pattern making and matching functions
  */

  /*
  ** addset -- put c in set &amp; increment j
  */
  addset(c, set, j, maxsiz) char c, set[]; int *j, maxsiz; {
    if(*j &gt;= maxsiz) return NO;
    set[*j]=c;
    *j = *j + 1;
    return YES;
    }

  /*
  ** amatch -- look for match starting at lin[from]
  */
  amatch(lin, from, pat) char lin[], pat[]; int from; {
    int i, j, offset, stack;
    stack = -1;
    offset=from;
    j=0;
    while(pat[j]!=NULL) {
      if(pat[j]==ClOSURE) {
        stack=j;
        j=j+CLOSIZE;
        i=offset;
        while(lin[i]!=NULL) {
          if(omatch(lin, &amp;i, pat, j)==NO) break;
          }
        pat[stack+COUNT]=i-offset;
        pat[stack+START]=offset;
        offset=i;
        }
      else if(omatch(lin, &amp;offset, pat, j)==NO) {
        while(stack &gt;= 0) {
          if(pat[stack+COUNT] &gt; 0) break;
          stack=pat[stack+PREVCL];
          }
        if(stack &lt; 0) return -1;
        pat[stack+COUNT]=pat[stack+COUNT]-1;
        j=stack+CLOSIZE;
        offset=pat[stack+START]+pat[stack+COUNT];
        }
      j=j+patsiz(pat, j);
      }
    return offset;
    }

  /*
  ** dodash -- expand array[i-1] - array[i+1] into set[j]...
  */
  dodash(valid, array, i, set, j, maxset)
    char valid[], set[], array[]; int *i, *j, maxset; {
    int k, limit;
    *i = 1 + *i;
    *j = -1 + *j;
    limit=index(valid, esc(array, i));
    k=index(valid, sel[*j]);
    while(k &lt;= limit)
      addset(valid[k++], set, j, maxset);
    }

  /*
  ** esc -- map array[i] into escaped char if appropriate
  */
  esc(array, i) char array[]; int *i; {
    if(array[*i]!=ESCAPE) return array[*i];
    else if(array[ *i + 1]==NULL)     /* esc not special at end */
      return ESCAPE;
    else {
      *i= *i + 1;
      if(array[*i]=='n') return '\n';
      else if(array[*i]=='t') return '\t';
      else if(array[*i]=='b') return '\b';
      else if(array[*i]=='s') return '';
      else return array[*i];
      }
    }

  /*
  ** filset -- expand set in array into set stopping at delim
  */
  filset(delim, array, i, set, j, maxset)
    char delim, array[], set[]; int *i, *j, maxset; {
    char *digits, *lowalf, *upalf;
    digits=&quot;0123456789&quot;;
    lowalf=&quot;abcdefghijklmnopqrstuvwxyz&quot;;
    upalf=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
    while((array[*i]!=delim)&amp;(array[*i]!=NULL)) {
      if(array[*i]==ESCAPE)
        addset(esc(array, i), set, j, maxset);
      else if(array[*i]!='-')
        addset(array[*i], set, j, maxset);
      else if((j &lt;= 0)|(array[*i+[]==NULL)) /* literal - */
        addset('-', set, j, maxset);
      else if(index(digits, set[*j -1]) &gt; -1)
        dodash(digits, array, i, set, j, maxset);
      else if(index(lowalf, set[*j -1]) &gt; -1)
        dodash(lowalf, array, i, set, j, maxset);
      else if(index(upalf, set[*j -1]) &gt; -1)
        dodash(upalf, array, i, set, j, maxset);
      else addset('-', set, j, maxset);
      *i = *i + 1;
      }
    }

  /*
  ** getccl -- expand char class at arg[i] into pat[j]
  */
  getccl(arg, i, pat, j) char arg[], pat[]; int *i, *j; {
    int jstart;
    *i = *i + 1; /**** skip over '[' in arg ****/
    if(arg[*i]==NOT) {
      addset(NCCL, pat, j, MAXPAT);
      *i = *i + 1;
      }
    else addset(CCL, pat, j, MAXPAT);
    jstart = *j;
    addset(0, pat, j, MAXPAT); /**** leave room for count ****/
    filset(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    if(arg[*i]==CCLEND) return YES;
    return ERR;
    }

  /*
  ** locate -- look for c in char class at pat[offset]
  */
  locate(c, pat, offset) char c, pat[]; int offset; {
    int i;
    /*
    ** size of class is at pat[offset], characters follow
    */
    i=offset+pat[offset];
    while( i &gt; offset) {
      if(c==pat[i--]) return YES;
      }
    return NO;
    }

  /*
  ** makpat -- make pattern from arg[from], end at delim
  */
  makpat(arg, from, delim, pat) char arg[], delim, pat[]; int from; {
    int i, j, lastcl, lastj, lj;
    j=lastj=0;
    lastcl = -1;
    i=from;
    while((arg[i]!=delim)&amp;(arg[i]!=NULL)) {
      lj=j;
      if(arg[i]==ANY) addset(ANY, pat, &amp;j, MAXPAT);
      else if((arg[i]==BOL)&amp;(i==from)) addset(BOL, pat, &amp;j, MAXPAT);
      else if((arg[i]==EOL)&amp;(arg[i+1]==delim)) addset(EOL, pat, &amp;j, MAXPAT);
      else if(arg[i]==CCL) {
        if(getccl(arg, &amp;i, pat, &amp;j)==ERR) break;
        }
      else if((arg[i]==CLOSURE)&amp;(i&gt;from)) {
        lj=lastj;
        if((pat[lj]==BOL)|(pat[lj]==EOL)|(pat[lj]==CLOSURE)) 
break;
        lastcl=stclos(pat, &amp;j, &amp;lastj, lastcl);
        }
      else {
        addset(CHAR, pat, &amp;j, MAXPAT);
        addset(esc(arg, &amp;i), pat, &amp;j, MAXPAT);
        }
      lastj=lj;
      ++i;
      }
    if((arg[i]!=delim)|(addset(NULL, pat, &amp;j, MAXPAT)==NO)) 
return ERR;
    return i;
    }

  /*
  ** match -- find match anywhere in line
  */
  match(line, pattern) char line[], pattern[]; {
    int i;
    i:0;
    while(YES) {
      if(amatch(line, i, pattern) &gt;= 0) return YES;
      if(line[i++]==NULL) return NO;
      }
    }

  /*
  ** omatch -- try to match a single pattern at pat[j]
  */
  omatch(lin, i, pat, j) char lin[], pat[]; int *i, j; {
    int bump;
    bump = -1;
    if(pat[j]==BOL) {
      if(*i==0) bump=0;
      }
    else if(pat[j]==EOL) {
      if(lin[*i]==NULL} bump=0;
      }
    else if(lin[*i]==NULL) return NO;
    else if(pat[j]==CHAR) {
      if(lin[*i]==pat[j+1]) bump=1;
      }
    else if(pat[j]==ANY) bump=1;
    else if(pat[j]==CCL) {
      if(locate(lin[*i], pat, j+1)==YES) bump=1;
      }
    else if(pat[j]==NCCL) {
      if(locate(lin[*i], pat, j+1)==NO) bump=1;
      }
    else error(&quot;in omatch: can't happen\n&quot;);
    if(bump &gt;= 0) {
      *i = *i + bump;
      return YES;
      }
    return NO;
    }

  /*
  ** patsiz -- returns size of entry at pat[n]
  */
  patsiz(pat, n) char *pat; int n; {
    pat=pat+n;
    if(*pat==CHAR) return 2;
    else if((*pat==BOL)|(*pat==EOL)|(*pat==ANY)) return 1;
    else if((*pat==CCL)|(*pat==NCCL)) return (*(++pat)+2);
    else if(*pat==CLOSURE) return CLOSIZE;
    else error(&quot;in patsiz: can't happen\n&quot;);
    }

  /*
  ** stclos -- insert closure entry at pat[j]
  */
  stclos(pat, j, lastj, lastcl) char pat[]; int *j, *lastj, lastcl; {
    int jp, jt;
    jp = *j - 1;
    while(jp &gt;= *lastj) { /**** make hole for closure ****/
      jt = jp + CLOSIZE;
      addset(pat[jp--], pat, &amp;jt, MAXPAT);
      }
    *j = *j + CLOSIZE;
    jp = *lastj;
    addset(CLOSURE, pat, lastj, MAXPAT);  /** CLOSURE **/
    addset(0, pat, lastj, MAXPAT);        /** COUNT **/
    addset(lastcl, pat, lastj, MAXPAT);   /** PREVCL **/
    addset(0, pat, lastj, MAXPAT);        /** START **/
    return jp;
    }

------------------------------------------------------------FILE: SAME.C
  /*
  ** same -- YES if c same as lower case lc, else NO
  **         c may be upper or lower case
  */
  same(c, lc) char c, lc; {
    if((c &gt;= 'A')&amp;(c &lt;= 'Z')) c = c + 32;
    if (c == lc) return YES;
    return NO;
    }

-----------------------------------------------------------FILE: SCOPY.C
  /*
  ** scopy -- copy from[i] to to[j]
  */
  scopy(from, i, to, j) char *from, *to; int i, j; {
    from=from+i;
    to=to+j;
    while(*to++ = *from++);
    }

----------------------------------------------------------FILE: SETTAB.C
  /*
  ** settab.c -- search command line for tab list possibly
  **             terminated with an interval (+n) and set up
  **             tabs[MAXLINE+1]
  */
  #define DEFTAB 8
  settab(tabs, argc, argv) char tabs[]; int argc, *argv; {
    int i, j, k;
    char parm[9];
    i=0;
    while(++i&lt;MAXLINE) tabs[i]=NO;
    if((getarg(1, parm, 9, argc, argv))==EOF) {
      i=0;
      while(++i&lt;MAXLINE)
      if((i%DEFTAB)==1) tabs[i]=YES;
      return YES;
      }
    i=0;
    j=1;
    while(getarg(++i, parm, 9, argc, argv)!=EOF) {
      if(utoi(parm, &amp;k)) {
        if(k&lt;=MAXLINE) {
          tabs[k]=YES;
          j=k;
          }
        else {
          fputs(&quot;tab stop beyond max line length\n&quot;, stderr);
          return ERR;
          }
        }
      else if(parm[0]=='+') {
        if(utoi((parm+1), &amp;k))
          while((j=j+k)&lt;=MAXLINE) tabs[j]=YES;
        }
      else return ERR;
      }
    return YES;
    }

-----------------------------------------------------------FILE: STRIP.C
  /*
  ** strip -- Strip &lt;,&gt;, and &quot; from str.
  */
  strip(str) char *str; {
    char *cp;
    cp = str - 1;
    while(*++cp = *str++) {
      switch(*cp) {
        case '&lt;':  case '&gt;':  case '&quot;':  --cp;
        }
      }
    }

----------------------------------------------------------FILE: TABPOS.C
  /*
  ** tabpos.c -- return YES if col is a tab stop, else NO
  */
  tabpos(col, tabs) int col; char tabs[]; {
    if(col&gt;MAXLINE) return YES;
    else return tabs[col];
    }

------------------------------------------------------------FILE: TRIM.C
  /*
  ** trim -- trim \n from str &amp; return its length
  */
  trim(str) char *str; {
    char *s;
    s = str - 1;
    while(*++s) ; /* prefix ++ is faster */
    if((*--s == '\n') &amp;&amp; (s &gt;= str)) *s = NULL; else ++s;
    return (s - str);
    }

----------------------------------------------------------FILE: XINDEX.C
  /*
  ** xindex.c -- invert condition returned by index
  */
  xindex(array, c, allbut, lastto) char array[], c; int allbut, lastto; {
    if(c==EOF) return -1;
    else if(allbut==NO) return index(array, c);
    else if(index(array, c)&gt;-1) return -1;
    else return lastto+1;
    }<p>
</pre>
<p>

<CENTER> Return to <a href="../toc.htm">Table of Contents
</a>
</CENTER><p>
</HTML>


