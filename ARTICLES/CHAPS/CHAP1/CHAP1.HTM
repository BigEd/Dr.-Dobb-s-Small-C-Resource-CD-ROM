<HTML>
<!--
 	Dr. Dobb's Small C Resource CD-ROM Compilation (c) 1997 Dr. 
Dobb's Journal, M&T Publishing, Inc., a subsidiary of Miller 
Freeman, Inc. All rights reserved.
-->
<CENTER>
<B><H1>THE C PROGRAMMING LANGUAGE</H1> <p>

by D.M. Ritchie, S.C. Johnson, M.E. Lesk, and B.W. Kernighan<p>
</CENTER>
</B>
 
 
<i>This article originally appeared in <i><a 
href="http://www.ddj.com">Dr. Dobb's Journal</a></i> #45 
(May,1980); 
the authors, who work at Bell Laboratories in Murray Hill, New 
Jersey, 
originally wrote the article in 1978. Copyright (c) 1978, 
American Telephone and 
Telegraph Company; reprinted by permission</i>. <p>
 
C is a general purpose programming language featuring economy of 
expression, modern control flow and data structure capabilities, 
and a rich set of 
operators and data types. <p>

C is not a &quot;very high-level&quot; language nor a big one and 
is not specialized 
to any particular area of application. Its generality and an 
absence of 
restrictions make it more convenient and effective for many more 
tasks than 
supposedly more powerful languages. C has been used for a wide 
variety of 
programs, including the Unix operating system, the C compiler 
itself, and 
essentially all Unix application software. The language is 
sufficiently expressive 
and efficient to have completely displaced assembly language 
programming on 
Unix. <p>

C was originally written for the PDP-11 under Unix, but the 
language is not 
tied to any particular hardware or operating system. C compilers 
run on a wide 
variety of machines, including the Honeywell 6000, the IBM 
System/370, and 
the Interdata 8/32. <p>

<B>Linguistic History of C <p>
</B>
The C language in use today (Kernighan and Ritchie, 1978) is the 
product of 
several years of evolution. Many of its most important ideas stem 
from the 
considerably older, but still quite vital, language BCPL 
(Richards, 1969) developed 
by Martin Richards. The influence of BCPL on C proceeded 
indirectly through 
the language B (Johnson and Kernighan, 1973), which was written 
by Ken 
Thompson in 1970 for the first Unix system on the PDP-11.  <p>

Although neither B nor C could really be considered dialects of 
BCPL, they 
all have several characteristic features in common: <p>
<OL>
<LI> All are able to express the fundamental flow-control 
constructions required for 
well-structured programs: statement grouping, decision-making 
(if), looping 
(while) with the termination test either at the top or the bottom 
of the loop, and 
branching out to a sequence of possible cases (switch). It is 
interesting that BCPL 
provided these constructions in 1967, well before the current 
vogue for structured 
programming.<p> 

<LI> All three languages include the concept of pointer and 
provide the ability to do
address arithmetic. <p>

<LI> In all three languages, the arguments to functions are 
passed by copying the value 
of the argument, and it is impossible for the function to change 
the actual 
argument. To achieve &quot;call by reference,&quot; a pointer may 
be passed explicitly, 
and the function may change the object to which the pointer 
points. Any function is 
allowed to be recursive, and its local variables are typically 
&quot;automatic&quot; or 
specific to each invocation. <p>

<LI> All three languages are rather low-level, in that, they deal 
with the same sorts of 
objects that most computers do. BCPL and B restrict their 
attention almost 
completely to machine words, whereas C widens its horizons 
somewhat to characters 
and (possibly multiword) integers, and floating-point numbers. 
None deals 
directly with composite objects such as character strings, sets, 
lists, or arrays 
considered as a whole. The languages themselves do not define any 
storage allocation 
facility beside static definition and the stack discipline 
provided by the local 
variables of functions; likewise, I/O is not part of any of these 
languages. All these 
higher mechanisms must be provided by explicitly called routines 
from libraries. <p>
</OL>
B and BCPL differ mainly in their syntax, and many differences 
stem from the 
very small size of the first B compiler (fewer than 4K 18-bit 
words on the PDP-7). 
Several constructions in BCPL encourage a compiler to maintain a 
representation of the entire program in memory. In BCPL, for 
example, <p> 
<PRE>
     valof $(
           ...
           resultis expression
           ...<p>
     $) 
</PRE>
is syntactically an expression. It provides a way of packaging a 
block of many 
statements into a sort of unnamed internal procedure yielding a 
single result 
(delivered by the resultis statement). The valof construction can 
occur in the 
middle of any expression, and can be arbitrarily large. The B 
language avoided 
the difficulties caused by this and some other constructions by 
rigorously 
simplifying (and in some cases adjusting to personal taste) the 
syntax of BCPL.<p> 

Despite many syntactic changes, B remained close to BCPL 
semantically. 
The most characteristic feature of both languages is their nearly 
identical 
treatment of addresses (pointers). They support a model of the 
storage of the 
machine consisting of a sequence of equal-sized cells, into which 
values can be 
placed; in typical implementations, these cells are machine 
words. Each 
identifier in a program corresponds to a cell, and a cell may 
contain a variety of 
values. Most often the value is an integer, or perhaps a 
representation of a 
character. All the cells, however, are numbered; the address of a 
cell is just the 
integer giving its ordinal position. BCPL has a unary operator <i>
lv</i> (in some 
versions, and also in B and C, shortened to &amp;) that, when 
applied to a name, yields 
the address of the cell corresponding to the name. The inverse 
operator <i>rv</i> (later 
*) yields the value in the cell pointed to. Thus the statement <p>

<PRE>
     px = &amp;x; <p>
</PRE>
of B assigns to px the number that can be interpreted as the 
address of x; the 
statements <p>
<PRE>
     y = *px + 2; 
     *px = 5; <p>
</PRE>
first use the value in the cell pointed to by px (which is the 
same cell as x) and 
then assign 5 to this cell. <p>

Arrays in BCPL and B are intimately tied up with pointers. An 
array 
declaration, which might in BCPL be written <p>
<PRE>
     let Array = vec 10 <p>
</PRE>
and in B <p>
<PRE>
     auto Array[10]; <p>
</PRE>
creates a single cell named Array and initializes it with the 
address of the first in 
a sequence of 10 unnamed cells containing the array itself. Since 
the quantity 
stored in <i>Array</i> is just the address of the cell of the 
first element of the array, the 
expression <p>
<PRE>
     Array + i <p>
</PRE>
is the address of the ith element, counting from zero. Likewise, 
applying the 
indirection operator, <p>
<PRE>
     *(Array + i) <p>
</PRE>
refers to the value of the ith member of the array. This 
operation is so frequent 
that special syntax was invented to express it:<p> 
<PRE>
     Array[i] <p>
</PRE>
Thus, despite its asymmetric appearance, subscripting is a 
commutative 
operation; the above example could equally well be written <p>
<PRE>
     i[Array] <p>
</PRE>
     In BCPL and B there is only one type of object, the machine 
word, so when 
the same language operator is applied to two operands, the 
calculation actually 
carried out must always be the same. Thus, for example, if the 
programmer 
wants to do floating-point arithmetic, the &quot;+&quot; operator 
notation cannot be 
used, since it implies an integer addition. Instead (in a version 
of BCPL for the 
GE 635), a &quot;.&quot; was placed in front of each operator 
that had floating-point 
operands. As may be appreciated, this was a frequent source of 
errors. <p>

The machine model implied by the definitions of BCPL and B is 
simple and 
self-consistent. It is, however, inadequate for many purposes, 
and on many 
machines it causes inefficiencies when implemented. The problems 
became 
evident to us after B began to be used heavily on the first 
PDP-11 version of Unix. <p>
 
The first problem followed from the fact that the PDP-11, like 
several machines 
(including, for example, the IBM System/370) is byte-addressed; a 
machine 
address refers to any of several bytes (characters) in a word, 
not the word alone. 
Most obviously, the word orientation of B cuts us off from any 
convenient 
ability to access bytes. Equally important was the fact that, 
before any address could 
be used, it had to be shifted left by one place. The reason for 
this is simple: 
there are two bytes per PDP-11 word. On the one hand, the 
language guaranteed 
that if 1 was added to an address quantity, it would point to the 
next word; on 
the other hand, the machine architecture required that word 
addresses be even 
and equal to the byte number of the first byte in the word. Since 
there was no 
way to distinguish cells containing ordinary integers from those 
containing 
pointers, the only solution visible was to represent pointers as 
word numbers 
and then, at the point of use, convert to the byte representation 
by 
multiplication by 2. <p>

Yet another problem was introduced by the desire to provide for 
floating-point arithmetic. The PDP-11 supports two floating-point 
formats, one of which 
requires two words, the other four. In neither case was it 
satisfactory to use the 
trick used on the GE 635 (operator like &quot;.+&quot;) because 
there was no way to 
represent the requirement for a single data item occupying four 
or eight bytes. 
This problem did not arise on the 635 because integers and 
single-precision 
floating-point both require only one word. <p>

Thus, the problems evidenced by B led us to design a new language 
that 
(after a brief period under the name NB) was dubbed C. The major 
advance 
provided by C is its typing structure, which completely solved 
the difficulties 
mentioned above. Each declaration in a C program specifies 
(sometimes 
implicitly) a type, which determines how much storage the object 
requires and how it 
is to be interpreted. The original fundamental types provided 
were single 
character (byte), integer, single-precision floating-point, and 
double-precision 
floating-point. (Others discussed below were added later.) Thus 
in the program <p>
<PRE>
     double a, b; 
        ... 
     a = b + 3;<p> 
</PRE>
the compiler can determine from the declarations of a and b the 
fact that they 
require four words of storage each, that the &quot;+&quot; means 
a double-precision 
floating add, and that &quot;3&quot; must be converted to 
floating.<p> 

Of course, the idea of typing variables is in no way original 
with C; in fact, 
it was the general rule among the most widely used and 
influential languages, 
including Algol, Fortran, and PL/1. Nevertheless, the 
introduction of types 
marked an important change in our own thinking. The typeless 
nature of BCPL 
and B had seemed to promise a great simplification in the 
implementation, 
understanding, and use of these languages. By the time C was 
created (circa 1972), 
advocates of languages such as Algol 68 and Pascal strongly 
recommended an 
enforced type structure on psychological grounds; but even 
disregarding their 
arguments, the typeless nature of BCPL and B seemed 
inappropriate, for purely 
technological reasons, to the available hardware. <p>
<B>
Type Structure of C <p>
</B>
The introduction of types in C, although a major departure from 
the tradition 
of BCPL and B, was done in such a way that many of the 
characteristic usages of 
the earlier languages survived. To some extent, this continuity 
was an attempt 
to preserve as much as possible of the considerable corpus of 
existing software 
written in B, but even more important, especially in retrospect, 
was the desire to 
minimize the intellectual distance between past and future ways 
of expression. <p>
<B>
Pointers, Arrays, and Address Arithmetic <p>
</B>
One clear example of the similarity of C to the earlier languages 
is its treatment 
of pointers and arrays. In C an array of 10 integers might be 
declared <p>
<PRE>
     int Array[10]; <p>
</PRE>
which is identical to the corresponding declaration in B. (Arrays 
begin at zero; 
the elements of <i>Array</i> are <i>Array[0],...,Array[9]</i>.) 
As discussed above, the B 
implementation caused a cell named Array to be allocated and 
initialized with a 
pointer to ten otherwise unnamed cells to hold the array. In C, 
the effect is a bit 
different; ten integers are allocated, and the first is 
associated with the name 
<i>Array</i>. But C also includes a general rule that, whenever 
the name of an array 
appears in an expression, it is converted to a pointer to the 
first member of the 
array. Strictly speaking, we should say, for this example, it is 
converted to an 
integer pointer since all C pointers are associated with a 
particular type to 
which they point. In most usages, the actual effects of the 
slightly different 
meanings of <i>Array</i> are indistinguishable. Thus in the C 
expression <p>
<PRE>
     Array + i <p>
</PRE>
the identifier <i>Array</i> is converted to a pointer to the 
first element of the array; <i>i</i> 
is scaled (if required) before it is added to the pointer. For a 
byte-addressed 
machine, the scale factor is the number of bytes in an integer; 
for a 
word-addressed machine the scale factor is unity. In any event, 
the result is a pointer to 
the <i>i</i>th member of the array. Likewise identical in effect 
to the interpretation 
of B, <p>
<PRE>
     *(Array + i)<p> 
</PRE>
is the <i>i</i>th member itself, and <p>
<PRE>
     Array[i] <p>
</PRE>
is another notation for the same thing. In all these cases, of 
course, should <i>Array </i>
be an array of, or pointer to, some objects other than integers, 
the scale factor is 
adjusted appropriately. The pointer arithmetic, as written, is 
independent of the 
type of object to which the pointer points and indeed of the 
internal 
representation of the pointer. <p>
<B>
Derived Types <p>
</B>
As mentioned above, the basic types in C were originally int, 
which represents 
an integer in the basic size provided by the machine 
architecture; char, which 
represents a single byte; float, a single-precision 
floating-point number; and 
double, double-precision floating-point. Over the years, long, 
short, and unsigned 
integers have been added. In current C implementations, long is 
at least 32 bits; 
short is usually 16 bits; and int remains the natural size for 
the machine at 
hand. Unsigned integers exist mainly to squeeze an extra bit out 
of the 
machine, since the sign bit need not be represented. <p>

In addition to these basic types, C provides a conceptually 
infinite 
hierarchy of derived types, which are formed by composition of 
the basic types with 
pointers, arrays, structures, unions, and functions. Examples of 
pointer and 
array declarations have already been exhibited; another is <p>
<PRE>
     double *vecp, vector[100]; <p>
</PRE>
which declares a pointer vecp to double-precision floating 
numbers, and an 
array vector of the same kind of objects. The size of an array, 
when specified, 
must always be a constant. <p>

A structure is an aggregate of one or more objects, usually of 
various types, 
which can be treated as a unit. C structures are essentially the 
same as records 
in languages such as Pascal, and semantically, though not 
syntactically, like 
PL/1 and Cobol structures. Thus: <p>
<PRE>
     struct tag { 
           int         i; 
           float       f; 
           char        c[3]; 
     };<p> 
</PRE>
defines a template, called tag, for a structure containing three 
members: an 
integer <i>i</i>, a floating-point number<i> f</i>, and a 
three-character array <i>c</i>. The 
declaration <p>
<PRE>
     struct tag x, y[10], *p; <p>
</PRE>
declares a structure <i>x </i>of this type, an array <i>y</i> of 
10 such structures, and a 
pointer <i>p</i> to this kind of structure. The hierarchical 
nature of derived types 
is clearly evident here: <i>y</i> is an array of structures whose 
members include 
an array of characters. References to individual members of 
structures use 
the &quot;.&quot; operator.<p> 
<PRE>
     x.i 
     x.f 
     y[i].c[0] 
     (*p).c[1] <p>
</PRE>
Parentheses in the last line are necessary because the. binds 
more tightly than 
the *. It turns out that pointers to structures are so common 
that special syntax 
is called for to express structure access through a pointer.<p> 
<PRE>
     p-&gt;c[1] 
     p-&gt;i <p>
</PRE>
This soon becomes more natural than the equivalent<p> 
<PRE>
     (*p).c[1] 
     (*p).i  <p>
</PRE>

A union can hold, at different times, objects of different types, 
with the 
compiler keeping track of size and alignment requirements. Unions 
provide a 
way to manipulate different kinds of data in a single part of 
storage, without 
embedding machine-dependent information (such as the relative 
sizes of <i>int </i>
and <i>float</i>) in a program. For example, the union <i>u</i>, 
declared <p>
<PRE>
     union { 
           int    i; 
           float  f; 
     yu; <p>
</PRE>
can hold either an <i>int</i> (written u.i) or a <i>float</i> 
(written u.f). Regardless of the 
machine it is compiled on, it will be large enough to hold either 
one of these 
quantities. A union is syntactically identical to a structure; it 
may be 
considered as a structure in which all the members begin at the 
same offset. Unions in 
C are more analogous to PL/1's CALL than to the unions of Algol 
68 or the 
variant records of Pascal, because it is the responsibility of 
the programmer to 
avoid referring to a union that does not currently contain an 
object of the 
implied type. <p>

A function is a subprogram that returns an object of a given 
type:<p> 
<PRE>
     unsigned unsf(); <p>
</PRE>
declares a function that returns unsigned. The type of a function 
ignores the 
number and types of its arguments, although in general the call 
and the 
definition must agree. <p>
<B>
Type Definition <p>
</B>
The syntax of declarations borrows from that of expressions. The 
key idea is 
that a declaration, say <p>
<PRE>
     int       ... ; <p>
</PRE>
contains a part &quot;...&quot; that, if it appeared in an 
expression, would be of type <i>int</i>. 
The constructions seen so far, for example, <p>
<PRE>
     int     *lptr; 
     int     lfunc(); 
     int     iarr[10]; <p>
</PRE>
exhibit this approach, but more complicated declarations are 
common. For 
example: <p>
<PRE>
     int     *funcptr(); 
     int     (*ptrfunc)(); <p>
</PRE>
declare respectively a function that returns a pointer to an 
integer, and a pointer 
to a function that returns an integer. The extra parentheses in 
the second are 
needed to make the * apply directly to <i>ptrfunc</i>, since the 
implicit function-call 
operator () binds more tightly than *. Functions are not 
variables, so arrays or 
structures of functions are not permitted. However, a pointer to 
a function, 
such as <i>ptrfunc</i>, may be stored, copied, passed as an 
argument, returned by a 
function, and so on, just as any other pointer.<p> 

Arrays of pointers are frequently used instead of 
multidimensional arrays. 
The usage of <i>a</i> and <i>b</i> when declared <p>
<PRE>
     int   a[10][10]; 
     int   *b[10]; <p>
</PRE>

may be similar, in that <i>a[5][5]</i> and <i>b[5][5]</i> are 
both legal references to a single 
int, but <i>a</i> is a true array: all 100 storage cells have 
been allocated, and the 
conventional rectangular subscript calculation is done. For <i>b
</i>, however, the 
declaration has only allocated 10 pointers; each must be set to 
point to an array of 
integers. Assuming each does point to a 10-element array, then 
there will be 100 
storage cells set aside, plus the 10 cells for the pointers. 
Thus, the array of 
pointers uses slightly more space and may require an extra 
initialization step, but it 
has two advantages: it trades an indirection for a subscript 
multiplication, and it 
permits the rows of the array to be of different lengths. (That 
is, each element of 
<i>b</i> need not point to a 10-element vector; one may point to 
2 elements, another 
to 20.) Particularly with strings whose lengths are not known in 
advance, an 
array of pointers is often used instead of a multidimensional 
array. Every C 
main program gets access to its invoking command line in this 
form, for 
example. <p>

The idea of specifying types by appropriating some of the syntax 
of 
expressions seems to be original with C, and for the simpler 
cases, it works well. 
Occasionally some rather ornate types are needed, and the 
declaration may be a bit 
hard to interpret. For example, a pointer to an array of pointers 
to functions, 
each returning an int, would be written <p>
<PRE>
     int (*(*funnyarray)[])(); <p>
</PRE>
 
that is certainly opaque, although understandable enough if read 
from the 
inside out. In an expression, funnyarray might appear as <p>
<PRE>
     i = (*(*funnyarray)[j])(k); <p>
</PRE> 
The corresponding Algol 68 declaration is <p>
<PRE>
     ref [] ref proc int funnyarray <p>
</PRE> 
when read from left to right in correspondence with the informal 
description of 
the type if <i>ref</i> is taken to be the equivalent of C's 
&quot;pointer to.&quot; The Algol may be 
clearer, but both are hard to grasp.<p> 
<B>
Statements and Control Flow <p>
</B>
Control flow in C differs from other languages primarily in 
details of syntax. As 
in PL/1, semicolons are used to terminate statements, not to 
separate them. 
Most statements are just expressions followed by a semicolon; 
since assignments 
are expressions, there is no need for a special assignment 
statement. <p>

Statements are grouped with braces { and }, rather than with 
words such as 
begin-end or do-od, because the more concise form seems much 
easier to read 
and is certainly easier to type. A sequence of statements 
enclosed in { } is 
syntactically a single statement. <p>

The if-else statement has the form <p>
<PRE>
     if (expression) 
           statement 
     else 
           statement <p>
</PRE> 
The expression is evaluated; if it is &quot;true&quot; (that is, 
if expression has a nonzero 
value), the first statement is done. If it is &quot;false&quot; 
(expression is zero), and if there is 
an else part, the second statement is executed instead. The else 
part is optional; if it 
is omitted in a sequence of nested if's, the resulting ambiguity 
is resolved in the 
usual way by associating the else with the nearest previous 
else-less if. <p>

The switch statement provides a multiway branch depending on the 
value 
of an integer expression: <p>
 <PRE> 
     switch (expression){ 
           case const: 
                  code 
           case const: 
                  code 
           ... 
           default: 
                 code 
     } <p>
</PRE>  
The expression is evaluated and compared against the various 
cases, which are 
labeled with distinct integer constant values. If any case 
matches, execution 
begins at that point. If no case matches but there is a default 
statement, 
execution begins there; otherwise, no part of the switch is 
executed. <p>

The cases are just labels, and so control may flow from one case 
to the next. 
Although this permits multiple labels on cases, it also means 
that in general 
most cases must be terminated with an explicit exit from the 
switch (the break 
statement below). <p>

The switch construction is part of C's legacy from BCPL; it is so 
useful and 
so easy to provide that the lack of a corresponding facility of 
acceptable 
generality in languages ranging from Fortran through Algol 68, 
and even to Pascal 
(which does not provide for a default), must be considered a real 
failure of 
imagination in language designers. <p>

C provides three kinds of loops. The while is simply <p>
 <PRE> 
     while (expression) 
            statement <p>
 </PRE> 
The expression is evaluated; if it is true (nonzero), the 
statement is executed, 
and then the process repeats. When expression becomes false 
(zero), execution 
terminates. <p>

The do statement is a test-at-the-bottom loop: <p>
<PRE>  
     do 
         statement 
     while (expression); <p>
</PRE>  
statement is performed once, then expression is evaluated. If it 
is true, the loop 
is repeated; otherwise it is terminated. <p>

The for loop is reminiscent of similarly named loops in other 
languages, but 
rather more general. The for statement <p>
<PRE>  
     for (expr1;expr2;expr3) 
           statement <p>
</PRE>  
is equivalent to <p>
<PRE>  
     expr1; 
     while (expr2){ 
             statement 
             expr3; 
     } <p>
</PRE> 
Grammatically, the three components of a for loop are 
expressions. Any of the 
three parts can be omitted, although the semicolons must remain. 
If<i> expr1</i> or 
<i>expr3</i> is left out, it is simply dropped from the 
expansion. If the test, <i>expr2</i>, is 
not present, it is taken as permanently true, so <p>
<PRE>  
     for (;;){ 
           ... 
     } <p>
</PRE>  
is an &quot;infinite&quot; loop, to be broken by other means, for 
example 
by break, below. <p>
 
The &quot;for&quot; statement keeps the loop control components 
together and 
visible at the top of the loop, as in the idiomatic <p>
<PRE>  
     for (i = 0; i &lt; N; i = i + 1) <p>
</PRE>  
which processes the first N elements of an array, the analogue of 
the Fortran or 
PL/1 DO loop. The for is more general, however. The test is 
reevaluated on each 
pass through the loop, and there is no restriction on changing 
the variables 
involved in any of the expressions in the for statement. The 
controlling variable<i> i</i> 
retains its value regardless of how the loop terminates. And 
since the 
components of a for are arbitrary expressions, for loops are not 
restricted to arithmetic 
progressions. For example, the classic walk along a linked list 
is <p>
 <PRE> 
     for (p = top; p! = NULL; p = p -&gt; next) 
                 ...<p> 
 </PRE> 

There are two statements for controlling loops. The break 
statement, as 
mentioned, causes an immediate exit from the immediately 
enclosing while, 
for, do, and switch. The continue statement causes the next 
iteration of the 
immediately enclosing loop to begin. The statements break and 
continue are 
asymmetric, since continue does not apply to switch. <p>

Finally, C provides the oft-maligned goto statement. Empirically, 
goto's are 
not used much, at least not on our system. The operating system 
itself, for 
example, contains 98 goto statements in some 8300 lines; the 
PDP-11 C compiler, 
in 9660 lines, has 147. Essentially, all of these implement some 
form of branch 
to the top or bottom of a loop, or to error recovery code. <p>
<B> 
Operators and Expressions <p>
</B> 
C has been characterized as having a relatively rich set of 
operators. Some of 
these are quite conventional. For example, the basic binary 
arithmetic operators 
are +, -, *, and/. To these, C adds the modulus operator %: m%n 
is the 
remainder when <i>m</i> is divided by <i>n</i>.<p> 

Besides the basic logical or bitwise operators &amp; (bitwise 
AND) 
and I (bitwise OR), there are also the binary operators ^ 
(bitwise exclusive OR), 
&gt; &gt; (right shift), and &lt; &lt; (left shift), and the 
unary operator ~ (ones 
complement). These operators apply to all integers; C provides no 
special bit-string 
type. <p>

The relational operators are the usual &gt;, &gt;=, &lt;, &lt;=, 
== (equality 
test), and != (inequality test). They have the value 1 if the 
stated relation is 
true, 0 if not. <p>

The unary pointer operators * (for indirection) and &amp; (for 
taking the 
address) were described earlier. When y is such as to make the 
expressions &amp;*y or 
* &amp;y legal, either is just equal to y. Note that &amp; and * 
are used as both binary 
and unary operators (with different meanings).<p>

The simplest assignment is written =, and is used conventionally: 
the 
value of the expression on the right is stored in the object 
whose address is on 
the left. In addition, most binary operators can be combined with 
assignment by 
writing <p>
<PRE>  
     a op= b<p> 
</PRE>  
which has the effect of <p>
<PRE> 
     a = a op b<p>
</PRE> 
except that a is only evaluated once. For example, <p>
<PRE>  
     x += 3 <p>
</PRE>  
is the same as <p>
<PRE>  
     x = x + 3 <p>
</PRE>  
if x is just a variable, but <p>
<PRE>  
     p[i + j + 1] += 3 <p>
</PRE>  
adds 3 to the element selected from the array p, calculating the 
subscript only 
once, and, more importantly, requiring it to be written out only 
once. 
Compound assignment operators also seem to correspond well to the 
way we think; 
&quot;add 3 to x&quot; is said, if not written, much more 
commonly than &quot;assign x + 3 to 
x.&quot; <p>

Assignment expressions have a value, just like other expressions, 
and may 
be used in larger expressions. For example, the multiple 
assignment <p>
<PRE>  
      i = j = k = 0;<p> 
</PRE> 
is a by-product of this fact, not a special case. Another very 
common instance is 
the nesting of an assignment in the condition part of an if 
statement or a loop, 
as in <p>
<PRE>  
     while ((c = getchar())!= EOF)... <p>
</PRE>  
which fetches a character with the function getchar, assigns it 
to c, then tests 
whether the result is an end-of-file marker. (Parentheses are 
needed because the 
precedence of the assignment = is lower than that of the 
relational !=.) <p>

C provides two novel operators for incrementing and decrementing 
variables. The increment operator + + adds 1 to its operand; the 
decrement 
operator- -subtracts 1. Thus the statement<p> 
<PRE>  
     ++i;<p> 
</PRE>  
increments<i> i</i>. The unusual aspect is that + + and - - may 
be used either as 
prefix operators (before the variable, as in <i>+ +i</i>), or 
postfix (after the variable as 
in <i>i+ + </i>). In both cases, the effect is to increment i. 
But the expression <i>+ +i</i> 
increments i before using its value, while <i>i+ +</i> increments 
<i>i</i> after its value has 
been used. If<i> i</i> is 5, then <p>
<PRE>  
     x = i++;<p> 
</PRE>  
sets <i>x</i> to 5, but<p> 
<PRE>  
     x = ++i; <p>
</PRE>  
sets <i>x</i> to 6. In both cases,<i> i</i> becomes 6. <p>
 
For example: <p>
<PRE>  
     stack[i++] = ... ; <p>
</PRE>  
pushes a value on a stack stored in array stack indexed by i, 
whereas <p>
 <PRE> 
     ... = stack I--i];<p> 
 </PRE> 
retrieves the value and pops the stack. Of course, when the 
quantity 
incremented or decremented is a pointer, appropriate scaling is 
done, just as if the <i>1</i> 
were added explicitly: <p>
<PRE> 
 
     *stackp ++= ... ; 
     ... = *--stackp;<p> 
</PRE>  
are analogous to the previous example, this time using a stack 
pointer instead of 
an index.<p>
 
Tests may be combined with the logical connectives &amp;&amp; 
(AND), | | (OR), 
and ! (truth value negation). The &amp;&amp; and | | guarantee 
left-to-right evaluation, 
with termination as soon as the truth value is known. For 
example, in the test <p>
<PRE>  
     if (i &lt;= N &amp;&amp; array[i] &gt; 0 ... <p>
</PRE>  
if <i>i</i> is greater than N, then <i>array[i]</i> (presumably 
at that point an out-of-bounds 
reference) will not be accessed. This predictable behavior is 
especially 
convenient, and much preferable to the explicitly random order of 
evaluation 
promised by most other languages. Most C programs rely heavily on 
the properties of 
&amp;&amp; and | |. <p>

Finally, the conditional expression, written with the ternary 
operator ?:, 
provides an analogue of if-else in expressions. In the expression 
<p>
<PRE>  
     e1 ? e2 : e3<p> 
</PRE>  
the expression <i>el</i> is evaluated first. If it is nonzero 
(true), then the expression e2 
is evaluated, and that is the value of the conditional 
expression. Otherwise, <i>e3</i> is 
evaluated, and that is the value. Only one of <i>e2</i> and <i>e3
</i> is evaluated. Thus to set 
<i>z</i> to the maximum of <i>a </i>and <i>b</i>, <p>
<PRE>  
     z = (a &gt; b) ? a : b; /* z = max(a, b) */<p> 
</PRE>  
We have already discussed how integers are scaled appropriately 
in pointer 
arithmetic. C does several other automatic conversions between 
data types, 
more freely than Pascal, for example, but without the wild 
abandon of PL/1. In 
all contexts, char variables and constants are promoted to int. 
This is 
particularly handy in a code such as <p>
<PRE>  
     n = c - '0';<p> 
</PRE>  
which assigns to n the integer value of the character stored in 
c, by subtracting 
the value of the character '0'. Generally, the basic types fall 
into only two 
classes, integral and floating-point; char variables, and the 
various lengths of 
int's, are taken to be representations of the same kind of thing. 
They occupy 
different amounts of storage, but are essentially compatible. 
Boolean values as 
such do not exist; relational or truth-value expressions have 
value 1 if true, 0 if 
false. <p>

Variables of type int are converted to floating-point when 
combined with 
floats or doubles and in fact all floating arithmetic is carried 
out in double 
precision, so floats are widened to double in expressions. <p>

Conversions that involve &quot;narrowing' an expression (for 
example, when a 
longer value is assigned to a shorter) are also well behaved. 
Foating-point values 
are converted to integer by truncation; integers convert to 
shorter integers or 
characters by dropping high-order bits. <p>

When a conversion is desired, but is not implicit in the context, 
it is 
possible to force a conversion by an explicit operator called a 
cast. The expression <p>
 
     <i>(type) expression</i> <p>
 
is a new expression whose type is that specified in type. For 
example, the sin 
routine expects an argument of type double; in the statement <p>
<PRE>  
     x = sin((double)n); <p>
</PRE>  
the value of <i>n</i> is converted to double before being passed 
to <i>sin</i>. <p>
<B>
Structure of Programs<p> 
</B> 
Complete programs consist of one or more files containing 
function and data 
declarations. Thus, syntactically, a program is made up of a 
sequence of 
declarations; executable code appears inside functions. 
Conventionally, the runtime 
system arranges to call a function named main to start execution. 
<p>

The language distinguishes the notions of declaration and 
definition. A 
declaration merely announces the properties of a variable (such 
as its type); a 
definition declares a variable and also allocates storage for it 
or, in the case of a 
function, supplies the code.<p> 
<B>
Functions<p> 
</B> 
The notion of function in C includes the subroutines and 
functions of Fortran 
and the procedures of most other languages. A function call is 
written <p>
 
     <i>name(arglist)</i> <p>
 
where the parentheses are required even if the argument list is 
empty. All 
functions may be used recursively. <p>

Arguments are passed by value, so the called function cannot in 
any way 
affect the actual argument with which it was called. This permits 
the called 
program to use its formal arguments as conveniently initialized 
local variables. 
Call by value also eliminates the class of errors, familiar to 
Fortran programmers, 
in which a constant is passed to a subroutine that tries to alter 
the 
corresponding argument. An array name as an actual argument, 
however, is converted to a 
pointer to the first array element (as it always is), so the 
effect is as if arrays 
were called by reference; given the pointer, the called function 
can work its will 
on the individual elements of the array. When a function must 
return a value 
through its argument list, an explicit pointer may be passed, and 
the function 
references the ultimate target through this pointer. For example, 
the function 
swap(px, py) interchanges two integers pointed to by its 
arguments: <p>
<PRE>  
     swap(px,py)               /* flip int's 
                               pointed to by px and py */. 
     int *px, *py; 
     int temp; 
     { 
       temp = *px; 
       *px = *py; 
       *py = temp; 
     }<p> 
</PRE>  
This also demonstrates the form of a function definition: the 
name is followed 
by an argument list; the arguments are declared, and the body of 
the function is 
a block, or compound statement, enclosed in braces. Declarations 
of local 
variables may follow the opening brace. <p>
 
A function returns a value by <p>
 
     <i>return expression;</i> <p>
 
The expression is automatically coerced to the type that the 
function returns. 
By default, functions are assumed to return int; if this is not 
the case, the 
function must be declared both in the calling routine and when it 
is defined. For 
example, a function definition is <p>
<PRE> 
     double sqrt(x)             / *returns square root of x */ 
     double x; 
     { 
          ... 
     }<p> 
</PRE>  
In the caller, the declaration is <p>
 <PRE> 
     double y, sqrt(); 
 
     y = sqrt(y); 
 </PRE> 
A function argument may be any of the basic types or a pointer, 
but not an 
array, structure, union, or function. The same is true of the 
value returned by a 
function. (The most recent versions of the language, still not 
standard 
everywhere, permit structures and unions as arguments and values 
of functions, and 
allow them to be assigned.) <p>
<B>
Data<p> 
</B>
Data declared at the top level (that is, outside the body of any 
function 
definition) is static in lifetime, and exists throughout the 
execution of the program. 
Variables declared within a function body are by default 
automatic: they come 
into existence when the function is entered and vanish when it is 
exited. 
Automatic variables may be declared to be register variables; 
when possible they will 
be placed in machine registers, which may result in smaller, 
faster code. The 
register declaration is only considered a hint to the compiler; 
no hardware 
register names are mentioned, and the hint may be ignored if the 
compiler wishes. <p>

Static variables exist throughout the execution of a program, and 
retain 
their values across function calls. Static variables may be local 
to a function or 
(if defined at the top level) common to several functions. <p>

External variables have the same lifetime as static, but they are 
also 
accessible to programs from other source files. That is, all 
references to an identically 
named external variable are references to the same thing.<p>
 
The &quot;storage class&quot; of a variable can be explicitly 
announced in its 
declaration:<p> 
<PRE> 
     static int x; 
     extern double y[10]; <p>
</PRE>  
More often the defaults for the context are sufficient. Inside a 
function, the 
default is auto (for automatic). Outside a function, at the top 
level, the default 
is extern. Since automatic and register variables are specific to 
a particular call 
of a particular function, they cannot be declared at the top 
level. Neither 
top-level variables nor functions explicitly declared static are 
visible to functions 
outside the file in which they appear.<p> 
<B>
Scope<p> 
</B> 
Declarations may appear either at the top level or at the head of 
a block 
(compound statement). Declarations in an inner block temporarily 
override those of 
identically named variables outside. The scope of a declaration 
persists until the 
end of its block, or until the end of the file, if it was at the 
top level. <p>

Since function definitions may be given only at the top level 
(that is, they 
may not be nested), there are no internal procedures. They have 
been forbidden 
not for any philosophical reason, but only to simplify the 
implementation. It 
has turned out that the ability to make certain functions and 
data invisible to 
programs in other files (by explicitly declaring them static) is 
sufficient to 
provide one of their most important uses, namely hiding their 
names from other 
functions. (However, it is not possible for one function to 
access the internal 
variables of another, as internal procedures could do.) 
Similarly, the ability to 
conceal functions and data in one file from access by another 
satisfies some of 
the most crucial requirements of modular programming (as in 
languages such as 
Alphard, CLU, and Euclid), even though it does not satisfy them 
all.<p> 
<B> 
C Preprocessor <p>
</B> 
It is well recognized that the &quot;magic numbers&quot; in a 
program are a sign of bad 
programming. Most languages, therefore, provide a way to define 
the symbolic 
names for constants, so that the value of a magic number need be 
specified in 
only one place, and the rest of the code can refer to the value 
by some 
mnemonic name. In C such a mechanism is available, but it is not 
part of the syntax 
of the language; instead, symbolic naming is provided by a macro 
preprocessor 
automatically invoked as part of every C compilation. For 
example, given the 
definitions <p>
<PRE>  
     #define        P1      3.14159 
     #define        E       2.71284 <p>
</PRE>  
the preprocessor replaces all occurrences of a defined name by 
the 
corresponding defining string. (Uppercase names are normally 
chosen to emphasize that 
these are not variables.) Thus, when the programmer recognizes 
that he or she 
has written an incorrect value for E, only the definition line 
has to be changed 
to <p>
<PRE> 
     #define     E     2.71828 <p>
</PRE>  
instead of each instance of the constant in the program. <p>

Providing this service by a macro preprocessor instead of by 
syntax has 
some significant advantages. The replacement test is not 
restricted to being 
numbers; any string of characters is permitted. Furthermore, the 
token being 
replaced need not be a variable, although it must have the form 
of a name. For 
example, we can define <p>
<PRE>  
     #define     forever     (for;;)<p> 
</PRE>  
and then write an infinite loop as <p>
<PRE>  
     forever   { 
           ... 
     } <p>
</PRE>  
The macro preprocessor also permits macros to have arguments; 
this capability 
is heavily used by some I/O packages. <p>

A second service of the C macro preprocessor is library file 
include; a 
source line of the form <p>
<PRE> 
     #include     &quot;name&quot; <p>
</PRE>  
causes the contents of the filename to be interpolated into the 
source at that 
point (includes may be nested). This feature is much used, 
especially in larger 
programs, for making sure that all the source files of the 
program are supplied 
with identical <i>#define</i>s, global data declarations, and the 
like. <p>
<B> 
Environmental Considerations <p>
</B> 
By intent, the C language confines itself to facilities that can 
be mapped 
relatively efficiently and directly into machine instructions. 
For example, writing 
matrix operations that look exactly like scalar operations is 
possible in some 
programming languages and occasionally misleads programmers into 
believing 
that matrix operations are as cheap as scalar operations. More 
important, 
restricting the domain of the C compiler to those areas where it 
knows how to do 
a relatively efficient job provides the freedom to design 
subroutine libraries for 
the remaining tasks without constraining them to fit into some 
language 
specification. When the compiler cannot implement some facility 
without heavy costs 
in nonportability, complexity, or efficiency, there are many 
benefits to leaving 
out such a facility: it simplifies the language and the compiler, 
frequently 
without inconveniencing users (who often reject a high-cost 
built-in operation and 
do it themselves anyway).<p>

At present, C is restricted to simple operations on simple data 
types. As a 
result, although the C area of operation is comparatively clean 
and pleasant, 
users must know something about the polluting effects of the 
environment to 
get most jobs done. A program can always access the raw system 
calls on each 
system, if very close interaction with the operating system is 
needed, but 
standard library routines have been implemented in each C 
environment that try to 
encourage portability while retaining speed and flexibility. The 
basic areas 
covered by the standard library at present are storage 
allocation, string handling, 
and I/O. Additional libraries and utilities are available for 
such areas as 
graphics, coroutine sequencing, execution time monitoring, and 
parsing. 

<p>The only automatic storage management service provided by C 
itself is the 
stack discipline for automatic variables. Two subroutines exist 
for more flexible 
storage handling. The function <i>calloc(n,s)</i> returns a 
pointer to a properly aligned 
storage block that will hold <i>n</i> items each of which is <i>s
</i> bytes long. Normally <i>s</i> is 
obtained from the sizeof pseudo-function, a compile-time function 
that yields 
the size in bytes of a variable or data type. To return a block 
obtained from 
calloc to the free storage pool, <i>cfree(p)</i> may be called, 
where <i>p</i> is a value 
returned by a previous call to <i>calloc</i>.<p>
 
Another set of routines deals with string handling. There is no 
&quot;string&quot; data 
type, but an array of characters, with a convention that the end 
of a string is 
indicated by a null byte, can be used for the same purpose. The 
most commonly 
used string routines perform the functions of copying one string 
to another, 
comparing two strings, and computing a string length. More 
sophisticated string 
operations can often be performed using the I/O routines, which 
are described 
next. <p>

Most of the routines in the standard library deal with input and 
output. 
Most C programmers use stream I/O, although there is no reason 
why record 
I/0 could not be used with the language. There are three default 
streams: the 
standard input, the standard output, and the error output. The 
most elementary 
routines for dealing with these streams are getchar(), which 
reads a character 
from the standard input, and <i>putchar(c)</i>, which writes the 
character c on the 
standard output. In the environments in which C programs run, it 
is generally 
possible to redirect these streams to files or other programs; 
the program itself 
does not change and is unaware of the redirection. <p>

The most common output data function is <p>
<PRE> 
     printf(format, data1, data2,...) <p>
</PRE>  
which performs data conversion for formatted output. The string 
format is 
copied to the standard output, except that when a conversion 
specification 
introduced by a % character is found in format it is replaced by 
the value of the next 
data argument, converted according to the specification. For 
example, <p>
<PRE> 
     printf(&quot;n = %d, x = %f&quot;, n, x); <p>
</PRE>  
prints <i>n</i> as a decimal integer and <i>x</i> as a 
floating-point number, as in <p>
<PRE>  
     n = 17, x = 12.34<p> 
</PRE>  
A similar function scanf performs formatted input conversion. <p>

All the routines mentioned have versions that operate on streams 
other 
than the standard input or output, and printf and scanf variants 
may also 
process a string, to allow for in-memory format conversion. Other 
routines in the 
I/0 library transmit whole lines between memory and files, and 
check for error 
or end-of-file status. <p>

Many other routines and utilities are used with C, somewhat more 
on Unix 
than on other systems. As an example, it is possible to compile 
and load a C 
program so that when the program is run, data is collected on the 
number of 
times each function is called and how long it executes. This 
profile pinpoints 
the parts of the program that dominate the run time. <p>

<B>
Experience with C <p>
</B> 
Compilers exist for the most widely used machines at Bell 
Laboratories (the IBM 
S/370, Honeywell 6000, PDP-11) and perhaps ten others. Several 
hundred 
programmers within Bell Laboratories and many outside use C as 
their primary 
programming language. <p>
<B> 
Favorable Experiences<p> 
</B> 
C has completely displaced assembly language in Unix programs. 
All application 
code, the C compiler itself, and the operating system (except for 
about 1000 
lines of initial bootstrap, and so on) are written in C. Although 
compilers or 
interpreters are available under Unix for Fortran, Pascal, Algol 
68, Snobol, APL, 
and other languages, most programmers make little use of them. 
Since C is a 
relatively low-level language, it is adequately efficient to 
prevent people from 
resorting to assembler, and yet sufficiently terse and expressive 
that its users 
prefer it to PL/1 or other very large languages. <p>

A language that does not have everything is actually easier to 
program in 
than some that do. The limitations of C often imply shorter 
manuals and easier 
training and adaptation. Language design, especially when done by 
a committee, 
often tends toward including all doubtful features, since there 
is no quick 
answer to the advocate who insists that the new feature will be 
useful to some and 
can be ignored by others. This results in long manuals and 
hierarchies of 
&quot;experts&quot; who know progressively larger subsets of the 
language. In practice, if a 
feature is not used often enough to be familiar and does not 
complete some 
structure of syntax or semantics, it should probably be left out. 
Otherwise, the 
manual and compiler get bulky, the users get surprises, and it 
becomes harder 
and harder to maintain and use the language. It is also desirable 
to avoid 
language features that cannot be compiled efficiently; 
programmers like to feel that 
the cost of a statement is comparable to the difficulty in 
writing it. C has thus 
avoided implementing operations in the language that would have 
to be 
performed by subroutine call. As compiler technology improves, 
some extensions 
(such as structure assignment) are being made in C, but always 
with some 
principles in mind. <p>

One direction for possible expansion of the language has been 
explicitly 
avoided. Although C is much used for writing operating systems 
and associated 
software, there are no facilities for multiprogramming, parallel 
operations, 
synchronization, or process control. We believe that making these 
operations 
primitives of the language is inappropriate, mostly because 
language design is hard 
enough in itself without incorporating into it the design of 
operating systems. 
Language facilities of this sort tend to make strong assumptions 
about the 
underlying operating system that may match very poorly what it 
actually does. <p>
<B> 
Unfavorable Experiences <p>
</B> 
The design and implementation of C can (or could) be criticized 
on several 
points. Here we discuss some of the more vulnerable aspects of 
the language.<p> 
 
Language Level. Some users complain that C is an insufficiently 
high-level 
language; for example, they want string data types and 
operations, or 
variablesize multidimensional arrays, or generic functions. 
Sometimes a suggested 
extension merely involves lifting some restriction. For example, 
allowing 
variablesize arrays would actually simplify the language 
specification, since it would 
only involve allowing general expressions in place of constants 
in certain 
contexts. <p>

Many other extensions are plausible; since the low level of C was 
praised in 
the previous section as an advantage of the language, most will 
not be further 
discussed. One is worthy of mention, however. The C language 
provides no 
facility for I/0, leaving this job to library routines. The 
following fragment 
illustrates one difficulty with this approach: <p>
<PRE>  
     printf( &quot;%d\n&quot;,x);<p> 
</PRE>  
The problem arises on machines on which int is not the same as 
long: x may 
not be long; if it were, the program must be written <p>
<PRE>  
     printf(&quot;%ld\n&quot;,x);<p> 
</PRE>  
so as to tell printf the length of <i>x</i>. Thus, changing the 
type of x involves 
changing not only its declaration, but also other parts of the 
program. If I/O were built 
into the language, the association between the type of an 
expression and the 
format in which it is printed could be reconciled by the 
compiler. <p>
 
Type Safety. C has traditionally been permissive in checking 
whether an 
expression is used in a context appropriate to its type. A 
complete list of 
examples would be long, but two of the most important should 
illustrate sufficiently. 
The types of formal arguments of functions are in general not 
known, and in 
any case are not checked by the compiler against the actual 
arguments at each 
call. Thus in the statement <p>
<PRE>  
     s = sin(1) <p>
</PRE>  
the fact that the sin routine takes a floating-point argument is 
not noticed until 
the erroneous result is detected by the programmer. <p>
 
In the structure reference <p> 
<PRE>  
     p-&gt;memb <p>
</PRE>  
<i>p</i> is simply assumed to point to a structure of which memb 
is a member; <i>p</i> 
might even be an integer and not a pointer at all. 

Much of the explanation, if not justification, for such laxity is 
the typeless 
nature of C's predecessor languages. Fortunately, a justification 
need no longer 
be attempted, since a program is now available that detects all 
common type 
mismatches. This utility, called lint because it picks bits of 
fluff from programs, 
examines a set of files and complains about a great many dubious 
constructions, 
ranging from unused or uninitialized variables through the type 
errors 
mentioned. Programs that pass unscathed through lint seemingly 
enjoy freedom 
from type errors to the same degree as do Algol 68 programs, with 
a few 
exceptions: unions are not checked dynamically, and explicit 
escapes are available 
that in effect turn off checking. <p>

Some languages, such as Pascal and Euclid, allow the writer to 
specify that 
the value of a given variable may assume only a given subrange of 
the integers. 
This facility is often connected with the usage of arrays, in 
that any array index 
must be a variable or expression whose type specifies a subset of 
the set given by 
the bounds of the array. This approach is not without theoretical 
difficulties, as 
suggested by Habermann (1973). In itself it does not solve the 
problems of 
variables assuming unexpected values or of accessing outside 
array bounds; such 
things must (in general) be detected dynamically. Still, the 
extra information 
provided by specifying the permissible range for each variable 
provides valuable 
information for the compiler and any verifier program. C has no 
corresponding 
facility. <p>

One of the characteristic features of C is its rather complete 
integration of 
the notion of pointer and of address arithmetic. Some writers, 
notably Hoare 
(1975), have argued against the very notion of pointer. We feel, 
however, that 
the facilities offered by pointers are too valuable to give up 
lightly. <p>
 
Syntax Peculiarities. Some people are annoyed by the terseness of 

expression that is one of the characteristics of the language. We 
view C's short 
operators and general lack of noise as a benefit. For example, 
the use of braces {} for 
grouping instead of begin and end seems appropriate in view of 
the frequency of 
the operation. The use of braces even fits well into ordinary 
mathematical 
notation. <p>

Terseness can lead to code that is hard to read, however. For 
example, <p>
<PRE>  
     *++*argv <p>
</PRE>  
where <i>argv</i> has been declared <i>char **argv</i> (pointer 
to an array of character 
pointers) means: select the character pointer pointed at by <i>
argv (*argv)</i> 
increment it by one <i>(+ +*argv)</i>, then retrieve the 
character that that pointer points 
at <i>(*+ +*argv)</i>. This is concise and efficient but 
reminiscent of APL. <p>
 
An example of a minor problem is the comment convention, which is 

PL/l's/*...*/. Comments do not nest, so an effort to 
&quot;comment out&quot; a section 
of code will fail if that section contains a comment. And several 
of us can testify 
that it is surprisingly hard to recognize when an &quot;end 
comment&quot; delimiter has 
been botched, so that the comment silently continues until the 
next comment 
is reached, deleting a line or two of code. It would be more 
convenient if a single 
unique character were reserved to introduce a comment, and if 
comments were 
always terminated at an end of line. <p>
 
Semantic Peculiarities. There are some occasionally surprising 
operator 
precedences. For example,<p> 
<PRE> 
     a &gt;&gt; 4 + 5 <p>
</PRE> 
shifts right by 9. Perhaps worse, <p>
<PRE> 
     (x &amp; MASK) == 0 <p>
</PRE> 
must be parenthesized to associate the proper way. Users learn 
quickly to 
parenthesize such doubtful cases; and when feasible, lint warns 
of suspicious 
expressions (including both of these). <p>

We have already mentioned the fact that the case actions in a 
switch flow 
through, unless explicitly broken. In practice, users write so 
many switch 
statements that they become familiar with this behavior, and some 
even prefer it. <p>

Some problems arise from machine differences that are reflected, 
perhaps 
unnecessarily, onto the semantics of C. For example, the PDP-11 
does sign 
extension on byte retrieves, so that a character (viewed 
arithmetically) can have a 
value ranging from - 128 to + 127, rather than 0 to + 255. 
Although the 
reference manual makes it quite clear that the precise range of a 
char variable is 
machine dependent, programmers occasionally succumb to the 
temptation of 
using the full range that their local machine can represent, 
forgetting that their 
programs may not work on another machine. The fundamental 
problem, of 
course, is that C permits small numbers, as well as genuine 
characters, to be 
stored in char variables. This might not be necessary if, for 
example, the notion 
of subranges (explained above) were introduced into the language. 
<p>
 
Miscellaneous. C was developed and is generally used in a highly 
responsive interactive environment, and accordingly the compiler 
provides few of the 
services usually associated with batch compilers. For example, it 
prepares no 
listing of the source program, no cross-reference table, and no 
indication of the 
nature of the generated code. Such facilities are available, but 
they are separate 
programs, not parts of the compiler. Programmers used to batch 
environments 
may find it hard to live without giant listings; we would find it 
hard to use 
them.<p> 
<B> 
Conclusions and Future Directions<p> 
</B> 
C has continued to develop in recent years, mostly by upwardly 
compatible 
extensions, occasionally by restrictions against manifestly 
nonportable or illegal 
programs that happened to be compiled into something useful. The 
most recent 
major changes were motivated by the extension of C to other 
machines, and the 
resulting emphasis on portability. The advent of union, and of 
casts reflects a 
desire to be more precise about types, when using other machines 
becomes a 
prospect. These changes have had relatively little effect on 
programmers who 
remained entirely on the Unix system. Of more importance was a 
new library, 
that changed the use of a &quot;portable&quot; library from an 
option into an effective 
standard, while increasing the efficiency of the library so that 
users would not 
object. <p>

It is more difficult, of course, to speculate about the future. C 
is now 
encountering more and more foreign environments, and this is 
producing many 
demands for C to adapt itself to the hardware, and particularly 
to the operating 
systems, of other machines. Bit fields, for example, are a 
response to a request to 
describe externally imposed data layouts. Similarly, the 
procedures for external 
storage allocation and referencing have been made tighter to 
conform to 
requirements on other systems. Portability of the basic language 
seems well 
handled, but interactions with operating systems grow ever more 
complex. These 
lead to requests for more sophisticated data descriptions and 
initializations, and 
even for assembler windows. Further changes of this sort are 
likely. <p>

What is not likely is a fundamental change in the level of the 
language. 
Realistically, the very acceptance of C has compelled changes to 
be made only 
most cautiously and compatibly. Should the pressure for 
improvements become 
too strong for the language to accommodate, C would probably have 
to be left as 
is, and a totally new language developed. We leave it to the 
reader to speculate 
on whether it should be called D or P. <p>
<B>
References<p> 
</B> 
     Habermann, A. N., 1973. &quot;Critical Comments on the 
Programming 
Language Pascal.&quot; <i>Acta Informatica</i>, 3, pp. 47-58. <p>
     Hoare, C. A. R., 1975. &quot;Data Reliability.&quot; <i>ACM 
SIGPLAN Notices</i>, 10 
(June), pp. 528-533. <p>
     Johnson, S.C., and Kernighan, B. W., 1973. &quot;The 
Programming Language B.&quot; 
C<i>omputer Science Tech Report No. 8</i>, Bell Laboratories 
(January). <p>
     Kernighan, B. W., and Ritchie, D. M., 1978. <i>The C 
Programming Language</i>. 
Englewood Cliffs, N.J.: Prentice-Hall. <p>
     Richards, M., 1969. &quot;BCPL: A Tool for Compiler Writing 
and Systems 
Programming.&quot; <i>Proceedings AFIPS SJCC</i>, 34, pp. 
557-566.<p> 
 
<P>
<CENTER> Return to <a href="../toc.htm">Table of Contents
</a>
</CENTER>
<P>
</HTML> 

