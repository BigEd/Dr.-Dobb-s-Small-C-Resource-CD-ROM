<HTML>
<!--
 	Dr. Dobb's Small C Resource CD-ROM Compilation (c) 1997 Dr. 
Dobb's Journal, M&T Publishing, Inc., a subsidiary of Miller 
Freeman, Inc. All rights reserved.
-->
<CENTER>
<B><H1>SMALL-MAC: AN ASSEMBLER FOR SMALL-C</H1> <p>
by J. E. Hendrix<p>
</CENTER>
</B>


<i>This article was adapted from the Small-Mac manual.</i> <p>
 
Small-Mac is a macro assembler designed primarily for use on the 
8080/Z80 
machines under CP/M. It was created as a companion for the 
Small-C compiler 
(see &quot;Small-C Version 2&quot; on this CD-ROM). As such, it 
was designed to appeal to 
Small-C users by stressing simplicity, portability, adaptability, 
and educational 
value. Program size and execution speed were considered less 
important than 
these primary goals. Therefore, like the compiler, Small-Mac was 
written in 
Small-C and is being distributed in both source and object 
formats. <p>

The salient features of the Small-Mac package are: <p>
<UL> 
<LI> Ease of use 
<LI> Simplified macro facility 
<LI> C-language expression operators 
<LI> Descriptive error messages 
<LI> Object file visibility 
<LI> Externally defined machine instruction table. <p>
</UL> 
The following programs are included in the Small-Mac package: <p>
<UL> 
<LI>     MAC  ---     macro assembler 
<LI>     LNK  ---     linkage editor 
<LI>     LGO  ---     load-and-go loader 
<LI>     LIB  ---     library manager 
<LI>     CMIT ---     CPU configuration utility 
<LI>     DREL ---     dump relocatable files <p>
</UL> 
MAC is a two-pass, table driven, relocatable, macro assembler. It 
&quot;learns&quot; the 
target machine from a machine instruction table (MIT), that is 
created with a 
text editor and compiled with the CMIT configuration utility. 
Small-Mac 
generates relocatable object modules in the 8-bit Microsoft 
format, and is invoked 
with a simple command syntax. <a href="#list7-1">Listing 7-1</a> 
contains the source code for MAC.<p>
 
LNK is the Small-Mac linkage editor. It combines object modules 
with 
modules from libraries into a complete executable program. The 
default output is a 
standard .COM file. However, it can generate a load-and-go (.LGO) 
file for 
execution at any desired address. <a href="#list7-2">Listing 7-2
</a> contains the source code for LNK. <p>

LGO loads and optionally executes .LGO files. It is most useful 
for loading 
system extensions after you have booted the operating system. <a 
href="#list7-3">Listing 7-3</a> 
contains the source code for LGO. <p>

LIB builds, maintains, and lists the contents of LNK compatible 
libraries. 
This facility enables you to assemble modules that are common to 
various 
programs, gather them into a single library, and then have LNK 
search the library 
for just those modules needed by the program being linked. <a 
href="#list7-4">Listing 7-4</a> contains 
the source code for LIB. <p>

CMIT compiles machine instruction tables, lists them, and 
optionally 
configures the assembler with the resulting object table. This 
approach to defining 
the machine instructions to the assembler provides a great deal 
of flexibility in 
adapting the assembler to different CPUs and in creating 
specialized instruction 
sets without incurring the overhead of macro processing. <a 
href="#list7-5">Listing 7-5</a> contains 
the source code for CMIT. <p>

DREL produces a formatted dump of .REL and .LIB files. This makes 
it 
possible to study the contents of these files even though they 
are structured as a 
continuous stream of bit fields. <a href="#list7-6">Listing 7-6
</a> contains the source code for DREL. <p>

<a href="#list7-7">Listing 7-7</a> contains the source code for 
functions common to several of 
these programs. <p>
<B> 
System Requirements <p>
</B> 
The implementation of the Small-Mac package runs on 8080/8085/Z80 

machines using the CP/M-80 operating system. You should have two 
diskette 
drives and at least 56K of memory.<p> 
<B> 
Concepts and Facilities <p>
</B>
<B>
Source Files<p> 
</B> 
Source lines have a free field format, with fields appearing in 
the following order 
on each line;<p> 
<PRE> 
     symbol/label operation operand comment <p>
</PRE> 
Each field is optional, and null lines are ignored. Fields are 
separated by 
white space (spaces and tabs), except that comments are prefixed 
by a 
semicolon (;). <p>
<B> 
The Symbol/Label Field <p>
</B> 
A symbol consists of a contiguous sequence of letters, digits, 
and any of the 
special characters _. $ ? or @. The first character must not be a 
digit. Uppercase 
and lowercase letters are equivalent. Symbols may be any length, 
but only the 
first eight characters are significant, and only six characters 
are used for 
declaring external references and entry points in object modules. 
<p>

Labels in the symbol/label field are always terminated with a 
colon (:). 
They may appear alone or followed by an instruction and/or 
comments. 
The address assigned to the label is the address of the first 
byte of the next 
instruction or data item. Two colons following a label declare it 
to be an 
entry point. References to labels and nonlabel symbols must not 
be 
terminated with colons. <p>
<B> 
The Operation Field <p>
</B> 
If no label or symbol precedes an operation code (op-code) or 
assembler 
directive (pseudo-op), then the operation field may begin in the 
first character 
position. The pseudo-ops are defined within the assembler, but 
the machine 
instruction op-codes are defined in an external machine 
instruction table, 
which is compiled into internal format and placed into the 
assembler by the 
configuration utility CMIT. <p>
<B> 
The Operand Field<p> 
</B> 
Operands and/or operand locations (memory addresses or register 
names) are 
specified in the operand field.<p>
 
Symbols in the operand field must either be defined elsewhere or 
be 
declared to be external. This is done by terminating them with a 
pair of number 
signs (#) or by using the EXT directive. <p>

The dollar sign $ may be used in the operand field as an implied 
reference 
to the address of the current instruction. <p>

Memory references and numeric values may be written as 
expressions. 
Small-Mac expression operators are a subset of those in the C 
language and 
follow the same precedence and grouping rules. This gives the 
C/assembly 
programmer just one set of rules to learn. For more about 
expressions, see 
Expressions below. <p>
<B> 
Comments<p> 
</B> 
Comments may appear as the last field on any line. A semicolon 
(;) introduces 
comments. A line may consist entirely of comments by specifying a 
semicolon 
as the first graphic character. White space is not necessary 
before a comment. 
<B> 
Object Files <p>
</B> 
There are two kinds of Small-Mac object files: modules and 
libraries. Modules 
are created by the assembler and always have a .REL filename 
extension. 
Libraries are created by the library manager and consist of a 
pair of files: the library 
itself (.LIB extension) and an index into the library (.NDX 
extension).<p>
 
Small-Mac object modules are relocatable and follow the 8-bit 
Microsoft 
format. This is a bit field format intended to reduce the size of 
object files. 
There is no byte alignment except at the beginning of a module. 
The bit fields 
are listed in Table 7-1.<p>

The order of the items in a module is: <p>
<OL> 
<LI> program name 
<LI> entry symbols (unordered) 
<LI> program area size 
<LI> body of module
     <UL>
     <LI>   absolute items 
     <LI>   program-relative items 
     <LI>   external reference increments 
     <LI>   set location counter items 
     </UL>
<LI> list (in alphanumeric sequence) of 
      <UL>
      <LI>  external reference chains 
      <LI>  entry points 
      </UL>
<LI> end of program 
<LI> end of file 
</OL> 
A library is just the concatenation of a collection of modules, 
except that there 
is only one end-of-file item. A library index is merely a series 
of 16-bit word 
pairs pointing to the beginning of each module in the library. 
The first word 
specifies the 128-byte block and the second the byte in the 
block. Both begin at 
zero. <p>

Program-relative items may be addresses, data, or chain pointers. 
The end 
of a chain is indicated by an absolute item of value zero. All 
external references 
to a particular entry point are chained together so that the 
linker may find them 
and replace (resolve) them with the address of the matching entry 
point. If an 
external reference is included in an expression so that the 
result is an offset 
(negative or positive) from the reference, then an &quot;external 
reference 
increment&quot; item immediately precedes the chain link. This is 
added after resolving 
the reference. The &quot;increment&quot; item has no effect on 
the loading location 
counter. Small-Mac assembler listings show both the chain pointer 
and the 
increment value.<p> 
 
<CENTER>
<B> 
Table 7-1. Bit Fields in Small-Mac Modules <p>
</B>
</CENTER> 

<PRE>
LINK ITEM FORMAT                     DESCRIPTION              USED? 
 
0 &lt;8-bits&gt;                           absolute item                YES 
1000000 lll &lt;string&gt;                 entry symbol             YES 
1000001 lll &lt;string&gt;                 select common block          NO 
1000010 lll &lt;string&gt;                 program name                 YES 
1000011 lll &lt;string&gt;                 library to search            NO 
1000100 lll &lt;string&gt;                 extension link item        NO 
1000101 tt &lt;16-bits&gt; lll &lt;string&gt;    common area size             NO 
1000110 tt &lt;16-bits&gt; lll &lt;string&gt;    external reference chain     YES 
1000111 tt &lt;16-bits&gt; lll &lt;string&gt;    entry point             YES 
1001000 tt &lt;16-bits&gt;                 external reference decr.     NO 
1001001 tt &lt;16-bits&gt;                 external reference incr.     YES 
1001010 tt &lt;16-bits&gt;                 data area size            NO 
1001011 tt &lt;16-bits&gt;                 set location counter       YES 
1001100 tt &lt;16-bits&gt;                 location counter chain       NO 
1001101 tt &lt;16-bits&gt;                 program area size            YES 
1001110 tt &lt;16-bits&gt;                 end of module                YES 
1001111                              end of file                  YES 
101 &lt;16-bits&gt;                        program relative item       YES 
110 &lt;16-bits&gt;                        data relative item           NO 
111 &lt;16-bits&gt;                        common relative item       NO 
 
The lll field occupies 3 bits and specifies the string length. 
The tt field occupies 2 bits and specifies the type of 16-bit field that follows. The 
type codes are: 
 
     CODE          MEANING               USED? 
     00            absolute              YES 
     01            program relative      YES 
     10            data relative         NO 
     11            common                NO 
                   relative 
</PRE>
<B>
Machine Instructions <p>
</B> 
As mentioned above, machine instructions are defined in an 
external machine 
instruction table (MIT). This is an ASCII file that specifies the 
operation 
mnemonics, the operand syntax, and the object code for each 
machine instruction. 
The configuration utility CMIT compiles the table into internal 
format, then 
optionally lists it and/or plants a copy of it in the assembler. 
<p>

This approach to defining the machine instructions makes it much 
easier 
to adapt the assembler to other CPUs. It also makes it easy to 
create specialized 
instruction sets that are readily assembled without the overhead 
of macro 
processing. <p>

<a href="#list7-8">Listing 7-8</a> and <a href="#list7-9">Listing 
7-9</a> show the machine instruction tables for the 8080 and 
Z80 processors, respectively. Each line consists of three fields: 
object, 
mnemonic, and operand. White space separates the fields. <p>

Expression specifiers may appear in the operand and object 
fields. They 
indicate where in the operand syntax an expression may appear, 
and where in the 
object code the corresponding expression value is to be placed. 
Also specified is 
the size of the object value (one or two bytes), and whether or 
not it is a PC 
(program counter) relative value. Expression specifiers consist 
of the lowercase 
letter <i>x</i> or <i>p</i> and (in the object field) a digit 
indicating the number of bytes (one 
or two). The letter <i>x</i> indicates an ordinary expression 
value, and the letter <i>p</i> 
indicates a PC-relative value. Except for these specifiers, all 
other letters in the 
mnemonic and operand fields must be uppercase. <p>

In the compiled MIT, 16 bits are used to describe the format of 
the object 
code. Each code byte takes one bit in the format word, and each 
expression 
takes 3 bits. Therefore, any combination of code bytes and 
expressions may be 
generated as long as the number of format bits used does not 
exceed 16.<p>
 
Underscore characters are used between object components for 
legibility. 
The code bytes and expression values are generated in the order 
specified in the 
object field. If more than one expression is specified, the 
assembler places them 
in the object file in the same order as they appear in the 
operand field. <p>

To match an instruction to an entry in the MIT, the assembler 
performs a 
hash search for the mnemonic and then a serial search for the 
correct operand 
variant. The serial search proceeds in the order of the variants 
in the MIT. This 
works quite well for 8080 assembly language but rather poorly for 
the Z80, 
which has an obscene number of variants of some mnemonics (for 
example, 
LD). If you have an idea of the relative frequency of use of the 
operand variants, 
you may rearrange the order of the MIT to improve search time. 
But be warned 
that you must keep all the variants of a given mnemonic together. 
<p>

The use of vertical bars | in the MIT operand field is a 
space-saving device 
that is effective because of the redundancy of operand variants 
in most 
instruction sets and the tendency of CPU architects to assign 
object codes sequentially. 
The vertical bar separates operand variants specified on the same 
line. In such 
cases, the object byte that immediately precedes the first 
expression or comes 
last if there is no expression is understood to apply to the 
first variant. For each 
subsequent variant on the line, that byte is incremented by one. 
The other 
object bytes remain the same. <p>

If you plan to alter an MIT, it is most important that you 
understand how 
the assembler matches an expression with an expression specifier 
in the MIT 
operand field. For a detailed understanding, see the function <i>
match()</i> in the file 
MIT.C. Once the instruction mnemonic is found in the MIT, <i>
match()</i> is called 
to attempt a match on the correct operand variant. It compares 
characters from 
left to right, treating uppercase and lowercase the same. If a 
mismatch occurs 
that variant fails; if a match occurs then the next pair of 
characters is compared. 
When an <i>x</i> or <i>p</i> is found in the MIT operand field, 
the string beginning with the 
current instruction character is skipped until a comma or an 
unmatched right 
parenthesis is encountered. Unmatched, in this case, means 
unmatched while 
skipping the expression string. <p>

For instance, if the instruction &quot;LD A,((a+b)/2)&quot; is 
being matched with 
&quot;LD A,(x)&quot; then the second right parenthesis terminates 
the expression 
skipping because only the first right parenthesis is matched in 
the skipping process. 
So the string &quot;(a+b)/2&quot; is taken as the expression. 
This part of the instruction 
is extracted from the source line during the matching process and 
placed in a 
separate buffer for subsequent analysis. <p>

Now, what would happen if the instruction &quot;LD A,(x)&quot; 
appeared in the 
MIT before &quot;LD A,(HL)&quot; while the instruction &quot;LD 
A,(HL)&quot; was being 
assembled? That's right, &quot;HL&quot; would be taken for an 
expression and the instruction 
would erroneously match &quot;LD A,(x)&quot;. Therefore, take 
care to place such 
variants after any other variant that could match it. 
Incidentally, this error would 
no doubt produce an assembly error message. <p>
<B> 
Assembler Directives <p>
</B> 
Small-Mac supports the assembler instructions (pseudo-ops) listed 
in Table 7-2. 
This release of Small-Mac does not provide repeat pseudo-ops or 
conditional 
assembly.<p>

<CENTER>
<B>
Table 7-2. Pseudo-ops Supported by Small-Mac <p>
</B>
</CENTER>
<PRE> 
     SYNTAX                                   FUNCTION 
 
     [label] DW value[,value[,...]]           define words 
     [label] DB value[,value[,...]]           define bytes 
     [label] DS expr                          define storage 
     [label] EXT symbol[,symbol[,...]]        declare external references 
     symbol SET expr                          set symbol to expr 
     symbol EQU expr                          equate symbol to expr 
     [label] ORG expr                         set location counter to expr 
     [label] END [expr]                       end of source file 
                                              (expr gives starting address) 
     symbol MACRO                             begin a macro definition 
            ENDM                              end a macro definition 
     [label] macroname [par[,par[,...]]]      call (expand) the named macro<p> 
</PRE> 

In the pseudo-ops listed in Table 7-2, brackets enclose optional 
elements. 
The term value stands for either an expression or a character 
string. Character 
strings are enclosed in either apostrophes (') or quotes 
(&quot;). If you want an occurrence of the delimiter within the 
string, code two successive delimiters. The 
term <i>expr</i> stands for an expression. <p>
<PRE> 
     [label] DW value[,value[,...]] <p>
</PRE> 
<b>Define Words</b>: For each value in the operand field, the 
assembler reserves one 
word containing that value. If a label is specified, it assumes 
the address of the 
first word. <p>
<PRE> 
     [label] DB value[,value[,...]] <p>
</PRE> 
<b>Define Bytes</b>: For each value in the operand field, the 
assembler reserves one 
byte containing that value. Each value must be absolute. If a 
label is specified, it 
assumes the address of the first byte. <p>
<PRE> 
     [label] DS expr <p>
</PRE> 
<b>Define Storage</b>: The number of bytes of memory specified by 
the expression are 
reserved. They have no predictable value. The expression must 
yield an absolute 
value. If a label is specified, it assumes the address of the 
first byte. <p>
<PRE> 
     [label] EXT symbol[,symbol[,...]] <p>
</PRE> 
<b>Declare External References</b>: Each symbol is declared to be 
external. If a label is 
given, it assumes the address of the next instruction or data 
byte in the program. 
Note that declaring a symbol external is sufficient to cause the 
module 
containing it as an entry point to be loaded with the program by 
the linker. It need not 
actually be referenced.<p> 
<PRE> 
     symbol SET expr <p>
</PRE> 
<b>Set Symbol Value</b>: This pseudo-op &quot;sets&quot; the 
symbol to the value of the 
expression. The same symbol may be reset later by other SET 
pseudo-ops. Once a value 
is given to a symbol, it may be used in expressions.<p> 
<PRE> 
     symbol EQU expr <p>
</PRE> 
<b>Equate Symbol to Value</b>: This pseudo-op &quot;equates&quot; 
the symbol to the value of 
the expression. The same symbol may not be used with SET or EQU 
again. Once 
a value is given to a symbol, it may be used in expressions. <p>
<PRE> 
     [label] ORG expr <p>
</PRE> 
<b>Set Location Counter Origin</b>: This pseudo-op sets the 
origin for the assembler 
location counter. Small-Mac only allows forward movement of the 
location 
counter. This prevents programmers from overlapping old code with 
new and 
confusing the linker as it attempts to resolve external reference 
chains. <p>
<PRE> 
     [label] END [expr] <p>
</PRE> 
<b>End of Source File</b>: This pseudo-op designates the end of a 
source file. It is 
required, and it must be the last line of each source file. If a 
label is present, it 
assumes the program-relative address of the byte following the 
last byte 
assembled. If an expression is given, it must evaluate to a 
program-relative value, that 
the assembler takes as the starting address of the program. Only 
one starting 
address should be specified when a program is assembled from more 
than one 
source file. However, if more than one is given, the assembler 
will take the last 
one processed. If no starting address is given, execution will 
begin at the first 
instruction of the program. <p>

The starting address, if any, is included in the output object 
file. When the 
linker builds an executable program from several modules, it 
inserts in front of 
the program a jump to the starting address. If it encounters more 
than one 
module with a starting address, it uses the last one. <p>
<PRE> 
     symbol MACRO <p>
</PRE> 
<b>Begin a Macro Definition</b>: This pseudo-op signals the 
beginning of a macro 
definition. The symbol is required and gives the name of the 
macro. For more on 
macro processing, see The Macro Facility below. <p>
<PRE> 
     ENDM <p>
</PRE> 
<b>End a Macro Definition</b>: This pseudo-op signals the end of 
a macro definition. <p>
<PRE> 
     [label] macroname [par[,par[,...]]]<p> 
</PRE> 
<b>Call a Macro</b>: This pseudo-op is used to call (or expand) a 
macro. The label is 
optional. If given, it assumes the program-relative address of 
the first byte of the 
macro expansion. Macroname is the name given to the macro. Actual 

parameters are supplied in a comma-separated list in the operand 
field. Parameters are 
merely character sequences that replace corresponding 
substitution sentinels in 
the macro body. If spaces, commas, or semicolons are in a 
parameter, it must be 
delimited by quotes (&quot;) or apostrophes ('). Delimiters 
within such strings are 
written as two successive delimiters. Missing parameters are 
taken as null 
strings. Two successive commas indicate a missing parameter. A 
parameter is 
also missing if the parameter list does not go far enough to 
include it.<p> 
<B> 
Expressions <p>
</B> 
Expressions may appear in the operand field of certain machine 
instructions or 
pseudo-ops. For the proper placement of expressions in machine 
instructions, 
see the machine instruction tables in <a href="#list7-8">Listing 
7-8</a> and
<a href="#list7-9">Listing 7-9</a>. Expression evaluation 
always produces a 16-bit binary value. If the expression appears 
in the operand 
field of an instruction, its value is placed in the object file. 
If the instruction 
requires less than 16 bits, high order bits are truncated. 
Expressions in the DW 
and DB pseudo-ops likewise produce values in the object file.<p> 
<B> 
Relocation Rules <p>
</B> 
The value of an expression is either absolute or program 
relative, depending on 
whether and how symbols are used. <p>

Program-relative items in an object file are converted to 
absolute by the 
linker once it has determined the absolute address at which the 
module will 
reside, whereas absolute items are loaded without change. <p>

Recall that a label always has a program-relative value; that is, 
it 
assumes the program-relative address of the next assembled item 
in the 
program. But a numeric constant is absolute. The relocation 
attribute of an 
expression depends on the attributes of its primary terms and the 
way they 
are combined. Table 7-3 illustrates the rules for determining the 
relocation 
attribute of expressions. <p>

<CENTER>
<B>
Table 7-3. Rules for Determining the Relocation Attribute of 
Expressions <p>
</B>
</CENTER>

<PRE> 
  COMBINATION     RESULT 
 
  abs ? abs       abs 
  abs + rel       rel 
  abs ? rel       error 
  rel + abs       rel 
  rel - abs       rel 
  rel - rel       abs 
  rel == rel      abs 
  rel &lt; rel       abs 
  rel &lt; = rel     abs 
  rel != rel      abs 
  rel &gt; rel       abs 
  rel &gt; = rel     abs 
  rel ? rel       error <p>
</PRE>
 
A question mark in the list stands for any operator other than 
the ones 
explicitly shown for each combination of left- and right-hand 
attributes. <p>

Ordinarily, only 16-bit object fields take relocatable 
expressions. However, a 
relocatable expression may appear for a PC-relative field; that 
is, a field 
containing a signed offset that is added by the CPU to the 
program counter to obtain 
the effective address. The Z80 JR (jump relative) instruction is 
an example of 
PC-relative addressing. In such cases MAC takes the expression as 
the target 
address. It subtracts the location counter and the instruction 
length from the 
expression, converting it an absolute offset from the following 
instruction. But if 
the expression evaluates to an absolute value, MAC assumes the 
programmer 
means to give an offset from the current instruction; it 
therefore subtracts only 
the instruction length to account for the fact that the CPU 
applies the offset 
after advancing the PC. <p>
<B> 
Numbers <p>
</B> 
Numbers must be integer values. They are assumed to be decimal 
unless 
followed immediately by O or Q (specifies octal), or H (specifies 
hexadecimal). <p>

The first character of a number must be a decimal digit. A 
leading zero may 
be needed to make hexadecimal numbers conform to this rule. 
Numbers are 
converted to 16-bit values and then combined with the rest of the 
expression (if 
any). <p>
<B> 
Symbols <p>
</B> 
Symbols in an expression must either be defined elsewhere or be 
declared 
external. A symbol appearing in the operand field may be 
terminated with a 
pair of number signs (#), declaring it to be an external 
reference. The EXT 
directive also declares symbols to be external. External symbols 
have the 
program-relative attribute. Symbols defined with the SET and EQU 
pseudoops are assigned the relocation attribute of the 
expressions in their operand 
fields. <p>
<B> 
Operators <p>
</B>  
Small-Mac expression operators are a subset of those in the C 
language and 
follow the same precedence and grouping rules. They are listed in 
Table 7-4.<p> 

Operators with the highest precedence are at the top, and all 
operators in 
the same box in Table 7-4 have the same precedence. Arrows 
indicate the 
direction of grouping. You may use parentheses to control 
grouping. Any number of 
nesting levels is permitted.<p> 
<B>  
The Current Instruction Address <p>
</B>  
You may use the dollar sign $ as an implied label for the address 
of the current 
instruction. It has the program-relative attribute. <p>
<B>  
The Macro Facility <p>
</B>  
Source lines located between the MACRO and ENDM pseudo-ops 
constitute the body of a macro. They are stashed away in a buffer 
during pass one 
of the assembly process. The occurrence of a macro name in the 
operation 
field causes the body of the named macro to be inserted at that 
point in the 
program. This is called a macro &quot;expansion&quot; or macro 
&quot;call.&quot; The first term 
comes from the fact that a single instruction is 
&quot;expanded&quot; into a whole set 
of instructions. The second term comes by analogy to subroutine 
calls. 
Indeed, macros are also known as &quot;open&quot; or 
&quot;inline&quot; subroutines. Macro calls 
must follow their definitions in the source file. <p>

Nesting of macro definitions and macro calls is not allowed. If 
more 
than one macro definition has the same name, only the first one 
is 
used. <p>

<CENTER>
<B>  
Table 7-4. Small-Mac Expression Operators <p>
</B>  
</CENTER>
<PRE>

                +-------------------------------+ 
                | !   logical NOT            &lt;- | 
                | ~   one's complement       &lt;- | 
                | -   unary minus            &lt;- | 
                +-------------------------------+ 
                | *   multiplication         -&gt; | 
                | /   division               -&gt; | 
                | %   modulo (remainder)     -&gt; | 
                +-------------------------------+ 
                | +   addition               -&gt; | 
                | -   subtraction            -&gt; | 
                +-------------------------------+ 
                | &lt;&lt;  shift left             -&gt; | 
                | &gt;&gt;  shift right            -&gt; | 
                +-------------------------------+ 
                | &lt;   less than              -&gt; | 
                | &lt;=  less than or equal     -&gt; | 
                | &gt;   greater than           -&gt; | 
                | &gt;=  greater than or equal  -&gt; | 
                +-------------------------------+ 
                | ==  equal                  -&gt; | 
                | !=  not equal              -&gt; | 
                +-------------------------------+ 
                | &amp;   bitwise AND            -&gt; | 
                +-------------------------------+ 
                | ^   bitwise exclusive OR   -&gt; | 
                +-------------------------------+ 
                | |   bitwise inclusive OR   -&gt; | 
                +-------------------------------+ 
                | &amp;&amp; logical AND             -&gt; | 
                +-------------------------------+ 
                | || logical OR              -&gt; | 
                +-------------------------------+ <p>
 
</PRE>
 
<B> 
Parameter Substitution <p>
</B> 
Parameters may be specified with each macro call to tailor the 
expanded code to 
the circumstances peculiar to the call. Simply place ?1 in the 
body of the macro 
where the first actual parameter should go, ?2 for the second and 
?0 for the tenth 
and final one. At most, ten parameters are allowed. Parameters in 
a macro call 
are identified by position and are separated by commas. 
Successive commas or 
missing trailing parameters produce a null substitution; that is, 
the substitution 
sentinel (for example, ?3) corresponding to a null parameter is 
squeezed out of 
the expanded text. If you desire a ? in the expanded text, code 
?? in the macro 
body. Quotes or apostrophes may delimit an actual parameter 
containing spaces. 
An occurrence of the delimiter within the string is achieved by 
giving two 
successive delimiters. <p>

Parameter substitution is performed without regard to context. 
Therefore, 
substitutions occur within quoted strings, comments, and even 
symbols and 
mnemonics. You can use this simple concept to your advantage. <p>
<B> 
Local Labels <p>
</B> 
Ten labels that are local to each macro expansion may be 
specified in the macro 
body as @0 through @9. The first such label encountered by the 
assembler and 
its references will appear in the expanded text as @1, the second 
as @2, and so 
on. The sequence continues to increase throughout the program so 
that every 
such label and its references is guaranteed to be unique. This 
avoids &quot;redundant 
definition&quot; errors when the same macro is called repeatedly. 
<p>
<B> 
The Load-and-Go Facility <p>
</B> 
At times it is desirable to develop programs that run at 
addresses other than the 
standard CP/M TPA address. Frequently such programs are special 
device 
drivers or other BIOS extensions that should usually be invoked 
whenever a cold 
start is performed. Small-Mac includes a special load-and-go 
loader, LGO, for 
such purposes. LGO loads and optionally transfers control to 
programs that are 
created by LNK with a special load-and-go format.<p>
 
The -G# switch requests LNK to generate a load-and-go program. 
The 
number sign (#) stands for the hexadecimal address at which the 
program is to 
execute. Load-and-go files contain a return instruction at the 
beginning so that 
attempts to invoke them as ordinary CP/M commands (by renaming 
the 
filename extensions) will fail gracefully. Following the return 
are words specifying 
the load address, the length in bytes, and the starting address. 
This information 
is used by LGO to load precisely the right number of bytes at the 
right address 
and to (optionally) begin execution at the right place. <p>

It is the programmer's responsibility to ensure that this creates 
no problems 
during subsequent operation of the operating system. Refer to 
your CP/M 
manuals for the proper techniques. <p>
<B>  
The User Interface <p>
</B>  
The command to invoke a Small-Mac program consists of (1) the 
program name 
with optional drive designator in standard CP/M format, (2) 
redirection 
specifications for standard output files, and (3) switches used 
to control the action of 
the program. <p>
<B>  
Standard Input and Output Files <p>
</B>  
Small-Mac programs support Unix-like redirectable 
&quot;standard&quot; files. A standard 
file is a file that is automatically opened upon program 
execution. By default, 
the &quot;standard input&quot; file is assigned to the keyboard 
and the &quot;standard output&quot; 
file is assigned to the screen. <p>

You may direct the standard input file away from the keyboard by 
placing a 
&lt; in the command line followed by the new source. This may be 
a filename 
(complete with extension and optional drive specifier), or a 
logical device such 
as RDR:. <p>

Likewise, you may direct the standard output file away from the 
screen by 
placing a &gt; in the command line. When standard output is 
redirected by &gt;&gt; 
(for example, &gt; &gt;FILE3), the output is appended to whatever 
data was already 
in the named file. If the file does not already exist, it is 
created and &gt;&gt; is no 
different than &gt;. <p>

Both redirection specifications may be given simultaneously in 
any 
position following the program name in the command line. <p>

Take care not to assign both input and output to the same file; 
the result 
will be a corrupted file. <p>

Small-Mac programs use standard input only for keyboard response 
to error 
messages, so there should be no need to redirect it. Standard 
output is used for 
listings and error messages, so by default these go to the 
screen. <p>
<B> 
Command Line Parameters <p>
</B>  
Switches consist of a hyphen followed immediately by one or two 
letters and, 
perhaps, a numeric value. Switch letters are chosen to have 
mnemonic value. 
Except for LIB, all the Small-Mac programs allow switches to 
appear in any 
position after the program name. LIB takes only one switch, and 
it must come first 
in the command line. <p>
 
Small-Mac programs take nonswitch parameters as filenames. The 
order in 
which they are listed can make a difference. See the individual 
program 
descriptions below for details. <p>
<B>  
Usage Messages <p>
</B>  
To aid in remembering the various switches and parameters used 
with 
Small-Mac programs, the console displays a usage message whenever 
a Small-Mac 
program is invoked with a null or undefined switch. If you need 
help remembering 
how to invoke a program, just enter the program's name followed 
by an isolated 
hyphen. Usage messages indicate the syntax of the commands that 
invoke 
Small-Mac programs; they have the form <p>
<PRE> 
     Usage: &lt;program&gt; &lt;switch&gt;... &lt;file&gt;... <p>
</PRE> 
where &lt;program&gt; is the program name, &lt;switch&gt; is a 
switch, and &lt;file&gt; is 
a filename. The &lt; and &gt; characters are not part of the 
syntax. They only 
indicate that a generic term is enclosed. <p>

Redirection specifications are not shown in usage messages since 
they are 
common to all programs; their presence can be assumed. <p>

Square brackets appear in usage messages to indicate fields that 
are 
optional. The brackets are not part of the command. <p>

Programs take default actions when an optional switch is missing. 
These 
actions are chosen to be the most usual ones, so that switches 
are usually 
needed only in exceptional cases. LIB is an exception, since it 
must always be 
told what to do.<p>
 
The ellipsis appears in usage messages to indicate that a given 
type of field 
may occur more than once in the command. The ellipsis itself is 
not a part of 
the command. <p>

Words or combinations of words are used as generic names for 
specific 
types of parameters. For example, the term source stands for an 
assembler input 
file. <p>
<B>  
Error Handling <p>
</B>  
All Small-Mac programs send error messages to the standard output 
file. If a fatal 
error is reported, the program aborts with an audible alarm. If 
possible, the 
program runs to completion before aborting. However, some errors 
(for example, 
command line errors) may cause immediate program termination.<p>
 
Two errors are caught by the Small-C runtime system rather than 
the 
program: <p>
<UL>

<LI> R, Redirection specification error, which indicates an 
attempt to redirect 
        standard input to come from a nonexistent file. This 
should not occur, since there is 
        no reason to redirect Small-Mac standard input files. 
<LI> M, Memory allocation error, which indicates that an attempt 
was made to 
        allocate more memory than was available. <p>
</UL>
<B>  
Program Control <p>
</B> 
You may interrupt any of the programs in the Small-Mac package 
while they are 
running. To make a program pause temporarily, enter a control-S 
from the 
keyboard. Another keystroke continues program execution. To abort 
a program, 
enter control-C. <p>
<CENTER>
<B> 
USING SMALL-MAC PROGRAMS <p>
</B>
</CENTER> 
<B>
MAC: The Small-Mac Assembler <p>
</B>
<PRE> 
     Usage: MAC [-L] [-NM] [-P] [-S#] [object] source... 
     -L         Generate an assembly listing 
     -NM        No macro processing 
     -P         Pause on errors 
     -S#        Set the symbol table for # symbols maximum 
     object     Name of the object file 
     source...  Names of the source files <p>
</PRE>  
<b>Description<p></b>: 
 
Source Files:<p>
 
You must specify at least one source file in the command line. If 
more than one 
is given, they will be assembled into a single object module in 
the order given. 
You may include a drive specifier with the source filenames to 
direct the 
assembler to specific drives. If no drive is indicated, the 
default drive is assumed. If a 
source file cannot be found, MAC aborts with an error message. 
The default and 
only allowed source filename extension is MAC. <p>
 
The Object File: <p>
 
You may specify one object file. If none is given, the object 
code goes into a file 
on the default drive bearing the same name as the first source 
file, but with a 
REL extension. You may include a drive specifier with the object 
filename to 
direct the output to a specific drive. If no drive is indicated, 
the default drive is 
assumed. The object filename must have a REL extension to 
distinguish it from 
the source files. The module name in the object file is taken 
from the first six 
characters of the object filename. <p>
 
The Assembly Listing: <p>
 
An assembly listing will be produced only if you include the -L 
switch in the 
command line. The listing and any error messages are sent to the 
standard 
output file and, therefore, go to the screen unless redirected. 
<p>

Error messages follow the line in the listing to which they 
apply. However, 
if no listing is being generated, each erroneous source line is 
printed before its 
error message(s). <p>

The listing output is paginated for printing on 11-inch high 
pages. You 
should use either a wide printer or a compressed print mode for 
assembly 
listings. <p>

Each line in the listing contains (left to right): <p>
<UL> 
<LI>The source line number in decimal 
<LI>The current location counter value in hexadecimal 
<LI>The hexadecimal object code generated by the current source 
line 
<LI>The source line <p>
</UL> 

Program relocatable items in the object column are flagged with 
an apostrophe. 
Other items are absolute. If the object code will not fit in the 
allotted space, 
overflow lines are printed. <p>

A sorted dump of the symbol table is produced at the end of the 
listing. 
Each line shows the symbol value, relocation attribute flag, 
symbol, and symbol 
type. Symbol types are indicated with the following suffixes:<p>
<PRE> 
 
     :            label 
     ::           entry point 
     ##           external reference <p>
</PRE>
 
The Macro Override:<p> 
 
You may specify the -NM switch, meaning &quot;no macros,&quot; if 
macro processing is 
not required. This speeds up the assembler by about 13 percent. 
Macro 
processing is not needed for programs generated by the Small-C 
compiler. <p>
 
Error Pauses: <p>
 
The -P switch causes MAC to pause after displaying the errors for 
each line. It 
waits until a carriage return is received from the keyboard.<p> 
 
Symbol Table Size:<p> 
 
The -S# switch sets the size of the symbol table. The number sign 
stands for an 
unsigned decimal integer, indicating the maximum number of 
symbols that the 
table will hold. Since performance degrades as the symbol table 
approaches 
capacity, leave some unused space in the table. The default table 
size is 500 symbols. <p>

Whatever memory is left over after allocating the symbol table is 
used for 
macro buffer space. The larger the symbol table, the less space 
remains for 
macro definitions; the smaller the symbol table, the more space 
remains for 
macro definitions. <p>

If you need to assemble programs with approximately 400 symbols 
or more, 
use -S# to increase the size of the symbol table. On the other 
hand, if you get a 
&quot;Macro Buffer Overflow&quot; error, try decreasing the 
symbol table size. <p>
 
Examples:<p> 
<PRE>  
   <b>COMMAND                            DESCRIPTION </b>
 
MAC PROG                   Assemble PROG.MAC, generating PROG.REL on the 
                           default drive. Do not produce a listing and do not 
                           pause on errors. 
 
MAC PROG PROG2 -L -P       Assemble PROG.MAC and PROG2.MAC, generating 
                           PROG.REL on the default drive. Produce a listing on 
                           the screen and pause on errors. 
 
MAC P1 P2 P3 B:P.REL -NM   Assemble P1.MAC, P2.MAC, and P3.MAC, 
                           generating P.REL on drive B. Do not produce a 
                           listing, do not pause on errors, and do not perform 
                           macro processing. 
 
MAC PROG -L &gt;LST:          Assemble PROG.MAC, generating PROG.REL on the 
                           default drive. Produce a listing on the LST device 
                           and do not pause on errors. <p>
</PRE>  
Normal Messages:<p> 
<PRE>  
   <b>MESSAGE                            EXPLANATION</b> 
 
   Waiting...              MAC is waiting for a carriage return from the 
                           keyboard. <p>
</PRE>  
Error Messages:<p> 
<PRE>  
<b>   MESSAGE                            EXPLANATION </b>
 
   Backward Movement        An ORG would move the assembly location counter 
                            backward. 
 
   Bad Data                 A DW or DB specifies improper data. 
 
   Bad Expression           An improper expression is in the operand field. 
 
   Bad Label                An improper label is in the symbol/label field. 
 
   Bad Operation            A mnemonic cannot be found in the machine 
                            instruction table. 
 
   Bad Parameter            A macro call specifies too many parameters. 
 
   Bad Symbol               An improper symbol has been found. 
 
   xxxxxxxx - Can't Open    The named file cannot be opened. 
 
   Close Error              A file cannot be closed properly. 
 
   Invalid Extension        A command-line file specification contains an 
                            improper extension. 
 
   Macro Buffer Overflow    The macro text buffer has overflowed. 

 
   Missing END              An input file lacks the END pseudo-up. 
 
   Missing ENDM             The end of a source file was encountered while 
                            within a macro definition. 
 
   Redundant Definition     The same symbol appears more than once in the 
                            symbol/label field. Only the SET pseudo-up is 
                            permitted to redefine symbols, and then only the 
                            ones it defined originally. 
 
   Relocation Error         An 8-bit field has evaluated to a program-relative 
                            value or the expression on an END pseudo-up is not 
                            program relative. 
 
   Symbol Table Overflow    No more symbols will fit into the symbol table. 
 
   xxxxxxxx - Too Long      The command line contains a filename that is too 
                            long. 
 
   Undefined Symbol         The operand field contains a reference to an 
                            undefined symbol. 
 
   Write Error in REL File  An output error has occurred in the object file. 
                            Most likely the output disk drive has run out of 
                            space. <p>
</PRE> 
 
<b>LNK: Small-Mac Linkage Editor<p> </b>
<PRE>  
  Usage: LNK [-B] [-G#] [-M] program [module/library...] 
 
  -B                 Linking a BIG program. Reserve all of memory for 
                     the symbol table and buffer program text entirely 
                     on disk. 
  -G#                Output a LGO file for execution at address #. 
  -M                 Monitor linking activity. 
  program            A file specifier for the program being linked. 
  module/library...  A list of zero or more module (.REL) and/or library 
                     (.LIB) files. <p>
</PRE>  
Description:<p> 
 
Functional Description:<p>
 
LNK performs three primary tasks: it combines separately 
assembled modules 
into a single program, resolves external references, and adds the 
base address of 
each module to all the program-relative items contained within 
it, thereby 
converting them to absolute values. <p>

This work is done in two phases. First, it scans the command line 
to 
look for module and library names. Each module that is named in 
the 
command line is read into a loading buffer behind the previous 
module. As each 
module is being loaded, a temporary list of pointers to program 
relative 
items is written into a &quot;reference&quot; file (.R$) for use 
in phase two. Also, 
entry points and external references are loaded into a symbol 
table for use 
in resolving external references. <p>

The symbol table is structured as two linked lists arranged in 
alphanumeric 
order--one for external references and one for entry points. Each 
symbol table 
entry contains a chain pointer, the name of the symbol, and a 
16-bit address. In 
the case of an entry point, the value is just the entry point 
address. But in the 
case of an external reference it is the address of the head of a 
chain of references 
to that symbol. LNK resolves an external reference by replacing 
every link in its 
chain with the value of the matching entry point. <p>

After loading each module, LNK attempts to resolve all external 
references that match entry points in the new module. As each 
external 
reference is resolved, its place in the symbol table is reclaimed 
for future use. 
New external references use up reclaimed space before the table 
is 
extended. Entry points must remain in the table in case they are 
referenced by 
upcoming modules. <p>

When LNK encounters a filename with a .LIB extension it assumes 
it to be a 
library. In that case a search is made for library members 
(modules) that 
contain entry points matching yet unresolved external references. 
This search is 
facilitated by the fact that every entry point contained in a 
module is listed near 
the beginning of the module. If no match is found, the module is 
skipped. To 
speed up the skipping process, an index file (.NDX) is used to 
obtain the location of the beginning of the next module. LNK 
seeks directly to the next module 
without reading through the unwanted one. When the scan is 
finished, the 
library is rescanned to resolve backward references. This is 
repeated until no 
more modules are loaded, at which time LNK continues scanning the 
command 
line for further modules and/or libraries. <p>

Note that merely declaring a symbol to be external will cause its 
module to 
be loaded. It need not actually be referenced. <p>

When the command line is exhausted, LNK enters phase two. It 
closes the 
reference file and reopens it for input. It then begins writing 
the buffered object 
code to the output file (either .COM or .LGO). As it proceeds, it 
compares the 
address of each item to the current address from the reference 
file. On each 
match, a relative item has been found, so LNK adds an offset 
value, making it an 
absolute value. The next reference address is read and the 
process continues. To 
reduce head movement during phase two, additional buffering is 
used for the 
reference file. <p>
 
The -B Switch. Normally, LNK attempts to use all available memory 
for 
buffering program text (object) and for the symbol table. 
However, there may not 
be enough memory for LNK, its symbol table, and the program being 
loaded. 
When LNK sees that a module about to be loaded will not fit in 
main memory, 
it overflows into a temporary file with an extension of 
&quot;.O$&quot;. Processing then 
continues as before, except that subsequent modules are placed 
into the 
overflow file. This slows down the loading process significantly, 
but it occurs only on 
larger programs. <p>

The low end of memory is used for program text and the high end 
for the 
symbol table. As processing continues, each grows in the 
direction of the other. 
Overflow occurs when the next module to be loaded would overlap 
an 
imaginary cushion of 200 entries at the end of the symbol table. 
Even after overflowing to disk, the symbol table may overflow 
when the cushion is exhausted. At 
that point, LNK aborts with the message &quot;Must Specify -B 
Switch.&quot; When you 
invoke LNK with the -B switch, LNK overflows immediately to disk, 
leaving all 
available memory for the symbol table. This should permit the 
linking of 
programs of any size. <p>
 
The Load-and-Go Switch. The -G# switch causes LNK to output a 
.LGO 
file instead of a .COM file. The address at which the program 
will run is 
specified by the hexadecimal number represented by #. The LGO 
loader must be 
used to load and/or execute the program. <p>
 
The Monitor Switch. The -M switch causes LNK to monitor its 
loading 
and linking activities. It produces on the standard output file a 
list of modules 
loaded, their sizes, and their load addresses (both 
program-relative and 
absolute). <p>
 
Program and Module Names. At least one module (.REL file) name 
must be specified. A filename without an extension is taken as a 
module name. 
The first module determines the name of the output program. 
Subsequent 
modules are loaded with and linked to the &quot;program&quot; 
module, but have no influence 
on the program name. If an extension is given to a module name, 
it must be 
.REL. If a drive designator (for example, B:) is specified, it is 
used for finding the 
input file. However, the output file always goes onto the default 
drive. <p>
 
Library Names. Libraries are identified by specifying the .LIB 
extension, that 
must be specified with the filename. A drive designator may be 
given to specify 
where the library and its index are to be found. LNK requires the 
presence of an 
index file on the same drive bearing the same name, but with a 
.NDX extension. The library C.LIB contains the standard Small-C 
runtime functions. 
Whenever you link a Small-C program, you must specify C.LIB. <p>
 
The Special Module END. To facilitate the linking of Small-C 
programs, 
LNK is sensitive to the module name END. That module in C.LIB 
must always 
be loaded last. This is because it contains statements that 
initialize the beginning of free memory before the program begins 
execution. When LNK would 
load a module by that name, it passes it by, and at the end of 
phase one goes 
back and loads it last. If LNK were to see more than one module 
named END, it 
would load only the last one. This feature may be useful when you 
construct private libraries. <p>
 
Special Note:<p>
 
Compile LNK only with Small-C 2.1 (edit level 63) or later. Edit 
63 fixes CSYSLIB 
so that when it overflows a buffer while writing into a file, it 
no longer assumes 
that it is at the end of the file. This prevents it from padding 
a sector with 1A 
(hex) in the middle of a file when random access is being used. 
<p>
 
Examples: <p>
<PRE>  
   <b>COMMAND                             COMMENT </b>
 
   LNK PROG -GE000          Load PROG.REL, yielding PROG.LGO for execution 
                            at address E000. 
 
   LNK P1 P2 C.LIB          Link P1.REL, P2.REL, and any required modules 
                            from C.LIB, yielding P1.COM for execution as a 
                            standard CP/M command. 
 
   LNK -B -M &gt;LST: ABC      Link ABC.REL and any required modules from 
   C. LIB                   C.LIB, yielding ABC.COM. ABC is very big, so load 
                            it entirely to disk, leaving all of available memory 
                            for the symbol table. Monitor the linking process on 
                            the LST device. <p>
</PRE> 
 
Normal Messages:<p>
<PRE>  
<b>   MESSAGE                         EXPLANATION</b> 
 
   xxxx Bytes at yyyy zzzz   Module mmmmmm of length xxxx is loaded at 
   mmmmmm                    relative address yyyy (absolute zzzz). This appears 
                             only when -M is specified. 
 
   xxxx Byte Buffer          The amount of memory available for the symbol 
                             table and the object buffer is xxxx. This appears 
                             only when -M is specified. 
 
   xxxx Bytes (hex)          The size of the program in hexadecimal is xxxx. 
 
   xxxxx Bytes (dec)         The size of the program in decimal is xxxxx. 
 
   xxxx Overflow Point       The relative address of the first module to overflow 
                             is xxxx. This appears only if LNK is compiled with 
                             the DEBUG symbol and -M is specified. 
 
   Resolving xxxxxx to yyyy  LNK is starting to resolve external reference xxxxxx 
                             with head of chain at yyyy. This appears only if 
                             LNK is compiled with the DEBUG symbol and -M is 
                             specified. 
 
   Start in xxxxxx           A starting address was specified for module xxxxxx. <p>
</PRE> 
 
Error Messages:<p> 
<PRE>  
   <b>MESSAGE                                EXPLANATION</b> 
 
   Abnormal End of REL File     The end of a module or library has been reached 
                                without finding a proper end-of-file item. 
 
   xxxxxxxx - Can't Open        The named file cannot be opened. 
 
   Close Error                  A file cannot be closed properly. 

    Corrupt Library or Index     A seek error has occurred while attempting to locate 
                                the next module in a library. 
 
   Corrupt Module               An unrecognizable link item has been found in a 
                                module or library member. 
 
   Error Reading xxxxxxxx       An I/O error has occurred while reading the named 
                                file. 
 
   Error Writing xxxxxxxx       An error has occurred while writing the named file. 
                                Mostly likely this means that the disk ran out of 
                                space. 
 
   Invalid Extension            A command-line file specification contains an 
                                improper extension. 
 
   Must Specify -B Switch       There is not enough free memory to contain both 
                                the symbol table and program text. Rerun LNK 
                                specifying the -B switch. 
 
   Premature End of Index       The index for a library contains too few entries. 
 
   Redundant: xxxxxx            The named symbol occurs more than once as an 
                                entry point. 
 
   Seek Error in xxxxxxxx       A seek error occurred while attempting to find a 
                                relative item in the overflow file. This could be 
                                caused by a problem with the overflow file, or a 
                                logic flaw in LNK. 
 
   xxxxxxxx - Too Long          The command line contains a filename that is too 
                                long. 
 
   Unresolved: xxxxxx           No entry point was found to match the named 
                                external reference. 
 
   Unsupported Link Item        An input module contains a recognizable but 
                                unsupported Microsoft link item. 
<p>
</PRE> 
 
<b>LGO: Small-Mac Load-and-Go Loader <p></b>
<PRE> 
       Usage: LGO [-G] [-M] program 
 
       -G       Execute program after loading. 
       -M       Monitor the load address, size, and starting 
                address. 
       program  File specifier for the program being loaded<p> 
</PRE>  
Description:<p>
 
LGO is a very simple loader designed to load .LGO files at their 
designated 
addresses and optionally begin execution. Its primary purpose is 
to permit the 
convenient installation of operating system extensions at cold 
start time. <p>

When the -G# switch is used with LNK, it outputs a special .LGO 
file 
instead of the usual .COM file. Load-and-go files have the 
following format: <p>
<PRE> 
     <b>ITEM                       BYTES </b>
 
     RET instruction            1 
     starting address           2 
     base address               2 
     program size               2 
     object text                &lt;size&gt; <p>
</PRE>  
The RET instruction serves two purposes. It identifies the file 
as having the load-and-go format and it produces a graceful exit 
in case someone were to rename 
the file to a .COM extension and then attempt to execute it as a 
CP/M 
command. <p>

The base address and size tell LGO exactly where to load the 
program and 
how many bytes to load. Only the indicated number of bytes are 
loaded. That 
number is reported by LNK when the .LGO file is created. Always 
verify that 
.LGO programs will fit exactly where they are expected to go. <p>

You should also consult the CP/M documentation and the 
documentation 
for your particular implementation of CP/M to learn how CP/M 
manages its 
TPA (temporary program area). If you place a .LGO program above 
CP/M, there 
will be no problem. However, if you place it below the CCP at the 
top end of the 
TPA, you must write your program to adjust the address at 
location 0006 to refer 
to the beginning of your program, which in turn must contain a 
jump to the 
address in BDOS that originally existed at location 0006. This 
will cause CP/M 
to operate normally with a reduced TPA, leaving your program 
intact even as 
normal programs are executed in the TPA. <p>

You cannot place a permanent program at the low end of the TPA, 
and you 
certainly cannot allow one to overlap LGO while it is executing 
in the TPA as a 
normal CP/M command. LGO is written in Small-C; therefore, its 
normal stack 
is located at the high end of the TPA. So, in order to make the 
top of the TPA 
available for loading programs, LGO moves its own stack to the 
first 256 bytes 
following itself. <p>

When LGO is executed, a program name must be specified in the 
command 
line. If an extension is given, it must be .LGO. <p>

LGO performs the following functions: <p>
<UL> 
<LI> Opens the named file 
<LI> Verifies that it has the load-and-go format 
<LI> Reads the initial parameters 
<LI> Loads the indicated number of bytes at the indicated address 

<LI> If -G was specified, it transfers control to the starting 
address.<p> 
</UL> 

Examples: <p>
<LI> 
   <b>COMMAND                               COMMENT </b>
 
   LGO DRIVER -G            Load DRIVER.LGO at the appropriate address and 
                            begin execution. 
 
   LGO PROG -M              Load PROG.LGO, display the loading address, size, 
                            and starting address on the screen, then exit to 
                            CP/M. 
 
   LGO ABC                  Load ABC.LGO, and exit to CP/M. <p>
</PRE>
 
Error Messages:<p> 
<PRE>
   <b>MESSAGE                              EXPLANATION </b>
 
   xxxxxxxx - Can't Open    The named file cannot be opened. 
 
   Error Reading xxxxxxxx   An I/O error occurred while reading the indicated 
                            file. 
 
   Invalid Extension        A command-line file specification contains an 
                            improper extension. 
 
   Invalid LGO Format       The named file is not a true load-and-go file. 
 
   xxxxxxxx - Too Long      The command line contains a filename that is too 
                            long. <p>
</PRE>
 
<b>LIB: -- Small-Mac Library Manager <p></b>
<PRE> 
       Usage: LIB -{DPTUX}[A] library [module...] 
 
       -D       Delete named modules 
       -P[A]    Print named or all (-PA) modules 
       -T[A]    Print a table of contents of named or all (-TA) modules 
       -U       Update (add/replace) named module 
       -X[A]    Extract named or all (-XA) modules <p>
</PRE>
 
Description:<p> 
 
LIB is used to maintain libraries of relocatable object modules 
(library 
members). Each member has exactly the same format as a 
freestanding object module 
(.REL file). Each library consists of a concatenation of object 
modules in a file 
that has a .LIB extension. An index file (.NDX) must accompany 
each library. 
The index file contains a series of word pairs, each specifying 
the address of the 
first byte of a member within the library. The first word 
indicates the block and 
the second the byte within the block. LNK and LIB use this 
information to seek 
directly to the next library member. LIB maintains libraries in 
alphanumeric 
order. <p>

When LIB is invoked, the first parameter must be a switch 
indicating the 
function to be performed. This must be followed by the name of 
the library in 
question. The library name may have the extension .LIB (which is 
assumed as 
the default), but no other. A drive designator may be given to 
indicate where 
the library is to be found. <p>

Whenever LIB creates or modifies a library, it outputs on the 
same drive a 
new library with an extension of .L$ and a new index with an 
extension of .N$. 
Then, upon successful completion, it deletes the original library 
and index and 
renames the new files with permanent extensions. <p>

The -D and -U commands require a list of member names to be 
operated 
upon. The other commands may operate on either a list of members 
or all 
members. The list can be supplied three ways: it may be given in 
the command line 
following the library name, entered from the console, or obtained 
from a file of 
names. If names appear in the command line, they are taken as the 
list. 
Otherwise LIB obtains the names from the standard input file. If 
standard input has 
been redirected to a disk file, LIB reads the file, obtaining one 
name per line. 
However, if standard input has not been redirected, LIB prompts 
for each name 
to be entered from the keyboard. A null response (carriage return 
only) signals 
the end of the list. <p>

The -P, -T, and -X commands operate on every member in the 
library if the 
name list is empty; that is, no names appear in the command line 
and a null 
reply is given to the first prompt, or the file to which standard 
input has been 
redirected is empty. If you want to avoid the prompt and do not 
wish to supply 
a null file, simply append the letter A to the switch, giving 
-PA, -TA, or -XA. <p>

Name lists may appear in any order. <p>

Member names are only six characters long. However, a filename 
may be 
eight characters long (excluding drive designator and extension). 
The name list 
may specify names of up to eight characters. Such names are 
truncated to six 
characters when referencing library modules. However, the -U 
command will 
use all eight characters when looking for freestanding modules to 
copy into a 
library. The -X command uses only six characters when it creates 
freestanding 
modules. When names will be truncated, LIB lists them on the 
screen and asks 
whether or not to proceed. <p>
 
Deleting Members:<p>
 
The -D switch causes LIB to delete specific members from an 
existing library. 
Each member to be deleted must be specified in the name list. <p>
 
Printing Library Members:<p> 
 
The -P switch causes LIB to print the contents of selected 
modules. Specified 
members are printed with program (module) name, program size, 
entry points, 
external references, and the end of program sentinel. To save 
space, object text 
is not shown. DREL can be used to see the complete contents of a 
module. <p>
 
Printing a Table of Contents:<p> 
 
The -T switch causes LIB to print a table of contents; that is, a 
list of member 
names. This is an eight-column list in alphanumeric order going 
left to right, top 
to bottom. <p>
 
Creating or Updating a Library:<p> 
 
The -U switch causes LIB to update (that is, add and replace) 
named members. 
For each name specified, a stand-alone module is copied into the 
new library. If 
a module of the same name is in the old library, it is replaced. 
Before proceeding 
with the update operation, each named file is sought on disk. If 
any are not 
found, LIB asks whether to proceed. <p>

If the named library does not exist, a null library is created 
and the 
operation proceeds as usual. <p>
 
Extracting Library Members:<p> 
 
The -X command causes LIB to copy the named members from the 
library into 
stand-alone files. Each file is placed on the default drive with 
a .REL extension. <p>
 
Examples:<p> 
<PRE> 
   <b>COMMAND                                COMMENT</b> 
 
   LIB -U M ABC DEF HIJ       Update M.LIB (and M.NDX) with ABC.REL, 
                              DEF.REL, and HIJ.REL. 
 
   LIB -X MY                  Extract members from MY.LIB. Accept member 
                              names from the keyboard. If the first response is 
                              null, all members are to be extracted. 
 
   LIB -D MY &lt;ABC.LST         Delete from MY.LIB (and MY.NDX) the members 
                              that are named in the file ABC.LST. 

 
   LIB -P M GETREL            Print the member GETREL from M.LIB. 

 
   LIB -TA C                  List the entire table of contents of C.LIB.<p>
</PRE> 
 
Normal Messages:<p> 
<PRE> 
  <b> MESSAGE                                 EXPLANATION </b>
 
   Added xxxxxx               The indicated member has been added to the 
                              library. 
 
   Created xxxxxx             The indicated file has been created as a stand-alone 
                              module. 
 
   Creating New Library       The named library did not exist, so a new library by 
                              that name is being created. 
 
   Continue?                  Should LIB continue or quit? 
 
   Deleted xxxxxx             The indicated member has been deleted from the 
                              library. 
 
   Module Name: xxxxxx        Prompt for the next module name. 
 
   Replaced xxxxxx            The indicated member has been replaced in the 
                              library. <p>
</PRE>
 
Error Messages:<p> 
<PRE> 
<b>  MESSAGE                                EXPLANATION </b>
 
   xxxxxxxx - Can't Find -    The named file cannot be found and will be 
   Ignored                    ignored. 
 
   xxxxxxxx - Can't Open      The named file cannot be opened. 
 
   Can't Rename Files         The commanded operation is complete, but the new 
                              files cannot be renamed to permanent extensions. 
 
   Close Error                A file cannot be closed properly. 
 
   Corrupt Library or Index   An index-directed seek did not locate the beginning 
                              of a member. 
 
   Delete by Name Only        Specific members were not named for a delete 
                              operation. 
 
   xxxxxxxx - Duplicate       The same member name was specified more than 
   Name - Ignored             once. 
 
   Error Reading Index        An I/O error occurred while reading the index file. 
 
   Error Writing New Index    An I/O error occurred while writing the new index 
                              file. Most likely this means that the disk is full. 
 
   xxxxxxxx - Extension       A filename extension was specified. LIB will ignore 
   Forced to xxx              it and use .REL instead. 
 
   Invalid Extension          A command-line file specification contains an 
                              improper extension. 
 
   xxxxxxxx - Invalid Format  An invalid filename format was specified. It will be 
   - Ignored                  ignored. 
 
   Limited Stack Space        LIB is operating with limited stack space. It may 
                              malfunction. A larger TPA is needed. 
 
   Memory Overflow            LIB cannot proceed because there is not enough 
                              memory. 
 
   Premature End of Index     The end of the index file was reached before the 
                              end of the library. 
 
   Too Many Modules           LIB cannot handle the number of member names 
   Specified                  specified. Lib will take at most 200 module names. 
                              Multiple LIB runs can be made or LIB can be 
                              recompiled with a larger value assigned to the 
                              symbol MAXMODS. 
 
   xxxxxx Was Not in          The indicated member was not found in the library. 
   Library 
 
   xxxxxxxx - Will be         The indicated name will be truncated as shown. 
   Truncated to xxxxxx 
 
   xxxxxxxx - Too Long        The command line contains a filename that is too 
                              long. <p>
</PRE>
 
<b>CMIT: Small-Mac Configuration Utility (Compile Machine Instruction Tables)<p></b> 
<PRE> 
     Usage: CMIT [-C] [-L] [table] [mac] 
 
     -C     Configure the executable assembler with the indicated or 
            default machine instruction table. 
     -L     List the compiled machine instruction table. 
    table  The name of the machine instruction table file in source format 
           (default 8080.MIT). 
    mac    Assembler .COM file (default MAC.COM).<p> 
</PRE> 
Description:<p>
 
CMIT is used to compile machine instruction tables (MITs) from 
external 
source format into internal format. <a href="#list7-8">Listing 
7-8</a> and 
<a href="#list7-9">Listing 7-9</a> show the two machine 
instruction tables supplied with Small-Mac. <p>

Once a table has been compiled, it is printed and/or copied into 
the 
executable assembler, thereby configuring it to a specific CPU. 
<p>

After you have compiled and linked a new MAC.COM, you must 
configure 
it by running CMIT before you may execute it. You may reconfigure 
a 
previously configured MAC.COM anytime. <p>

CMIT produces its listings from the object table. It reads the 
source table a 
second time and looks up each instruction in the internal MIT 
using the same 
functions the assembler uses. CMIT then lists each instruction, 
showing the 
source, the number of looks needed to find it in the internal 
MIT, and the 
object code that will be generated when the instruction is 
assembled. <p>

Whenever a new MIT is created, you must carefully check its 
listing to 
verify that it will generate the correct object code. <p>
 
The -C Switch:<p> 
 
The -C switch causes CMIT to configure an executable assembler 
with the 
compiled MIT. <p>
 
The -L Switch:<p> 
 
The -L switch causes CMIT to list the compiled table on the 
standard output 
file. The output may therefore be redirected to a printer, disk 
file, or whatever. If no switches are given, -L is assumed. 
However, if any switches are given, 
only requested actions are taken. <p>
 
Naming the Machine Instruction Table: 
 
If no MIT source file is named, then 8080.MIT (on the default 
drive) is 
assumed. A filename without an extension or with an extension of 
.MIT 
designates a different MIT source file. You may give a drive 
specifier.<p> 
 
Naming the Target Assembler: 
 
If no executable assembler file is named, MAC.COM on the default 
drive is 
assumed. A filename with an extension of .COM designates a 
different copy of 
the assembler. You may give a drive specifier. <p>
 
Examples: <p>
<PRE> 
<b>   COMMAND                                 COMMENT </b>
 
   CMIT                        Compile 8080.MIT (from the default drive) and list 
                               the resulting table. 
 
   CMIT-C                      Compile 8080.MIT (from the default drive) and 
                               place a copy in MAC.COM (also on the default 
                               drive). 
 
   CMIT Z80 B:MAC.COM          Compile Z80.MIT (from the default drive) and place 
                               a copy in B:MAC.COM. <p>
</PRE>
 
Normal Messages:<p> 
<PRE> 
<b>   MESSAGE                                  EXPLANATION</b> 
 
   Buffer Space Used nnnnn     The indicated number of bytes of buffer space was 
                               actually  used for the internal MIT. 
 
   Operation Codes nnnnn       The indicated number of unique operation codes 
                               (mnemonics) were compiled. <p>
</PRE>
 
Error Messages:<p>
<PRE> 
   <b>MESSAGE                                   EXPLANATION </b>
 
   xxxxxxxx - Write Error       A I/O error occurred while writing into the 
                                indicated file. Most likely the disk is full. 
 
   Bad Expression Specifier     An illegal expression specifier was found in the 
                                source file. 
 
   Bad Hex Byte                 An illegal hexadecimal byte value was found in the 
                                source file. 
 
   Can't Find Instruction in    While verifying the object table, CMIT could not 
   MIT                          find an instruction mnenomic. Most likely, this 
                                indicates a program error in CMIT. 
 
   Can't Find Operand           While verifying the object table, CMIT could not 
                                find an instruction operand. Most likely, 
                                instructions having the same mnemonic were 
                                separated in the source file. 
 
   xxxxxxxx - Can't Open        The named file cannot be opened. 
 
   Can't Rewind MIT File        The source file will not rewind. 
 
   Close Error                  A file cannot be closed properly. 

 
   Invalid Extension            A command-line file specification contains an 
                                improper extension. 
 
   MIT Buffer Overflow          Insufficient space was allowed in the internal MIT 
                                buffer. This can be corrected by increasing the value 
                                assigned to MIBUFSZ in MAC.H, then recompiling 
                                both CMIT and MAC. 
 
   xxxxxxxx MIT is nnnnn        The size of the internal MIT in the indicated 
   Bytes but Should be          executable assembler and in CMIT.COM are not the 
   nnnnn                        same. This can be corrected by verifying that 
                                MAC.H contains the correct values for MICOUNT, 
                                MIBUFSZ, and MIOPNDS, then recompiling both 
                                CMIT and MAC. 
 
   MIT Mnemonic Overflow        Insufficient space was allowed in the internal MIT 
                                for hashing mnemonics. This can be corrected by 
                                increasing the value assigned to MICOUNT in 
                                MAC.H, then recompiling both CMIT and MAC. 
 
   MIT Operand Overflow         Insufficient space was allowed in the internal MIT 
                                for operands. This can be corrected by increasing 
                                the value assigned to MIOPNDS in MAC.H, then 
                                recompiling both CMIT and MAC. 
 
   xxxxxxxx - Too Long          The command line contains a filename that is too 
                                long.<p>
</PRE> 
 
<b>DREL: Dump Relocatable Object Files<p> </b>
<PRE> 
     Usage: DREL <p>
</PRE> 
Description:<p> 
 
DREL produces a formatted listing of the contents of an object 
file. It dumps 
either stand-alone modules or libraries. Output goes to the 
standard output file 
and, therefore, may be redirected to a printer, disk file, or 
whatever.<p>
 
No command line switches are accepted. You are prompted for each 
file to 
be dumped. If a file cannot be found, you are prompted for 
another input file. 
Filenames must include extensions. Drive specifiers may be given. 
A null 
response to the prompt signals DREL to quit. <p>
 
Example:<p> 
<PRE> 
   library/module name: TEST.REL 
 
   - program: TEST 
    prog size: 008E' 
      load at: 0064' 
   0064 0085' 05 00 EB CE 05 88 89 CD 0085' CD 008A' C3 
   0074 10 00 21 0089' 21 10 00 3A 00 00 3A 0005+ 007D' 
   0082 3A FFFB+ 0080' 01 32 03 34 05 36 07 38 09 
    ext chain: 0083' EREF 
   - end prog: 0000 
   - end file 
 
   library/module name:<p>
</PRE> 
 
The first column of the body of the module is the program 
relative address of 
the first byte shown to the right. <p>

Items with no suffix are absolute. Items with an apostrophe (') 
suffix are 
program-relative items. Items with a plus sign (+) suffix are 
offsets, which LNK 
adds to the following external reference after it has been 
resolved. Therefore, 
such items do not occupy space in the program and do not cause 
the location 
counter to advance. This must be taken into account when locating 
items in a 
dump. EREF is an external reference with head of chain at 0083 
hex. Try 
following the chain. <p>

The &quot;load at&quot; item was generated by an ORG or DS 
pseudo-op. <p>

The absolute value of 0000 on the &quot;end prog&quot; item 
indicates that no 
starting address was specified. <p>
 
Availability <p>
 
Small-Mac is copyrighted; however, it is available to the general 
public for use 
without formal restrictions. Take it, use it, copy it, modify it, 
and give it away 
as you please. However, be sure to preserve the copyright 
notices.<p>
 
<b><a name="list7-1">LISTING 7-1</a><p></b> 
<PRE>
------------------------------------------------------------------FILE:MAC.C 
  /* 
  ** MAC.C -- Small-Mac Assembler -- Part 1: Mainline and Macro Functions 
  ** 
  **                  Copyright 1985 J. E. Hendrix 
  ** 
  ** Usage: MAC [-L] [-NM] [-P] [-S#] [object] source... 
  ** 
  ** -L         Generate an assembly listing on the standard output file. 
  ** 
  ** -NM        No macro processing. This speeds up the assembler somewhat. 
  **            Macro processing is NOT needed for Small-C 2.1 output files. 
  ** 
  ** -P         Pause on errors waiting for an operator response of CR. 
  ** 
  ** -S#        Set symbol table size to accept # symbols. 
  ** 
  ** object     Name of the object file to be output. It must have a REL 
  **            extension to be recognized as the output file. A drive 
  **            specifier is allowed. If not specified, the object code 
  **            will go into a file (on the default drive) bearing the same 
  **            name as the first source file, but with a REL extension. 
  ** 
  ** source...  Names of the source files to be assembled. The default,and 
  **            only allowed, extension is MAC. A drive specifier is allowed. 
  **            The named files will be assembled as one file concatenated 
  **            in the order given. 
  ** 
  **            NOTE: The module name in the REL file will be taken from 
  **            the first 6 characters of the object filename. 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;notice.h&quot; 
  #include &quot;mac.h&quot; 
  #include &quot;rel.h&quot; 
  #include &quot;mit.h&quot; 
  #define NOCCARGC 
 
  /* 
  ** symbol table 
  */ 
  int 
    stmax = STMAX,                 /* maximum symbols */ 
    stn,                           /* number of symbols loaded */ 

   *stp;                           /* symbol table pointer arrar */ 
  char 
   *st,                            /* symbol table buffer */ 
   *stend,                         /* end of symbol table */ 
   *stptr,                         /* st entry pointer */ 
    stsym[MAXLAB+1];               /* temporary symbol space */ 
 
  /* 
  ** macro definition table 
  */ 
  char 
   *mt,                            /* macro table buffer */ 
   *mtprev,                        /* previous mt entry */ 
   *mtnext,                        /* next available mt byte */ 
   *mtend,                         /* end of macro table */ 
   *mtptr;                         /* mt entry pointer */ 
 
  int 
    pass = 1,                      /* which pass? */ 
    badsym,                        /* bad symbol? */ 
    gotep,                         /* have an entry point? */ 
    gotxr,                         /* have an external reference? */ 
    gotlabel,                      /* have a label? */ 
    gotnam,                        /* have a name? */ 
    eom,                           /* end of module? */ 
    endv,                          /* END value */ 
    endt,                          /* END type */ 
    err,                           /* error? */ 
    lerr,                          /* line error flags */ 
    loc,                           /* location counter */ 
    lin,                           /* line counter */ 
    srcfd,                         /* source file fd */ 
    list,                          /* generate a listing? */ 
    lline,                         /* listing line, force 1st page heading */ 
    part1,                         /* part 1 of listing line printed? */ 
    ccnt,                          /* count of code characters printed */ 
    lpage,                         /* listing page */ 
    pause,                         /* pause on errors? */ 
    looks,                         /* number of looks to find instruction */ 
    macros = YES,                  /* macro processing? */ 
    mlnext,                        /* next macro label to assign */ 
    mlnbr[10],                     /* macro label numbers */ 
    mpptr[10],                     /* macro parameter pointers */ 

    defmode,                       /* macro definition mode */ 
    expmode;                       /* macro expansion mode */ 
 
  char 
   *ep,                            /* expression pointer */ 
   *lp,                            /* line pointer */ 
    line[MAXLINE],                 /* source line */ 
   *prior,                         /* prior ext ref in chain */ 
    srcfn[MAXFN+4],                /* source filename */ 
    objfn[MAXFN+4];                /* object filename */ 
 
 main(argc, argv) int argc, *argv; { 
   fputs(&quot;Small-Mac Assembler, &quot;, stderr); 
fputs(VERSION, stderr); 
   fputs(CRIGHT1, stderr); 
   getsw(argc, argv);            /* get command line switches */ 
   pass1(argc, argv);            /* build symbol table */ 
   pass2(argc, argv);            /* generate object code */ 
   if(err) abort(7);             /* sound the alarm */ 
   } 
 
 /* 
 ** pass one 
 */ 
 pass1(argc, argv) int argc, *argv; { 
   int max; 
   st  = calloc(STBUFSZ, 1);             /* allocate zeroed 
symbol table */ 
   stp = calloc(stmax, INTSZ); 
   stend = st + STBUFSZ;                 /* remember end of table */ 
   max = avail(YES);                     /* how much available? */ 
   max -= STACK + (MAXOPEN * OHDOPEN);   /* calculate how much */ 

   mt = mtnext = calloc(max, 1);         /* allocate space */ 
   mtend = mt + max - MAXLINE;           /* note end of macro buffer */ 
   dopass(argc, argv);                   /* do pass 1 */ 
   } 
 
 /* 
 ** pass two 
 */ 
 pass2(argc, argv) int argc, *argv; { 
   int i; 
   outrel = open(objfn, &quot;w&quot;);            /* open object file */ 
   putname();                            /* declare module name */ 
   putent();                             /* declare entry points */ 
   putsz();                              /* declare program size */ 
   pass = 2;                             /* signal pass 2 */ 
   dopass(argc, argv);                   /* do pass 2 */ 
   putexs();                             /* declare ep and xr symbols */ 
   putend();                             /* declare end of program */ 
   if(ferror(outrel)) err = YES; 
   close(outrel);                        /* close object file */ 
   } 
 
 /* 
 ** process passes 1 and 2 
 */ 
 dopass(argc, argv) int argc, *argv; { 
   int mop; 
   int i; 
   mlnext = lpage = i = lin: loc = 0;    /* reset everything */ 
   lline = 100;                          /* force page heading */ 

 while(getarg(++i, srcfn, MAXFN, argc, argv) != EOF) { 
   if(srcfn[0] == '-') continue; 
   if(extend(srcfn, SRCEXT, OBJEXT)) continue; 
   srcfd = open(srcfn, &quot;r&quot;);           /* open source file */ 
   eom = NO;                           /* not end of module */ 
   goto input; 
   while(YES) { 
     poll(YES); 
     ++lin; lerr = 0;                  /* bump line counter &amp; zero errors */ 
     part1 = NO;                       /* part 1 of line not listed */ 
     begline();                        /* begin a listing line */ 

     if(macros == NO) { 
       dolabel();                      /* do label and find next field */ 
       if(!domach()) doasm();          /* machine or assembler instr? */ 
       } 
     else { 
       lp = line; 
       lp = getsym(lp, NO); 
       if(!(mop = macop()) &amp;&amp; gotnam) {/* 2nd field a token? */ 
         lp = skip(1, line);           /* no, try first */ 
         mop = macop(); 
         } 
       if(defmode) {                   /* definition mode */ 
         if(mop == ENDM) defmode = NO; 
         if(pass == 1) putmac();       /* put line in macro table */ 
         } 
       else {                          /* copy or expansion mode */ 
         if(mop == CALL) {             /* enter expansion mode */ 

           expmode = YES; 
           putparm();                  /* save parameters */ 
           dolabel();                  /* process label */ 
           } 
         else if(mop == MACRO) {       /* enter definition mode */ 
           defmode = YES; 
           if(pass == 1) newmac();     /* init new macro in table */ 
           } 
         else if(mop == ENDM) {        /* leave expansion mode */ 

           expmode = NO; 
           } 
         else { 
           if(expmode) replace(); 
           dolabel();                  /* do label and find next field */ 
           if(!domach()) doasm();      /* machine or assembler instr? */ 
           } 
        } 
      } 
    endline();                         /* end a listing line */ 
    if(pass == 2) gripe();             /* gripe about errors */ 
    if(expmode) getmac();              /* fetch next macro line */ 
         else { 
           input: 
           if(eom) break; 
           if(!fgets(line, MAXLINE, srcfd)) error(&quot;- Missing END&quot;); 
           } 
         } 
       if(defmode) {err = YES; puts(&quot;- Missing ENDM&quot;);} 

       close(srcfd);                       /* close source file */ 
       } 
      } 
 
    /* 
    ** can line take more? 
    */ 
    cantake(i, need) int i, need; { 
      return (i &lt; (MAXLINE - 3) - need); 
      } 
 
    /* 
    ** get a line from the macro buffer 
    */ 
    getmac() { 
      char *cp; cp = line; 
      while(*cp++ = *mtptr++) ; 
      } 
 
    /* 
    ** get switches from command line 
    */ 
    getsw(argc, argv) int argc, *argv; { 
      char arg[MAXFN+4]; int i, j, len; 
      i = 0; 
      while(getarg(++i, arg, MAXFN, argc, argv) != EOF) { 
        if(arg[0] == '-') { 
               if(toupper(arg[1]) == 'L') list: YES; 
          else if(toupper(arg[1]) == 'P') pause = YES; 
          else if(toupper(arg[1]) == 'N' &amp;&amp; 
                  toupper(arg[2]) == 'M') macros = NO; 
          else if(toupper(arg[1]) == 'S') { 
            len = utoi(arg + 2, &amp;j); 
            if(len &gt; 0 &amp;&amp; !arg[len + 2]) stmax = j; 
            else usage(); 
            } 
          else usage(); 
          } 
        else { 
          if(extend(arg, OBJEXT, OBJEXT) || !*objfn) { 
            if(arg[1] == ':') j = 2; else j = 0; 
            strcpy(objfn, arg + j); 
        } 
      } 
    } 
  } 
 
 /* 
 ** recognize macro operation 
 */ 
 macop() { 
   if(fldcmp(lp, &quot;ENDM&quot; ) == 0) return (ENDM); 
   if(fldcmp(lp, &quot;MACRO&quot;) == 0) return (MACRO); 
   if(!expmode &amp;&amp; !defmode &amp;&amp; mtfind()) return (CALL); 
   return (NO); 
   } 
 
 /* 
 ** test for macro buffer overflow 
 */ 
 macover(ptr) char *ptr; { 
   if(ptr &gt; mtend) error(&quot;- Macro Buffer Overflow&quot;); 

   } 
 
 /* 
 ** find stsym in macro table 
 ** return true if found, else false 
 ** leave mtptr pointing to body of desired macro 
 */ 
 mtfind() { 
   if(atend(*lp) == 0) { 
     mtptr = mt; 
     do { 
       if(fldcmp(lp, mtptr + MTNAM) == 0) { 
         mtptr += MTNAM; 
         mtptr += strlen(mtptr) + 1; 
         return (YES); 
         } 
       mtptr = getint(mtptr); 
       } while(mtptr); 
     } 
   return (NO); 
   } 
 
 /* 
 ** establish new macro 
 */ 
 newmac() { 
   int i; i = 0; 
   if(!gotnam || badsym) symerr(); 
   else { 
     macover(mtnexu); 
     if(mtprev) putint(mtprev, mtnext); 
     mtprev = mtnext; 
     putint(mtnext, 0); 
     mtnext += INTSZ; 
     while(*mtnext++ = stsym[i++]) ; 
     } 
   } 
 /* 
 ** put a line in the macro buffer 
 */ 
 putmac() { 
   char *cp; cp = line; 
   macover(mtnext);              /* will buffer take it? */ 
   while(*mtnext++ = *cp++) ;    /* copy everything */ 
   } 
 
 /* 
 ** save macro call parameters in macro buffer 
 ** and reset macro labels 
 */ 
 putparm() { 
   int i, dlm; char *cp; 
   i = -1; cp = mtnext; 
   lp = skip(2, lp);                     /* skip to parameters */ 

   while(++i &lt; 10) { 
     mlnbr[i] = 0;                       /* null macro label nbr */ 
     while(isspace(*lp)) ++lp; 
     if(atend(*lp) || *lp == ',') mpptr[i] = 0; 
     else { 
       macover(cp); 
       mpptr[i] = cp; 
       while(!atend(*lp) &amp;&amp; *lp != ',') { 
         if(*lp == '\&quot;' || *lp == '\'') {              /* string? */ 
           dlm = *lp; 
           while(!atend(*++lp)) { 
             if(*lp == dlm &amp;&amp; *++lp != dlm) break; 
             *cp++ = *lp; 
             } 
           } 
         else *cp++ = *lp++; 
         } 
       *cp++ = NULL; 
       } 
     if(*lp == ',') ++lp; 
     } 
  if(!atend(*lp)) parerr(); 
  } 
/* 
** replace parameters 
*/ 
replace() { 
  char lin[MAXLINE]; int ndx; 
  char *cp, *cp2;    int i; 
  strcpy(lin, line); cp = lin; i = 0; 
  do { 
    if(*cp == '?') {                           /* substitution marker? */ 
      if(isdigit(*++cp)) {                     /* parameter substitution? */ 
        ndx = *cp++ - '0' - 1;                 /* which one? */ 
        if(ndx &lt; 0) ndx = 9;                   /* make 0 mean 10 */ 
        if(cp2 = mpptr[ndx]) {                 /* got parameter? */ 
          while(*cp2)                          /* yes, copy it */ 

            if(cantake(i, 1)) line[i++]: *cp2++; 
          } 
        continue; 
        } 
      } 
    if(*cp == '@') {                           /* label substitution? */ 
      if(cantake(i, 1)) line[i++] = '@';       /* insert label prefix */ 
      if(isdigit(*++cp)) {                     /* which one? */ 
        ndx = *cp++ - '0'; 
        if(!mlnbr[ndx]) mlnbr[ndx] = ++mlnext; /* need new label number? */ 
        if(cantake(i, 5)) { 
          left(itou(mlnbr[ndx], line + i, 5)); /* insert label number */ 
          while(line[i]) ++i;                  /* bypass label number */ 
          } 
        continue; 
        } 
      } 
    if(cantake(i, 1)) line[i++] = *cp++; 
    else { 
      line[i++] = '\n'; 
      break; 
      } 
      } while(*cp); 
    line[i] = NULL; 
    } 
 
 /* 
 ** abort with a usage message 
 */ 
 usage() { 
   error(&quot;Usage: MAC [-L] [-NM] [-P] [-S#] [object] 
source...&quot;); 
   } 
 
----------------------------------------------------------- FILE:MAC2.C 
  /* 
  ** MAC2.C -- Small-Mac Assembler -- Part 2: Pass 1 and 2 Functions 
  ** 
  **              Copyright 1985 J. E. Hendrix 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;mac.h&quot; 
  #include &quot;rel.h&quot; 
  #include &quot;ext.h&quot; 
  #define NOCCARGC 
  extern int iloc;                        /* instr location */ 
 
  /* 
  ** add a new symbol to the symbol table 
  */ 
  addsym() { 
    char *dest, *sour; 
    if(*stptr) error(&quot;- Symbol Table Overflow&quot;); 
    stp[stn++] = stptr;                   /* set symbol pointer */ 
    dest = stptr; sour = stsym; 
    while(*dest++ = toupper(*sour++)); 
    } 
 
  /* 
  ** determine if an assembler instruction 
  */ 
  aifind() { 
    char *cp; cp = lp; 
    while(isgraph(*lp)) ++lp; 
    while(isspace(*lp)) ++lp; 
         if(fldcmp(cp, &quot;DW&quot;)  == 0) return (DW); 
    else if(fldcmp(cp, &quot;DB&quot;)  == 0) return (DB); 
    else if(fldcmp(cp, &quot;DS&quot;)  == 0) return (DS); 
    else if(fldcmp(cp, &quot;EXT&quot;) == 0) return (EX); 
    else if(fldcmp(cp, &quot;SET&quot;) == 0) return (SET); 
    else if(fldcmp(cp, &quot;EQU&quot;) == 0) return (EQU); 
    else if(fldcmp(cp, &quot;ORG&quot;) == 0) return (ORG); 
    else if(fldcmp(cp, &quot;END&quot;) == 0) return (END); 
    return (ERR); 
    } 
 
  /* 
  ** begin a line in the listing 
  */ 
  begline() { 
    char str[6]; 
    if(pass == 2 &amp;&amp; list) { 
      if(begpage()) { 
        puts(&quot;line [oc ---- object----  source&quot;); puts(&quot;&quot;); 
        lline += 2; 
        } 
      itou(lin, str, 5); fputs(str, stdout); 
      itox(loc, str, 6); fputs(str, stdout); 
      putchar(' '); ccnt = 0; ++lline; 
      } 
    } 
 
  /* 
  ** begin a page? 
  */ 
  begpage() { 
    char str[4]; 
    if(lline &gt;= 58) { 
      lline = 2; 
      ++lpage; 
      if(lpage &gt; 1) puts(&quot;\n\n\n\n\n\n\n&quot;); 
      fputs(&quot;file: &quot;, stdout); fputs(srcfn, stdout); 
      itou(lpage, str, 4); 
      fputs(&quot; page: &quot;, stdout); puts(str); puts(&quot;&quot;); 
      return (YES); 
      } 
    return (NO); 
    } 
 
  /* 
  ** detect assembler instruction and process it 
  */ 
  doasm() { 
    int j; 
    if(atend(*lp) &amp;&amp; (!stsym[0] || gotlabel)) return; 
    if((j = aifind()) == ERR) {           /* lp -&gt; 2nd field or end */ 
      lp = skip(1, line);                 /* lp -&gt; 1st field */ 
      j = aifind(); 
      stsym[0] = NULL;                    /* declare no symbol */ 

      } 
    switch(j) { 
      case EX: doext();        return; 
      case DW: dodat(INTSZ);   return; 
      case DB: dodat(1);       return; 
      case DS: doloc(YES);     return; 
      case ORG: doloc(NO);     return; 
      case SET: doval(SETBIT); return; 
      case EQU: doval(0);      return; 
      case END: doend();       return; 
      } 
    oprerr(); 
    } 
  /* 
  ** define data (DB &amp; DW) 
  */ 
  dodat(sz) int sz; { 
    int dlm; 
    while(!atend(*lp)) { 
      if(isspace(*lp) || *lp == ',') ++lp; 
      else if(*lp == '\&quot;' || *lp == '\&quot;) {              
  /* string? */ 
        dlm = *lp; 
        while(!atend(*++lp)) { 
          if(*lp == dlm &amp;&amp; *++lp != dlm) break; 
          if(pass == 2) {field = *lp; genabs(sz);} 
          else loc += sz; 
          } 
        } 
      else { 
        ep = lp;                                          /* expression? */ 
        expr(&amp;field, &amp;type); 
        lp = ep; 
        if(pass == 2) { 
          type &amp;= RELBITS; 
          if(type == ABS) genabs(sz); 
          else { 
            if(sz == 1) {relerr(); genabs(1);}   /* 1-byte relocatable? */ 
            else genrel();                       /* output relocatable item */ 
            } 
          } 
        else loc += sz; 
        } 
      } 
    } 
 
  /* 
  ** process END instruction 
  */ 
  doend() { 
    eom = YES;                                   /* flag end of module */ 
    onexpr(); 
    if((type &amp; RELBITS) == PREL) { 
      endt = PREL; 
      endv = field; 
      } 
    else if(field) relerr(); 
    } 
 
  /* 
  ** define external reference (EXT) 
  */ 
  doext() { 
    while(!atend(*lp)) { 
      while(isspace(*lp) || *lp == ',') {++lp; continue;} 
      lp = getsym(lp, NO);                        /* fetch the next symbol */ 
      if(badsym) {symerr(); continue;}            /* symbol error */ 
      else if(stfind()) {                         /* already in table? */ 
        if(stptr[STFLAG] &amp; (LABBIT|EQUBIT|SETBIT)) {rederr(); continue;} 
        } 
      else addsym();                              /* not yet defined */ 
      if(pass == 1) stptr[STFLAG] |= XRBIT|ABS;   /* 1st ext ref is ABS 0 */ 
      } 
    } 
 
  /* 
  ** detect label and stow it away 
  */ 
  dolabel() { 
    lp = skip(1, line);                   /* locate first field */ 
    lp = getsym(lp, NO);                  /* fetch a symbol */ 
    if(gotlabel) {                        /* got a label */ 
      if(badsym) {laberr(); return;} 
      if(stfind()) {                      /* already in table */ 
        if(pass == 1) { 
          if(stptr[STFLAG] &amp; (LABBIT|EQUBIT|SETBIT|XRBIT)) 
            {rederr(); return;} 
          } 
        else if(stptr[STFLAG] &amp; (LABBIT2|EQUBIT|SETBIT|XRBIT)) 
          {rederr(); return;} 
        else stptr[STFLAG] |= LABBIT2; 
        } 
      else addsym();                      /* not defined, stow it */ 
      if(pass == 1) { 
        putint(stptr + STVALUE, loc);     /* value */ 
        if(gotep)                         /* flags */ 
             stptr[STFLAG] = LABBIT|PREL|EPBIT; 
        else stptr[STFLAG] = LABBIT|PREL; 
        } 
      } 
    } 
 
  /* 
  ** set location counter (ORG, DS) 
  */ 
  doloc(bump) int bump; { 
    if(onexpr()) { 
      if(bump) field = loc += field; 
      else if(loc &lt;= field) loc = field; 
      else bakerr(); 
      if(pass == 2) {item = SETLC; type = PREL; putrel();} 
      } 
    } 
 
  /* 
  ** detect machine instruction and process it 
  */ 
  domach() { 
    char *fmt, *cp; 
    if(gotlabel) cp = lp; 
    else         cp = skip(1, line);      /* backup if no label */ 
    if(fmt = find(cp)) {                  /* machine instruction? */ 
      fmt += INTSZ;                       /* locate format byte in mit */ 
      if(pass == 2) domac2(fmt);          /* do pass 2 processing */ 
      else loc += (*fmt &amp; 3) + 1;         /* bump location counter */ 
      return (YES); 
      } 
    return (NO);                          /* may be pseudo-op */ 
    } 
 
  /* 
  ** detect machine instruction and generate object code 
  */ 
  domac2(ptr) char *ptr; { 
    int format, len, ilen, pcr, t, v, opcode, holding; 
    format = getint(ptr++);               /* ptr is now 1 byte early */ 
    len = ilen = (format &amp; 7) + 1; 
    format &gt;&gt;= 3;                         /* first code/expr bit */ 
    iloc = loc;                           /* preserve istr loc for $ */ 
    holding = NO; 
    ep = expbuf;                          /* set ep for expr() */ 

    while(len-- &gt; 0) {                    /* for each byte of code */ 
      if(format &amp; 1) {                    /* expression */ 
        if(holding) { 
          holding = NO; 
          field = opcode + opadj;         /* adjust last byte before expr */ 
          opadj = 0; 
          genabs(1); 
          } 
        expr(&amp;v, &amp;t);                     /* evaluate next expression */ 
        format &gt;&gt;= 1;                     /* pc relative bit */ 
        if(format &amp; 1) { 
          if((t &amp; RELBITS) == PREL) { 
            v -= ilen + iloc;             /* calc offset from this instr */ 
            t = (t &amp; ~RELBITS) + ABS;     /* now abs, may be 1 byte */ 
            } 
          else v -= ilen;                 /* adjust offset from  this instr */ 
          pcr = YES;                      /* remember it's pc relative */ 
          } 
        else pcr = NO; 
        format &gt;&gt;= 1;                     /* size bit */ 
        if(format &amp; 1) {                   /* 2-byte expr */ 
          if(t &amp; XRBIT) {                  /* ext ref */ 
            if(v) {                        /* must offset from ext ref */ 
              item = XPOFF; 
              type = ABS; 
              field = v; 
              listcode(2, &quot;+ &quot;);           /* list offset */ 
              putrel();                    /* write 2-byte offset */ 
              } 
            field = prior;                 /* will link to prior ref */ 
            } 
          else field = v;                  /* expr value */ 
          if((t &amp; RELBITS) == ABS) 
               genabs(2);                  /* write 2 absolute bytes */ 
          else genrel();                   /* write 2 relocatable bytes */ 
          --len; 
          } 
        else {                             /* 1-byte expr */ 
          if((t &amp; RELBITS) == PREL) 
            relerr();                      /* 1 byte can't be relocatable */ 
          if(pcr &amp;&amp; (v &gt; 127 || v &lt; -128)) 
            rngerr();                      /* range error */ 
          field = v;                       /* expr value */ 
          genabs(1);                       /* write 1 absolute byte */ 
          } 
        } 
      else {                               /* code byte */ 
        if(holding) { 
          field = opcode;                  /* don't adjust, not last byte */ 
          genabs(1);                       /* write prior code byte */ 
          } 
        opcode = *++ptr &amp; 255;             /* hold this one, may be more */ 
        holding = YES; 
        } 
      format &gt;&gt;= 1; 
      } 
    if(holding) { 
      field = opcode + opadj; 
      genabs(1);                           /* write last code byte */ 
      } 
    } 
 
  /* 
  ** define a symbol value (SET, EQU) 
  */ 
  doval(set) int set; { 
    char *ptr; int found; 
    if(!stsym[0] || badsym || gotlabel) {merr(); return;} 
    if((found = stfind()) == 0) addsym(); /     /* not defined */ 

    ptr = stptr;                                  /* preserve stptr */ 
    onexpr();                                     /* evaluate expression */ 
    if(pass == 1 || set) { 
      if(found == 0 || ptr[STFLAG] &amp; set) { 
        putint(ptr + STVALUE, field);             /* value */ 
        ptr[STFLAG] = set|type;                   /* flags */ 
        } 
      else rederr(); 
      } 
    else if(ptr[STFLAG] &amp; (LABBIT|EQUBIT|SETBIT|XRBIT)) 
rederr(); 
    else ptr[STFLAG] |= EQUBIT; 
    if(pass == 2) {                               /* list value */ 
      if((ptr[STFLAG] &amp; RELBITS) == PREL) 
           listcode(2, &quot;' =&quot;); 
      else listcode(2,&quot; =&quot;); 
      } 
    } 
 
  /* 
  ** end a line in the listing 
  */ 
  endline() { 
    char *cp; int col; col = 0; 
    if(pass == 2 &amp;&amp; list) { 
      if(part1) puts(&quot;&quot;); 
      else { 
        part1 = YES; 
        while(ccnt++ &lt; 16) putchar(' '); 
        cp = line; 
        while(*cp) { 
          if(*cp != '\t') {++col; putchar(*cp++);} 
          else {do putchar(' '); while(++col % 8); ++cp;} 
          } 
        } 
      } 
    } 
 
  /* 
  ** generate an absolute value of sz bytes 
  */ 
  genabs(sz) int sz; { 
    listcode(sz, &quot;&quot;); 
    loc += sz;                            /* bump location counter */ 
    item = ABS; 
    while(sz--) {putrel(); field &gt;&gt;= 8;} 
    } 
 
  /* 
  ** generate a relocatable item 
  */ 
  genrel() { 
    listcode(2, &quot;' &quot;); 
    loc += 2;                      /* bump location counter */ 
    item = PREL; 
    putrel();                      /* write 2-byte relocatable item */ 
    }   
    
  /* 
  ** gripe about errors in a line 
  */ 
  gripe() { 
    if(lerr) { 
      if(!list) outerr(line); 
      if(lerr &amp;    1) outerr(&quot;- Backward Movement\n&quot;); 
      if(lerr &amp;    2) outerr(&quot;- Bad Number\n&quot;); 
      if(lerr &amp;    4) outerr(&quot;- Bad Expression\n&quot;); 

      if(lerr &amp;    8) outerr(&quot;- Bad Label\n&quot;); 
      if(lerr &amp;   16) outerr(&quot;- Bad Operation\n&quot;); 
      if(lerr &amp;   32) outerr(&quot;- Redundant Definition\n&quot;); 
      if(lerr &amp;   64) outerr(&quot;- Bad Symbol\n&quot;); 
      if(lerr &amp;  128) outerr(&quot;- Relocation Error\n&quot;); 
      if(lerr &amp;  256) outerr(&quot;- Undefined Symbol\n&quot;); 
      if(lerr &amp;  512) outerr(&quot;- Bad Parameter\n&quot;); 
      if(lerr &amp; 1024) outerr(&quot;- Range Error\n&quot;); 
      if(pause) wait(); 
      outerr(&quot;\n&quot;); 
      err = YES; 
      } 
    } 
 
  bakerr() {lerr |=    1;} 
  numerr() {lerr |=    2;} 
  experr() {lerr |=    4;} 
  laberr() {lerr |=    8;} 
  oprerr() (lerr |=   16;} 
  rederr() {lerr |=   32;} 
  symerr() {lerr |=   64;} 
  relerr() {lerr |=  128;} 
  underr() {lerr |=  256;} 
  parerr() {lerr |=  512;} 
  rngerr() {lerr |= 1024;} 
   
  /* 
  ** list a code item 
  */ 
  listcode(sz, suff) int sz; char suff[]; { 
    int i; char str[3]; 
    if(list) { 
      i = sz + sz + strlen(suff); 
      if((ccnt + i) &gt; 16) {endline(); begline();} 
      while(sz--) { 
        if(sz) itox((field &gt;&gt; 8) &amp; 255, str, 3); 
        else   itox(field &amp; 255, str, 3); 
        if(*str == ' ') *str = '0'; 
        fputs(str, stdout); 
        } 
      fputs(suff, stdout); 
      ccnt += i; 
      } 
    } 
 
  /* 
  ** output an error line 
  */ 
  outerr(str) char *str; { 
    begpage(); fputs(str, stdout); ++lline; 
    } 
 
  /* 
  ** require one expression only 
  */ 
  onexpr() { 
    ep = lp; 
    expr(&amp;field, &amp;type); 
    if(atend(*ep)) return (YES); 
    experr(); 
    return (NO); 
    } 
 
  /* 
  ** output end of program and file 
  */ 
  putend() { 
    item = EPROG; type = endt; field = endv; putrel(); 
    item = EFILE; type = ABS;  field = 0;    putrel(); 
    } 
 
  /* 
  ** output entry points 
  */ 
  putent() { 
    char *cp; 
    cp = st; 
    while(cp &lt; stend) { 
      poll(YES); 
      if(*cp) { 
        if(cp[STFLAG] &amp; EPBIT) {        /* entry point */ 
          item = ENAME; 
          strncpy(symbol, cp, MAXSYM + 1); 
          putrel(); 
          } 
        } 
      cp += STENTRY; 
      } 
    } 
 
  /* 
  ** output entry point or external reference 
  */ 
    putex(cp, i) char *cp; int i; { 
      item = i; 
      type = cp[STFLAG] &amp; RELBITS; 
      field = getint(cp + STVALUE); 
      strncpy(symbol, cp, MAXSYM + 1); 
      putrel(); 
      } 
 
  /* 
  ** output ent pnt and ext ref symbols 
  */ 
  putexs() { 
    int i; char *cp; 
    ccnt = 0;                             /* init for show() */ 
    shell(0, stn - 1);                    /* sort the symbols */ 
    if(list &amp;&amp; !begpage()) {++lline; puts(&quot;&quot;);} 

    for(i = 0; i &lt; stn; ++i) { 
      poll(YES); 
      cp = stp[i]; 
      if(list) show(cp); 
      if(cp[STFLAG] &amp; XRBIT) putex(cp, XCHAIN); 
      if(cp[STFLAG] &amp; EPBIT) putex(cp, EPOINT); 
      } 
    puts(&quot;&quot;); 
    } 
 
  /* 
  ** output module name 
  */ 
  putname() { 
    int i, j; 
    item = PNAME; 
    if(objfn[1] == ':') i = 2; else i = 0; 
      = 0; 
    while(objfn[i] &amp;&amp; objfn[i] != '.' &amp;&amp; j &lt; MAXSYM) 
      symbol[j++] = objfn[i++]; 
      symbol[j] = NULL; 
    putrel(); 
    } 
 
  /* 
  ** output program size 
  */ 
  putsz() { 
    item = PSIZE; 
    type = PREL; 
    field =loc; 
    putrel(); 
    } 
 
  /* 
  ** shell sort the symbols 
  */ 
  shell(l, u) int l, u; { 
    int gap, i, j, k, jg; 
    gap = (u - l + 1) &gt;&gt; 1; 
    while(gap &gt; 0) { 
      i = gap + l; 
      while(i &lt;= u) { 
        j = i++- gap; 
        while(j &gt;= l) { 
          jg = j + gap; 
          if(strcmp(stp[j], stp[jg]) &lt;= 0) break; 
          k = stp[jg]; stp[jg] = stp[j]; stp[j] = k; 
          j -= gap; 
          } 
        } 
      gap &gt;&gt;= 1; 
      } 
    } 
  /* 
  ** show a symbol 
  */ 
  show(cp) char *cp; { 
    char str[5]; 
    begpage(); 
    itox(getint(cp + STVALUE), str, 5); fputs(str, stdout); 
    if((cp[STFLAG] &amp; RELBITS) == PREL) fputs(&quot;' &quot;, stdout); 
    else fputs(&quot;  &quot;, stdout); 
    fputs(cp, stdout); 
    ccnt += 6 + strlen(cp); 
    if(cp[STFLAG] &amp; LABBIT) {putchar(':'); ++ccnt;} 
    if(cp[STFLAG] &amp; EPBIT) {putchar(':'); ++ccnt;} 
    if(cp[STFLAG] &amp; XRBIT) {fputs(&quot;##&quot;, stdout); ccnt += 2;} 
    if(ccnt &lt; 60) 
      while(ccnt % 20) {putchar(' '); ++ccnt;} 
    else {puts(&quot;&quot;); ++lline; ccnt = 0;} 
    } 
 
  /* 
  ** find stsym in symbol table 
  ** leave stptr pointing to desired or null entry 
  ** return true if found, else false 
  */ 
  stfind() { 
    char *start; 
    stptr = start = st + hash(stsym, stmax) * STENTRY; 
    while(*stptr) { 
      if(strcmp(stsym, stptr) == 0) return (YES); 
      if((stptr += STENTRY) &gt;= stend) stptr = st; 
      if(stptr == start) break; 
      } 
    return (NO); 
    } 
 
------------------------------------------------------------- FILE:MAC3.C 
  /* 
  ** MAC3.C -- Small-Mac Assembler -- Part 3: Expression Analyzer 

  ** 
  **                  Copyright 1985 J. E. Hendrix 
  ** 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;mac.h&quot; 
  #include &quot;rel.h&quot; 
  #include &quot;ext.h&quot; 
 
  #define NOCCARGC          /* no argument count passing */ 
 
  #define OR     1          /* |  */ 
  #define XOR    2          /* ^  */ 
  #define AND    3          /* &amp;  */ 
  #define EQ     4          /* == */ 
  #define NE     5          /* != */ 
  #define LE     6          /* &lt;= */ 
  #define GE     7          /* &gt;= */ 
  #define LT     8          /* &lt;  */ 
  #define GT     9          /* &gt;  */ 
  #define RSH   10          /* &gt;&gt; */ 
  #define LSH   11          /* &lt;&lt; */ 
  #define PLUS  12          /* +  */ 
  #define MINUS 13          /* -  */ 
  #define MULT  14          /* *  */ 
  #define DIV   15          /* /  */ 
  #define MOD   16          /* %  */ 
  #define CPL   17          /* ~  */ 
  #define NOT   18          /* !  */ 
  #define LPN   19          /* (  */ 
  #define RPN   20          /* )  */ 
  #define LOC   21          /* $  */ 
  #define SYM   22          /* symbol */ 
  #define NUM   23          /* number */ 
  #define EOE   24          /* end of expr */ 
 
  int 
    number,                         /* value of numeric token */ 
    iloc,                           /* instruction location */ 
    ct;                             /* current token */ 
 
  int                               /* operators by precedence level */ 
    l1ops[] =   {OR, NULL}, 
    l2ops[] =   {XOR, NULL}, 
    13ops[] =   {AND, NULL}, 
    l4ops[] =   {EQ, NE, NULL}, 
    l5ops[] =   {LE, GE, LT, GT, NULL}, 
    l6ops[] =   {LSH, RSH, NULL}, 
    l7ops[] =   {PLUS, MINUS, NULL}, 
    l8ops[] =   {MULT, DIV, MOD, NULL}; 
 
  /* 
  ** evaluate the next expression at ep 
  ** caller must set ep 
  */ 
  expr(value, type) int *value, *type; { 
    ct = NULL;                            /* no current token */ 
    if(token(EOE)) { 
      *value = 0; *type = ABS;            /* null expression */ 
      return; 
      } 
    if(!level1(value, type) || ct != EOE) experr(); 
    } 
 
  level1(v, t) int *v, *t; {return (down(l1ops, level2, v, t));} 
  level2(v, t) int *v, *t; {return (down(l2ops, level3, v, t));} 
  level3(v, t) int *v, *t; {return (down(l3ops, level4, v, t));} 
  level4(v, t) int *v, *t; {return (down(l4ops, level5, v, t));} 
  level5(v, t) int *v, *t; {return (down(l5ops, level6, v, t));} 
  level6(v, t) int *v, *t; {return (down(l6ops, level7, v, t));} 
  level7(v, t) int *v, *t; {return (down(l7ops, level8, v, t));} 
  level8(v, t) int *v, *t; {return (down(l8ops, unary,  v, t));} 
 
  unary(v, t) int *v, *t; { 
    if(token(CPL)) {                    /* ~ */ 
    if(!unary(v, t)) return (NO); 
    *V = ~*V; 
    goto check; 
    } 
  else if(token(NOT)) {                 /* ! */ 
    if(!unary(v ,t)) return (NO); 
    *v = !*v; 
    goto check; 
    } 
  else if(token(MINUS)) {               /* - */ 
    if(!unary(v, t)) return (NO); 
    *v = -*v; 
    check: 
    if(*t &amp; RELBITS) relerr();          /* can't be relocatable */ 
    *t &amp;: ~RELBITS;                     /* force ABS */ 
    return (YES);                       /* lie about it */ 
    } 
  else return (primary(v, t)); 
  } 
 
  primary(v, t) int *v, *t; { 
    int ok; 
    if(token(LPN)) {                           /* ( */ 
      ok = level1(v, t); 
      if(token(RPN)) return(ok); 
      return (NO); 
      } 
    *t = ABS; *v = 0;                          /* defaults */ 
    if(token(NUM)) {                           /* number */ 
      *v = number; 
      return (YES); 
      } 
    else if(token(LOC)) {                      /* $ */ 
      *v = iloc; 
      *t = PREL; 
      return (YES); 
      } 
    else { 
      if(token(SYM)) {                         /* symbol */ 
        if(stfind()) { 
          *t = stptr[STFLAG]; 
          if(!(stptr[STFLAG] &amp; XRBIT)) { 
            if(gotxr) rederr(); 
            *v = getint(stptr + STVALUE); 
            } 
          else goto doxr;                      /* ext ref */ 
          } 
        else if(gotxr) {                       /* define new ext ref */ 
          addsym();                               /* symbol */ 
          *t = XRBIT|ABS;                         /* 1st ext ref is ABS 0 */ 
          doxr: 
          prior = getint(stptr + STVALUE);        /* save prior ptr */ 
          putint(stptr + STVALUE, loc);           /* this becomes prey */ 
          stptr[STFLAG] |= XRBIT|PREL;            /* ext ref is relative */ 
          } 
        else underr();                            /* undefined */ 

        return (YES); 
        } 
      } 
    return (NO); 
    } 
 
  /* 
  ** drop to a lower level 
  */ 
  down(ops, level, v, t) int *ops, (*level)(), *v, *t; { 
    int *op; 
    if(!(*level)(v, t)) return (NO); 
    op =--ops; 
    while(*++op) { 
      if(token(*op)) { 
        if(!down2(*op, level, v, t)) return (NO); 
        if(token(EOE)) return (YES); 
        op =ops; 
        } 
      } 
    return (YES); 
    } 
 
  /* 
  ** binary drop to a lower level 
  */ 
  down2(oper, level, v, t) int oper, (*level)(), *v, *t; { 
    int ok, vr, tr, tl; 
    ok = (*level)(&amp;vr, &amp;tr); 
    *v = binary(*v, oper, vr);                    /* apply operator */ 
    tl = *t &amp; RELBITS; 
    *t = (*t | tr) &amp; ~RELBITS;     /* merge flag bits &amp; default to ABS */ 
    tr &amp;= RELBITS; 
    if(tl == ABS) { 
      if(tr == ABS) return (ok);                  /* abs &lt;oper&gt; abs */ 
      else {                                      /* abs &lt;oper&gt; rel */ 
        if(oper == PLUS) {*t |= PREL; return (ok);} 
        return (NO); 
        } 
      } 
    else {                                        /* rel &lt;oper&gt; abs */ 
      if(tr == ABS) { 
        switch(oper) { 
          case PLUS: case MINUS: 
          *t |= PREL; 
          return (ok); 
          } 
        return (NO); 
        } 
      else {                                       /* rel &lt;oper&gt; rel */ 
        switch(oper) { 
          case MINUS: 
          case EQ: case LT: case LE: 
          case NE: case GT: case GE: 
          return (ok); 
          } 
        return (NO); 
        } 
      } 
    } 
 
  /* 
  ** apply a binary operator 
  */ 
  binary(left, oper, right) int left, oper, right; { 
    switch(oper) { 
      case OR:    return (left  |  right); 
      case XOR:   return (left  ^  right); 
      case AND:   return (left  &amp;  right); 
      case EQ:    return (left  == right); 
      case NE:    return (left  != right); 
      case LE:    return (left  &lt;= right); 
      case GE:    return (left  &gt;= right); 
      case LT:    return (left  &lt;  right); 
      case GT:    return (left  &gt;  right); 
      case RSH:   return (left  &gt;&gt; right); 
      case LSH:   return (left  &lt;&lt; right); 
      case PLUS:  return (left  +  right); 
      case MINUS: return (left  -  right); 
      case MULT:  return (left  *  right); 
      case DIV:   return (left  /  right); 
      case MOD:   return (left  %  right); 
      } 
    return (NULL); 
    } 
 
  /* 
  ** scan for next token 
  */ 
  token(want) int want; { 
    int len; 
    if(ct) return (found(want, ct));       /* already have a token */ 
    while(isspace(*ep)) ++ep; 
    switch(*ep++) { 
      case '|': return (found(want, OR)); 
      case '^': return (found(want, XOR)); 
      case '&amp;': return (found(want, AND)); 
      case '+': return (found(want, PLUS)); 
      case '-': return (found(want, MINUS)); 
      case '*': return (found(want, MULT)); 
      case '/': return (found(want, DIV)); 
      case '%': return (found(want, MOD)); 
      case '~': return (found(want, CPL)); 
      case '(': return (found(want, LPN)); 
      case ')': return (found(want, RPN)); 
      case '$': return (found(want, LOC)); 
      case ',': return (found(want, EOE)); 
      case '!': if(*ep++ == '=') return (found(want, NE));  --ep; 
                                 return (found(want, NOT)); 
      case '&lt;': if(*ep++ == '=') return (found(want, LE));  --ep; 
                if(*ep++ == '&lt;') return (found(want, LSH)); --ep; 
                                 return (found(want, LT)); 
      case '&gt;': if(*ep++ == '=') return (found(want, GE));  --ep; 
                if(*ep++ == '&gt;') return (found(want, RSH)); --ep; 
                                 return (found(want, GT)); 
      case '=': if(*ep++ == '=') return (found(want, EQ));  --ep; 
      } 
    --ep; 
    ep = getsym(ep, YES); if(stsym[0]) {return (found(want, SYM));} 
    if(len = getnum(ep))    {ep += len; return (found(want, NUM));} 
    if(atend(*ep))                      return (found(want, EOE)); 
    return (NO); 
    } 
 
  /* 
  ** what was found? 
  */ 
  found(want, have) int want, have; { 
    ct = have;                                    /* new current token */ 
    if(ct == want) {                              /* was it sought? */ 
      if(ct != EOE) ct = NULL;                    /* yes, pass it by */ 
      return (YES);                               /* caller has a hit */ 
      } 
    return (NO);                                  /* sorry, no hit */ 
    } 
 
  /* 
  ** get hex, dec, or oct number as binary value in number 
  ** return length of field processed, else zero 
 
  */ 
  getnum(at) char *at; { 
    int bump, len; char *end, *cp; 
    cp = at; 
    if((*cp == '\&quot; || *cp == '&quot;') &amp;&amp; *cp == cp[2]) {     /* quoted char */ 
      number = cp[1] &amp; 255; 
      return (3); 
      } 
    switch(*cp) { 
      case '0': case '1': case '2': case '3': case '4': 
      case '5': case '6': case '7': case '8': case '9': 
      end = cp; 
      bump = 1; 
      while(YES) { 
        switch(toupper(*end)) { 
           default: if(isxdigit(*end)) {++end; continue;} 
                    bump = 0; 
                    len = utoi(cp, &amp;number); break; 
          case 'Q': 
          case '0': len = otoi(cp, &amp;number); break; 
          case 'H': len = xtoi(cp, &amp;number); break; 
          } 
        break; 
        } 
      if(len != (end - cp)) numerr();     /* bad number */ 
      return ((end - at) + bump); 
      } 
    return (0);   } 
 
  /* 
  ** get a symbol into stsym 
  */ 
  getsym(at, ref) char *at; int ref; { 
    int j; 
    j = badsym = gotep = gotxr = gotlabel = 0; 
    if(!isdigit(*at)) { 
      while(YES) { 
        switch(toupper(*at)) { 
          case '#': 
            if(ref) {gotxr = YES; if(*++at == '#') ++at; break;} 
          default: 
            if(ref) break; 
            badsym = YES; 
          case 'A': case 'B': case 'C': case 'D': case 'E': 
          case 'F': case 'G': case 'H': case 'I': case 'J': 
          case 'K': case 'L': case 'M': case 'N': case '0': 
          case 'P': case 'Q': case 'R': case 'S': case 'T': 
          case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z': 
          case '0': case '1': case '2': case '3': case '4': 
          case '5': case '6': cape '7': case '8': case '9': 
          case '_': case '.': case '$': case '?': case '@': 
            if(j &lt; MAXLAB) stsym[j++] = toupper(*at); 
            ++at; 
            continue; 
          case ':': 
            gotlabel = YES; 
            if(*++at == ':') {gotep = YES; ++at;} 
          case ' ': case '\t': case '\n': 
          case ',': case NULL: case COMMENT: 
          } 
        while(isspace(*at)) ++at; 
        break; 
        } 
      } 
    stsym[j] = NULL; 
    if(stsym[0] &amp;&amp; !gotlabel) gotnam = YES; else gotham = NO; 
    return (at); 
    } <p>
</PRE> 
<b><a name="list7-2">LISTING 7-2</a><p></b> 
<PRE> 
-------------------------------------------------------------FILE:LNK.C 
 
  /* 
  ** LNK.C -- Small-Mac Linkage Editor 
  ** 
  **                    Copyright 1985 J. E. Hendrix 
  ** 
  ** Usage: LNK [-B] [-G#] [-M] program [module/library...] 
  ** 
  ** -B                 A BIG program is being linked, so use all 
  **                    of free memory for the symbol table and load the 
  **                    program to disk entirely. This is slower but it 
  **                    gets the job done. 
  ** 
  ** -G#                Make program absolute at address # (hex) and 
  **                    output as &quot;program. LGO&quot; instead of &quot;program. COM&quot;. 
  ** 
  ** -M                 Monitor linking activity. 
  ** 
  ** program            A file specifier for the program being linked. 
  **                    The default, and only allowed, extension is REL. 
  ** 
  ** module/library...  A list of zero or more module (.REL) and/or 
  **                    library (.LIB) files. Each module is linked to 
  **                    the program and the libraries are searched for 
  **                    just those modules which satisfy one or more 
  **                    unresolved external references. 
  ** 
  ** NOTE: Merely declaring a symbol to be external will cause 
  ** it's module to be loaded. It need not actually be referenced. 
  ** 
  ** NOTE: The symbol TMNAME is defined to be the name of the 
  ** terminal module; i.e., the module which must be loaded last 
  ** of all. That module contains special code which identifies 
  ** the physical end of the program and the beginning of free 
  ** memory. The linker is sensitive to its name and waits until 
  ** all other modules are loaded before loading the terminal module. 
  ** 
  ** The absence of an extension, or a .REL extension, identifies a module; 
  ** whereas, a .LIB extension identifies a library. If necessary, a 
  ** library is rescanned to resolve backward external references between 
  ** modules within the library. Module files and libraries are processed 
  ** in the order in which they occur in the command line. 
  ** 
  ** Drive Designators (e.g. B:): 
  **    - allowed with module and library names 
  **    - program drive designator locates the input .REL file 
  **    - output goes to the default drive 
  ** 
  ** Filename Extensions: 
  **    - must specify .LIB with library name 
  **    - standard extensions are: 
  ** 
  **     .REL = relocatable object module 
  **     .LIB = library of object modules 
  **     .NDX = index to library (not user specified) 
  **     .COM = CP/M command file (default output) 
  **     .LGO = load-and-go file (-G# output) 
  **     .0$  = temporary overflow file 
  **     .R$  = temporary reference file 
  ** 
  ** Enter control-S to pause and control-C to abort. 
  ** 
  ** NOTE: Compile only with Small-C 2.1 (edit level 63) or later. 
  ** Edit 63 fixes CSYSLIB so that when it overflows a buffer while 
  ** writing into a file it will no longer assume that it is at the 
  ** end of the file. This prevents it from padding a sector with 
  ** 1A (hex) in the middle of a file when random access is being used. 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;notice.h&quot; 
  #include &quot;rel.h&quot; 
 
  #define NODEBUG                /* don't compile debug displays */ 
  #define NOCCARGC               /* don't pass arg counts to functions */ 
 
  #define NAMESIZE  15 
  #define MAXFIL    10 
  #define STACK    512           /* allow for stack space */ 
  #define AUXBUF  2048           /* aux buffer for reference file */ 
  #define MAXOPEN    4           /* maximum files opened */ 
  #define OHDOPEN  164           /* memery overhead per open file */ 
  #define COMBASE  259           /* 0100H + 3 */ 
  #define RET      201           /* RET instruction (OC9H) */ 
  #define JMP      195           /* JMP instruction (OC3H) */ 
  #define RES       -1           /* value of resolved ext ref */ 
  #define XRPLUS    -2           /* ext-ref-plus-offset flag */ 
  #define TMNAME  &quot;END&quot;          /* terminal module name */ 
  #define MODEXT &quot;.REL&quot; 
  #define LIBEXT &quot;.LIB&quot; 
  #define NDXEXT &quot;.NDX&quot; 
  #define COMEXT &quot;.COM&quot; 
  #define LGOEXT &quot;.LGO&quot; 
  #define OFLEXT  &quot;.0$&quot; 
  #define REFEXT  &quot;.R$&quot; 
 
  /* 
  ** symbol table definitions 
  */ 
  #define NXT        0           /* next-entry pointer */ 
  #define VAL        2           /* offset value */ 
  #define SYM        4           /* symbol */ 
  #define SSZ (SYM+MAXSYM+1)     /* size of table entry */ 
  #define HIGH 127               /* high-value byte */ 
  #define CUSHION (200*SSZ)      /* reserved for table at overflow point */ 
  char high[] = {HIGH,O};        /* high-value symbol */ 
 
  /* 
  ** global variables 
  */ 
  char 
   *xr,                          /* external reference */ 
   *nxt,                         /* next in ext ref chain */ 
   *ep,                          /* entry point */ 
   *buffer,                      /* beginning of code buffer */ 
   *bnext,                       /* next byte in code buffer */ 
   *sfree,                       /* head of freed entry list */ 
   *snext,                       /* next symbol table entry */ 
   *cloc,                        /* location counter */ 
   *cmod,                        /* module location */ 
   *cbase,                       /* base address */ 
   *csize,                       /* program size (fake unsigned) */ 
   *goloc,                       /* go location */ 
   *cdisk,                       /* disk overflow location */ 
   *epfirst,                     /* first entry point */ 
   *epprev,                      /* previous entry point */ 
   *epnext,                      /* next entry point */ 
   *xrfirst,                     /* first external reference */ 
   *xrprev,                      /* previous external reference */ 
   *xrnext,                      /* next external reference */ 
    modname[MAXSYM+1],           /* name of current module */ 
    infn   [NAMESIZE],           /* input filename */ 
    ndxfn  [NAMESIZE],           /* index filename */ 
    tmfn   [NAMESIZE],           /* terminal-module library name */ 
    csfn   [NAMESIZE],           /* code seg filename */ 
    crfn   [NAMESIZE],           /* code reg filename */ 
    outfn  [NAMESIZE];           /* output filename */ 
 
  int 
    lgo,          /* load-and-go format? */ 
    monitor,      /* monitor activity? */ 
    instr,        /* instruction to plant at 0000 */ 
    addr,         /* start address */ 
    ref,          /* reference to program relative item */ 
    big,          /* linking a big program? */ 
    xrplus,       /* value of offset for next ext ref */ 
    xrpflag=XRPLUS,       /* value of xrplus flag */ 
    ndxfd,        /* index fd */ 
    inblock,      /* block of next library member */ 
    inbyte,       /* byte in block of next library member */ 
    tmblock,      /* block of terminal module in tmfn */ 
    tmbyte,       /* byte of terminal module in tmblock */ 
    csfd,         /* code segment fd */ 
    crfd,         /* code relative index fd */ 
    outfd;        /* output fd */ 
 
  extern int Uchrpos[];          /* lives in CSYSLIB */ 
 
  main(argc,argv) int argc, argv[]; { 
    fputs(&quot;Small-Mac Linkage Editor, &quot;, stderr); 
    fputs(VERSION, stderr); 
    fputs(CRIGHT1, stderr); 
    getsw(argc, argv);           /* fetch and remember switches */ 
    getmem();                    /* acquire maximum memory buffer */ 
    phase1(argc, argv);          /* load and link */ 
    if(!okay()) abort(7);        /* quit early */ 
    phase2();                    /* generate final output */ 
    } 
 
  /* 
  ** get as much memory as possible for symbol table 
  */ 
  getmem() { 
    char sz[8]; 
    int max; 
 
    max = avail(YES);                     /* how much available? */ 
    max -= STACK + AUXBUF + (MAXOPEN * OHDOPEN); 
    buffer = bnext = malloc(max);         /* allocate space */ 
    snext = buffer + (max - SSZ);         /* first entry */ 
    sfree = 0;                            /* no reusable entries yet */ 
  #ifdef DEBUG 
    if(monitor) {itou(max, sz, 8); puts2(sz, &quot;Byte Buffer&quot;);} 
  #endif 
    newtbl(&amp;epfirst);                     /* set low and high ent pts */ 
    newtbl(&amp;xrfirst);                     /* set low and high ext refs */ 
    } 
 
  /* 
  ** get next module name 
  */ 
  getname() { 
    if(getrel() == PNAME) { 
      strcpy(modname, symbol); 
      return (YES); 
      } 
    if(item == EFILE) return (NO); 
    error2(infn, &quot; - Corrupted&quot;); 
    } 
 
  /* 
  ** read next entry from library index file 
  */ 
  getndx() { 
    if(read(ndxfd, &amp;inblock, 2) != 2 ||   /* next block */ 
       read(ndxfd, &amp;inbyte, 2) != 2) {    /* next byte in block */ 
      error2(&quot;- Error Reading &quot;, infn); 
      } 
    } 
 
  /* 
  ** get switches from command line 
  */ 
  getsw(argc, argv) int argc, *argv; { 
    char arg[NAMESIZE]; 
    int argnbr, b, len; 
    argnbr = 0; 
    while(getarg(++argnbr, arg, NAMESIZE, argc, argv) != EOF) { 
      if(arg[0] != '-') continue;                 /* skip file names */ 
      if(toupper(arg[1]) == 'G') { 
        lgo = YES; 
        len = xtoi(arg + 2, &amp;b); 
        if(len &gt;= 0 &amp;&amp; !arg[len + 2]) cbase = b; else usage(); 
        } 
      else if(toupper(arg[1]) == 'B') big = YES; 
      else if(toupper(arg[1]) == 'M') monitor = YES; 
      else usage(); 
      } 
    } 
 
  /* 
  ** is symbol an unresolved ext ref? 
  ** on return of true, xrnext -&gt; matching xr entry 
  */ 
  isunres() { 
    int i; 
    xrnext = getint(xrfirst); 
    while(xrnext) { 
      if((i = strcmp(symbol, xrnext + SYM)) &lt; 0) return (NO); 
      if(i == 0) return (YES); 
      xrnext = getint(xrnext); 
      } 
    return (NO); 
    } 
 
  /* 
  ** link external references to entry points 
  */ 
  link() { 
    int cspg, csch; 
    cspg = ctell(csfd);                   /* remember temp file position */ 
    csch = ctellc(csfd); 
    xrnext = getint(xrprev = xrfirst);    /* first external reference */ 
    epnext = getint(epfirst);             /* first entry point */ 

    while(YES) { 
      if(strcmp(xrnext + SYM, epnext + SYM) &gt; 0) {        /* xr &gt; ep */ 
        epnext = getint(epnext); 
        continue; 
        } 
      if(strcmp(xrnext + SYM, epnext + SYM) &lt; 0) {        /* xr &lt; ep */ 
        xrnext = getint(xrprev = xrnext); 
        continue; 
        } 
      if(*(xrnext + SYM) != HIGH) {                       /* xr = ep */ 
        resolve();                        /* resolve this ext ref */ 
        putint(xrprev, getint(xrnext));   /* delink from xr chain */ 
        putint(xrnext, sfree);            /* link to prey freed entry */ 
        sfree = xrnext;                   /* make first freed entry */ 
        xrnext = getint(xrprev);          /* advance to next ext ref */ 
        continue;                         /* same ext ref in diff modules? */ 
        } 
      break; 
      } 
    cseek(csfd, cspg, 0);                 /* restore temp file position */ 
    Uchrpos[csfd] = csch; 
    } 
 
  /* 
  ** load a module 
  */ 
  load() { 
    char str[8]; 
    epprev = epfirst;                     /* start at the very beginning */ 
    xrprev = xrfirst; 
    do { 
      poll(YES); 
      switch(getrel()) { 
        case  DSIZE: if(!field) break; 
            default: error(&quot;- Unsupported Link Item&quot;); 
        case    ERR: error(&quot;- Corrupt Module&quot;); 
        case  EPROG: if(type == PREL) { 
                       puts2(&quot;Start In &quot;, modname); 
                       goloc = field + cmod; 
                       } 
        case  ENAME: break;                       /* bypass enames */ 
        case XCHAIN: newsym(&amp;xrprev, &quot;xr&quot;); 
                     break; 
        case EPOINT: newsym(&amp;epprev, &quot;ep&quot;); 
                     break; 
        case  PSIZE: cmod = cloc; 
                     if(monitor) { 
                       itox(field, str, 8); 
                       fputs(str, stdout); fputs(&quot; Bytes at&quot;, stdout); 
                       itox(cloc, str, 6); 
                       fputs(str, stdout); fputs(&quot;'&quot;, stdout); 
                       itox(cloc+cbase, str, 6); 
                       fputs(str, stdout); puts2(&quot; &quot;, modname); 
                       } 
                     if(!csfd &amp;&amp; 
                       (big || (bnext + field) &gt; (snext - CUSHION))) { 
                       cdisk = cloc;              /* disk overflow point */ 
                       csfd = open(csfn, &quot;w+&quot;);   /* open overflow file */ 
  #ifdef DEBUG 
                       if(monitor) { 
                         itox(cdisk, str, 8); puts2(str, &quot; Overflow Point&quot;); 
                         } 
  #endif 
                       } 
                     break; 
       case   SETLC: field = field + cmod; 
                     while(cloc &lt; field) {                 /* adj loc ctr */ 
                       if(csfd) write(csfd, &quot;\0&quot;, 1); 
                       else *bnext++ = 0; 
                       ++cloc; 
                       } 
                       break; 
        case  XPOFF: write(crfd, &amp;xrpflag, 2)             /* flag xr plus */ 
                     write(crfd, &amp;field, 2);              /* xr offset */ 
                     break; 
        case   PREL: field = field + cmod; 
                     if(csfd) write(csfd, &amp;field, 2);     /* put on disk */ 
                     else {                               /* put in memory */ 
                       putint(bnext, field); 
                       bnext += 2; 
                       } 
                     write(crfd, &amp;cloc, 2);       /* reference for pass 2 */ 
                     cloc += 2; 
                     break; 
        case    ABS: if(csfd) write(csfd, &amp;field, 1);     /* put on disk */ 
                     else *bnext++ = field;               /* put in memory */ 
                     ++cloc; 
                     break; 
        } 
      } while(item != EPROG); 
    } 
 
  /* 
  ** create new file specifier from an old one 
  */ 
  newfn(dest, sour, ext) char *dest, *sour, *ext; { 
    if(sour[1] == ':' &amp;&amp; strcmp(ext, NDXEXT)) sour += 2; 
    while(*sour &amp;&amp; *sour != '.') *dest++ = *sour++; 
    strcpy(dest, ext); 
    } 
 
  /* 
  ** store new symbol table entry 
  ** they arrive in alphanumeric order 
  */ 
  newsym(prev, ts) int *prev; char *ts; { 
    char at[8], *cp, *new; 
    if(new = sfree) sfree = getint(sfree);                /* use old entry */ 
    else { 
      new = snext; 
      if((snext -= SSZ) &lt; bnext) error(&quot;- Must Specify -B Switch&quot;); 
      } 
    cp = *prev; 
    while(strcmp(symbol, cp + SYM) &gt;= 0) {                /* find position */ 
      *prev = cp; 
      cp = getint(cp); 
      } 
    putint(new, cp);                      /* point new entry ahead */ 
    putint(*prev, new);                   /* point prev entry here */ 
    *prev = new;                          /* this becomes prev entry */ 
    if(type == PREL) field = field + cmod;/* adjust for module location */ 
    putint(new + VAL, field);             /* load value */ 
    strcpy(new + SYM, symbol);            /* load symbol */ 
  #ifdef DEBUG 
    if(monitor) { 
      itox(getint(new + VAL), at, 8); 
      fputs(at, stdout); fputs(&quot; &quot;, stdout); 
      fputs(ts, stdout); fputs(&quot; &quot;, stdout); 
      puts(symbol); 
      } 
  #endif 
    } 
 
  /* 
  ** initial table entries 
  */ 
  newtbl(low) int *low; { 
    *low = snext;                         /* always points to low entry */ 
    strcpy(snext + SYM, &quot;&quot;);              /* store low symbol */ 
    putint(snext, snext - SSZ);           /* link to next (high) symbol */ 
    snext -= SSZ;                         /* now point to next entry */ 
    strcpy(snext + SYM, high);            /* store high symbol */ 

    putint(snext, 0);                     /* end of chain */ 
    snext -= SSZ;                         /* bump to next entry */ 
    } 
 
  /* 
  ** get next module name 
  */ 
  nxtmod() { 
    getndx();                             /* get location and */ 
    seek();                               /* go straight to next member */ 
    return (getname()); 
    } 
 
  /* 
  ** report the outcome and decide whether to quit 
  */ 
  okay() { 
    int err; char *eplast; 
    err = eplast = 0; 
    xrnext = getint(xrfirst);             /* first external reference */ 
    epnext = getint(epfirst);             /* first entry point */ 

    while(YES) { 
      poll(YES); 
      if(strcmp(xrnext + SYM, epnext + SYM) &gt; 0) {        /* ext &gt; ent */ 
        if(epnext == eplast) { 
           puts2(&quot;- Redundant: &quot;, xrnext + SYM); 
           err = YES; 
           } 
        eplast = epnext; 
        epnext = getint(epnext); 
        continue; 
        } 
      if(strcmp(xrnext + SYM, epnext + SYM) &lt; 0) {        /* ext &lt; ent */ 
        puts2(&quot;- Unresolved: &quot;, xrnext + SYM); 
        err = YES; 
        xrnext = getint(xrnext); 
        continue; 
        } 
      if(*(xrnext + SYM) != HIGH) {                       /* ext = ent */ 
        xrnext = getint(xrnext); 
        continue;                 /* same ext ref in diff modules? */ 
        } 
      break; 
      } 
    if(err) return (NO); 
    return (YES); 
    } 
 
  /* 
  ** load input files and library members 
  */ 
  phase1(argc, argv) int argc, *argv; { 
    char sz[8]; 
    int i, lib, eof; 
    eof = EOF; 
    cdisk = -1;                           /* high value for pointer */ 
    if(lgo) instr = RET;                  /* load and go format */ 
    else {instr = JMP; cbase = COMBASE;}  /* COM file format */ 
    i = 0; 
    while(getarg(++i, infn, NAMESIZE, argc, argv) != EOF) { 
      if(infn[0] == '-') continue;        /* skip switches */ 
      if(extend(infn, MODEXT, LIBEXT)) 
           lib = YES; 
      else lib = NO; 
      if(!*outfn) {                       /* first file name */ 
        if(lgo) newfn(outfn, infn, LGOEXT); 
        else    newfn(outfn, infn, COMEXT); 
        newfn(csfn, infn, OFLEXT); 
        newfn(crfn, infn, REFEXT); 
        crfd = open(crfn, &quot;w+&quot;);          /* open reference file */ 
        auxbuf(crfd, AUXBUF);   /* extra buffering lowers head movement */ 
        } 
      if(lib) search(); /* search library if unresolved ext refs */ 
      else { 
        inrel = open(infn, &quot;r&quot;);          /* must open */ 
        getname();                        /* program name */ 
        load();                           /* load module */ 
        link();                           /* link previous modules */ 
        close(inrel);                     /* must close */ 
        } 
      } 
    if(!*outfn) usage(); 
    if(*tmfn) {                           /* must get terminal module */ 
      inrel = open(tmfn, &quot;r&quot;); 
      inblock = tmblock; inbyte = tmbyte; 
      seek(); getname(); load(); link(); 
      close(inrel); 
      } 
    csize =cloc; 
    if(ferror(crfd)) error2(&quot;- Error Writing &quot;, crfn); 
    write(crfd, &amp;eof, 2); 
    rewind(crfd); 
    if(ferror(csfd)) error2(&quot;- Error Writing &quot;, csfn); 
    rewind(csfd); 
    itox(csize, sz, 8); puts2(sz, &quot; Bytes (hex)&quot;); 
    itou(csize, sz, 8); puts2(sz, &quot; Bytes (dec)&quot;); 
    } 
 
  /* 
  ** generate absolute output in COM or LGO format 
  ** 
  ** COM format: JMP &lt;start&gt; &lt;program&gt; 
  ** 
  ** LGO format: RET &lt;start&gt; &lt;prog-base&gt; &lt;prog-size&gt; &lt;program&gt; 
  */ 
  phase2() { 
     char at[5]; 
     outfd = open(outfn, &quot;w&quot;); 
     write(outfd, &amp;instr, 1);      /* plant first instruction */ 
     addr =cbase + goloc; 
     write(outfd, &amp;addr, 2);       /* with its address */ 
     if(lgo) { 
       write(outfd, &amp;cbase, 2);    /* where to load for execution */ 
       write(outfd, &amp;csize, 2);    /* how many bytes to load */ 
       } 
     cloc = -1;                    /* allow efficient pre-increment */ 
     readref();                    /* get first reference */ 
     while(++cloc &lt; csize) {       /* while more code */ 
       if(cloc != ref) {           /* not relative refereoce */ 
         if(cloc &lt; cdisk) 
           field = *(cloc + buffer); 
         else read(csfd, &amp;field, 1); 
         write(outfd, &amp;field, 1);  /* copy one byte as is */ 
           continue; 
           } 
         if(cloc &lt; cdisk)            /* get next 2-byte relative item */ 
           field = getint(cloc + buffer); 
         else read(csfd, &amp;field, 2); 
         field = field + cbase;      /* make absolute */ 
         if(xrplus) { 
           field += xrplus;          /* apply offset */ 
           xrplus = 0; 
           } 
         write(outfd, &amp;field, 2);    /* copy 2 bytes adjusted */ 
         readref();                  /* get next reference */ 
         ++cloc;                     /* need additional increment */ 
         } 
       if(ferror(outfd)) error2(&quot;- Error Writing &quot;, outfn); 
       close(outfd); 
       if(csfd) { 
         if(ferror(csfd)) error2(&quot;- Error Reading &quot;, csfn); 
         close(csfd); 
         delete(csfn); 
         } 
       if(ferror(crfd)) error2(&quot;- Error Reading &quot;, crfn); 
       close(crfd); 
       delete(crfn); 
       } 
 
  /* 
  ** read next reference 
  */ 
  readref() { 
    read(crfd, &amp;ref, 2);                  /* get next reference */ 
    if(ref == XRPLUS) {                   /* ext ref offset flag? */ 
      read(crfd, &amp;xrplus, 2);             /* yes, get offset value */ 
      read(crfd, &amp;ref, 2);                /* then get reference */ 
      } 
    } 
 
  /* 
  ** resolve external references to a given symbol 
  */ 
  resolve() { 
    char at[5]; 
    if(!(xr = getint(xrnext + VAL))) return;     /* head of ext ref chain */ 
    ep = getint(epnext + VAL);                   /* entry point address */ 
    do { 
  #ifdef DEBUG 
      if(monitor) { 
        poll(YES); 
        fputs(&quot;Resolving &quot;, stdout); 
        itox(xr, at, 5); fputs(at, stdout); 
        fputs(&quot; to &quot;, stdout); 
        itox(ep, at, 5); fputs(at, stdout); 
        puts2(&quot; &quot;, xrnext + SYM); 
        } 
  #endif 
      if(xr &lt; (disk) {                           /* in memory */ 
        nxt = getint(xr + buffer); 
        if(nxt == 0) ep += cbase;        /* end of chain is absolute */ 
        putint(xr + buffer, ep); 
        } 
      else {                                     /* on disk */ 
        xrseek(xr - cdisk); read(csfd, &amp;nxt, 2); 
        if(nxt == 0) ep += cbase;        /* end of chain is absolute */ 
        xrseek(xr - cdisk); write(csfd, &amp;ep, 2); 
        } 
      } while(xr = nxt); 
    } 
 
  /* 
  ** search a library 
  */ 
  search() { 
    int linked; 
    linked = NO; 
    newfn(ndxfn, infn, NDXEXT); 
    ndxfd = open(ndxfn, &quot;r&quot;); 
    inrel = open(infn, &quot;r&quot;); 
    while(YES) {                                 /* rescan till done */ 
      while(nxtmod()) { 
        if(strcmp(modname, TMNAME) == 0) {       /* will load this one last */ 
          strcpy(tmfn, infn); 
          tmblock = inblock; 
          tmbyte = inbyte; 
          continue; 
          } 
        while(getrel() == ENAME) { 
          poll(YES); 
          if(isunres()) {                        /* unresolved reference? */ 
            load();                              /* load module */ 
            link();                              /* link to previous ones */ 
            linked = YES; 
            break; 
            } 
          } 
        } 
     if(!linked) break; 
     linked = NO; 
     rewind(ndxfd); 
      } 
    close(ndxfd); 
    close(inrel); 
    } 
 
  /* 
  ** seek to next member in old library 
  */ 
  seek() { 
    if(inblock == EOF) error(&quot;- Premature End of Index&quot;); 
    if(cseek(inrel, inblock, 0) == EOF) 
      error(&quot;- Corrupt Library or Index&quot;); 
    Uchrpos[inrel] = inbyte; 
    inrem = 0;                    /* force getreL() to read a byte */ 
    } 
 
  /* 
  ** abort with a usage message 
  */ 
  usage() { 
    error(&quot;Usage: LNK [-B] [-G#] [-M] program [moduLe/Library...]&quot;); 
    } 
 
  /* 
  ** seek external reference 
  */ 
  xrseek(byte) int byte; { 
    if(cseek(csfd, (byte &gt;&gt; 7) &amp; 511, 0) == EOF) 
      error2(&quot;- Seek Error in &quot;, csfn); 
    Uchrpos[csfd] = byte &amp; 127; 
    } <p>
</PRE> 
<b><a name="list7-3">LISTING 7-3</a><p></b>
<PRE> 
--------------------------------------------------------------- FILE:LGO.C 
 
  /* 
  ** LGO.C -- Small-Mac Load-and-Go Loader 
  ** 
  **               Copyright 1985 J. E. Hendrix 
  ** 
  ** Usage: LGO [-G] [-M] program 
  ** 
  ** -G    Execute program after loading. 
  ** 
  ** -M    Monitor load address and size. 
  ** 
  ** &quot;Program&quot; is a file specifier for the program being loaded. 
  ** Default, and only allowed, extension is LGO. 
  ** 
  ** Enter control-S to pause and control-C to abort. 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;notice.h&quot; 
 
  #define NOCCARGC                /* don't pass arg counts to functions */ 
 
  #define NAMESIZE 15 
  #define STACK   256             /* allow for stack space */ 
  #define RET     201             /* RET instruction */ 
  #define LGOEXT &quot;.LGO&quot; 
 
  /* 
  ** global variables 
  */ 
  char 
   *base,                /* base address */ 
   *start,               /* starting address */ 
    infn[NAMESIZE];      /* input filename */ 
 
  int 
    infd,                /* input fd */ 
    size,                /* program size */ 
    monitor,             /* monitor activity? */ 
    go;                  /* execute? */ 
 
  /* 
  ** load program.LGO with format: 
  ** 
  **            RET &lt;start&gt; &lt;base&gt; &lt;size&gt; &lt;program&gt; 
  */ 
  main(argc,argv) int argc, argv[]; { 
    int i; char str[5]; 
    fputs(&quot;Small-Mac Load-and-Go Loader, &quot;, stderr); 
    fputs(VERSION, stderr); 
    fputs(CRIGHT1, stderr); 
    getsw(argc, argv);                             /* process switches */ 
    i = 0; 
    while(getarg(++i, infn, NAMESIZE, argc, argv) != EOF) /* get fn */ 
      if(infn[0] != '-') {i = 0; break;} 
    if(i) usage(); 
    extend(infn, LGOEXT, LGOEXT); 
    infd = open(infn, &quot;r&quot;); 
    read(infd, &amp;base, 1); 
    if(base != RET) error(&quot;- Invalid LGO Format&quot;); 
    read(infd, &amp;start, 2);                         /* get starting address */ 
    read(infd, &amp;base, 2);                          /* get base address */ 
    read(infd, &amp;size, 2);                          /* get program size */ 
    if(monitor) {                                  /* monitor? */ 

      fputs(&quot;From &quot;,    stdout); itox(base,      str, 5); fputs(str, stdout); 
      fputs(&quot;, To &quot;,    stdout); itox(base+size, str, 5); fputs(str, stdout); 
      fputs(&quot;, Size &quot;,  stdout); itox(size,      str, 5); fputs(str, stdout); 
      fputs(&quot;, Start &quot;, stdout); itox(start,     str, 5); puts(str); 
      } 
    malloc(STACK);        /* new machine stack */ 
    malloc(1);            /* leaves new stack address in HL */ 
    #asm 
    SPHL                  ; move stack 
    LXI H,O               ; CP/M return 
    PUSH H                ; re-stack CP/M return 
    #endasm 
    read(infd, base, size);                       /* load program */ 
    if(ferror(infd)) error2(&quot;- Error Reading &quot;, infn); 
    if(go) {              /* execute program? */ 
       start;             /* leaves starting address in HL */ 
       #asm 
       PCHL               ; Jump to start address with 
                          ; CP/M return on top of this stack. 
       #endasm 
       } 
     exit(0); 
     } 
 
  /* 
  ** get switches from command line 
  */ 
  getsw(argc, argv) int argc, *argv; { 
    char arg[NAMESIZE]; 
    int argnbr; argnbr = 0; 
    while(getarg(++argnbr, arg, NAMESIZE, argc, argv) != EOF) { 
      if(arg[0] != '-') continue;                 /* skip file names */ 
      if(toupper(arg[1]) == 'G') go = YES; 
      else if(toupper(arg[1]) == 'M') monitor = YES; 
      else usage(); 
      } 
    } 
 
  /* 
  ** abort with a usage message 
  */ 
  usage() { 
    error(&quot;Usage: LGO [-G] [-M] program&quot;); 
    } <p>
</PRE> 
<b><a name="list7-4">LISTING 7-4</a><p> </b>
<PRE>
------------------------------------------------------------ FILE:LIB.C 
  /* 
  ** LIB.C -- Small-Mac Library Manager 
  ** 
  **                  Copyright 1985 J. E. Hendrix 
  ** 
  ** Usage: LIB -{DPTUX}[A] library [module...] 
  ** 
  ** -D    delete named modules 
  ** -P[A] print named, or all (-PA), modules on stdout 
  ** -T[A] table of contents of named, or all (-TA), files on stdout 
  ** -U    update (adding/replace) named modules 
  **       (gets module names from stdin if not in command line) 
  ** -X[A] extract named, or all (-XA), modules 
  ** 
  **       The A suffix obviates prompting stdin for module 
  **       names when none are in the command line. This is handy for 
  **       eliminating operator intervention, especially in batch mode. 
  **       Ordinarily, when no modules are given in the command line, 
  **       LIB prompts the user (if stdin is not redirected) and 
  **       accepts one module name at a time from stdin. If none 
  **       are given (CR response to first prompt) and the command 
  **       switch is -P, -T, or -X then all members of the library are 
  **       processed. 
  ** 
  ** Drive Designators (e.g. B:): 
  **     allowed with any library and module names 
  **     new library and index go on same drive as old 
  **     will default to the default drive 
  ** 
  ** Filename Extensions: 
  **     do NOT specify with library or module names 
  **     standard extensions are: 
  ** 
  **     .REL = relocatable object module 
  **     .LIB = library of object modules 
  **     .NDX = index to library 
  **     .L$ = temporary new library 
  **     .N$ = temporary new index 
  ** 
  ** Enter control-S to pause and control-C to abort. 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;notice.h&quot; 
  #include &quot;rel.h&quot; 
 
  #define NOCCARGC               /* no argument count passing */ 
  #define NAMESIZE  15 
  #define MAXMODS  200 
  #define MODEXT &quot;.REL&quot; 
  #define LIBEXT &quot;.LIB&quot; 
  #define NDXEXT &quot;.NDX&quot; 
  #define L_EXT  &quot;.L$&quot; 
  define N_EXT   &quot;.N$&quot; 
  define HIGH      127           /* high-value byte */ 
 
  char 
   cmd[5],                        /* command switch */ 
   oldlib[NAMESIZE],              /* old library name */ 
   oldndx[NAMESIZE],              /* old index name */ 
   newlib[NAMESIZE],              /* new library name (temporary) */ 
   newndx[NAMESIZE],              /* new index name (temporary) */   
   *modname;                       /* points to module name buffer */ 
 
  int 
   *mptr,                        /* module name pointers */ 
   *mdone,                       /* done with module? */ 
    modules,                     /* count of modules to process */ 
    all,                         /* process all members? */ 
    inndx,                       /* input index fd */ 
    outndx,                      /* output index fd */ 
    oldblock,                    /* block of next input member */ 

    oldbyte,                     /* byte in block of next input member */ 
    newblock,                    /* block of next output member */ 
    newbyte;                     /* byte in block of next output member */ 
 
  int item2, type2, field2, inrel2, inrem2, inch2; 
  char sym2[NAMESIZE]; 
 
  main(argc,argv) int argc, argv[]; { 
    fputs(&quot;Small-Mac Library Manager, &quot;, stderr); 
    fputs(VERSION, stderr); 
    fputs(CRIGHT1, stderr); 
    mptr = calloc(MAXMODS, 2);     /* allocate zeroed memory */ 
    mdone = calloc(MAXMODS, 2); 
    if(getarg(1, cmd, 5, argc, argv) == EOF) usage(); 
    cmd[1] = toupper(cmd[1]); 
    cmd[2] = toupper(cmd[2]); 
    if(cmd[0] != '-' || (cmd[2] &amp;&amp; cmd[2] != 'A') || strlen(cmd) &gt; 3) usage(); 
    if(getarg(2, oldlib, NAMESIZE, argc, argv) == EOF) usage(); 
    extend(oldlib, LIBEXT, LIBEXT); 
    newfn(oldndx, oldlib, NDXEXT); 
    newfn(newlib, oldlib, L_EXT); 
    newfn(newndx, oldlib, N_EXT); 
    getmods(argc, argv);           /* gather switches and module names */ 
    switch(cmd[1]) { 
      case 'D': drop();    break; 
      case 'T': table();   break; 
      case 'U': update();  break; 
      case 'X': extract(); break; 
      case 'P': print();   break; 
       default: usage(); 
       } 
    } 
 
  /* 
  ** add module to library 
  */ 
  addmod(name) char *name; { 
    char *cp, nam[NAMESIZE]; 
    saverel();                    /* save REL variables */ 
    strcpy(nam, name); extend(ham, MODEXT, MODEXT); 
    inrel = open(ham, &quot;r&quot;); 
    cpymod(NO);                   /* do not already have header */ 
    close(inrel); 
    restrel();                    /* restore REL variables */ 
    strcpy(nam, name); 
    if(nam[1] == ':') cp = nam + 2; else cp = ham; 
    cp[MAXSYM] = NULL; 
    } 
 
  /* 
  ** close input library and index 
  */ 
  closein(mod1, mod2) char *modl, *mod2; { 
    close(inrel); 
    close(inndx); 
    } 
 
  /* 
  ** close output library and index 
  */ 
  closeup(mod1, mod2) char *mod1, *mod2; { 
    closein(); 
    endrel(); 
    close(outrel); 
    putndx(newblock, newbyte);                    /* index EFILE */ 
    putndx(EOF, EOF);                             /* terminate new index */ 
    close(outndx); 
    movfil(newlib, oldlib);                       /* take original names */ 
    movfil(newndx, oldndx); 
    } 
 
  /* 
  ** compare module names ignoring drive designators 
  */ 
  cmpmod(mod1, mod2) char *mod1, *mod2; { 
    char str1[NAMESIZE], str2[NAMESIZE]; 
    if(mod1[1] == ':') mod1 += 2; strncpy(str1, mod1, MAXSYM); 
    if(mod2[1] == ':') mod2 += 2; strncpy(str2, mod2, MAXSYM); 
    return (strcmp(str1, str2)); 
    } 
  /* 
  ** copy one module from inrel to outrel 
  */ 
  cpymod(hdr) int hdr; { 
    if(outndx) putndx(newblock, newbyte);  /* must not be extracting */ 
    if(hdr &amp;&amp; !putrel()) abort(7);         /* already have input header */ 
    do { 
      poll(YES); 
      if(getrel() == ERR || !putrel()) abort (7); 
      } while(item != EPROG); 
    fflush(outrel);               /* must empty aux buf for ctell() */ 
    newblock = ctell(outrel);     /* remember for next member */ 
    newbyte = ctellc(outrel); 
    if(newbyte == 128) {++newblock; newbyte = 0;} 
    } 
 
  /* 
  ** drop modules from library 
  */ 
  drop() { 
    char mod[NAMESIZE]; 
    if(modules == 0) error(&quot;- Delete by Name Only&quot;); 
    openup(); 
    while(nxtmod(mod)) { 
      if(match(mod, NO)) { 
        puts2(&quot;Deleted &quot;, mod); 
        continue; 
        } 
      cpymod(YES); 
      } 
    missing(); 
    closeup(); 
    } 
 
  /* 
  ** terminate REL or LIB file 
  */ 
  endrel() { 
    item = EFILE; 
    field = 0; 
    type = 0; 
    if(!putrel()) abort(7); 
    } 
 
  /* 
  ** extract files from library 
  */ 
  extract() { 
    char modnam[NAMESIZE]; 
    openin(); 
    while(nxtmod(modnam)) { 
      if(match(modnam, YES)) { 
        extend(modnam, MODEXT, MODEXT); 
        outrel = open(modnam, &quot;w&quot;); 
        cpymod(YES); 
        endrel(); 
        close(outrel); 
        puts2(&quot;Created &quot;, modnam); 
        } 
      } 
    missing(); 
    closein(); 
    } 
 
  /* 
  ** get module names 
  */ 
  getmods(argc, argv) int argc, argv[]; { 
    char *cp, *mp, name[NAMESIZE], fn[NAMESIZE]; 
    int err, eof, arg, i, j; 
    if(!(mp = modname = malloc(MAXMODS*10))) error(&quot;- Memory Overflow&quot;); 
    if((j = avail(NO)) &gt;= 0 &amp;&amp; j &lt; 512) { 
      puts(&quot;- Limited Stack Space&quot;); 
      err = YES; 
      } 
    all = YES;                    /* default to all modules */ 
    if(argc &gt; 3) arg = 3;         /* get module names from command line */ 
    else { 
      arg = 0;                    /* get module names from stdin */ 
      if(cmd[2] &amp;&amp; (cmd[1] == 'P' || cmd[1] == 'T' || cmd[1] == 'X')) { 
        modname[0] = HIGH;                /* high value */ 
        modname[1] = NULL; 
        return; 
        } 
      } 
    err = eof = NO; 
    while(modules &lt; MAXMODS-1) { 
      poll(YES); 
      if(arg) { 
        if(getarg(arg++, name, NAMESIZE, argc, argv)==EOF) {eof = YES; break;} 
        } 
      else { 
        if(!reqstr(&quot;Module Name: &quot;, name, NAMESIZE)) {eof = YES; break;} 
        } 
      all = NO;                           /* do selected modules only */ 
      if(cp = strchr(name, '.')) { 
        fputs(name, stdout); puts2(&quot; - Extension Forced to &quot;, MODEXT); 
        *cp = NULL; 
     err = YES; 
     } 
  if(cp = strchr(name, ':')) { 
    if(cp == name+1) ++cp;             /* set up next check */ 
    else { 
      puts2(name, &quot; - Invalid Format - Ignored&quot;); 
      goto ignore; 
      } 
    } 
  else cp = name;                      /* set up next check */ 
  if(strlen(cp) &gt; MAXSYM) { 
    strcpy(fn, cp); 
    fputs(fn, stdout); 
    fn[MAXSYM] = NULL; 
    puts2(&quot; - Will be Truncated to &quot;, fn); 
    err = YES;        /* assembler does actual truncation */ 
    } 
  if(cmd[1] == 'U') {                  /* REL file must exist */ 
    strcpy(fn, name); extend(fn, MODEXT, MODEXT); 
    if(i = fopen(fn, &quot;r&quot;)) fclose(i); 
    else { 
      puts2(name, &quot;- Can't Find - Ignored&quot;); 
      goto ignore; 
      } 
    } 
  for(i = 0; i &lt; modules; ++i) {       /* find place for module */ 
    if(cmpmod(mptr[i], name) &gt; 0) {    /* shift others up */ 
      for(j = modules; j &gt; i; --j) mptr[j] = mptr[j-1]; 
      break; 
      } 
    if(cmpmod(name, mptr[i]) == 0) {    /* already loaded */ 
      puts2(mp, &quot;- Duplicate Name - Ignored&quot;); 
      goto ignore; 
      } 
     } 
    mptr[i] = mp;                       /* load modname pointer */ 
    strcpy(mp, name);                   /* load modname buffer */ 

    while(*mp++) ;                      /* scoot to next address */ 
    ++modules;                          /* bump number of modules */ 
    continue; 
 
    ignore: 
    err = YES; 
    } 
  mptr[modules] = mp;                   /* load terminal pointer */ 
  *mp++ = HIGH;                         /* high value */ 
  *mp = NULL; 
  if(!eof) error(&quot;- Too Many Modules Specified&quot;); 
  if(err) { 
      fputs(&quot;\nContinue? &quot;, stderr); 
      fgets(name, NAMESIZE, stderr); 
      if(toupper(*name) != 'Y') exit(7); 
      } 
    } 
 
  /* 
  ** read an entry from the old index 
  */ 
  getndx() { 
    if(read(inndx, &amp;oldblock, 2) != 2 || /* next block*/ 
       read(inndx, &amp;oldbyte, 2) != 2)    /* next byte in block */ 
      error(&quot;- Error Reading Index&quot;); 
    } 
 
  /* 
  ** check if name matches module list 
  */ 
  match(name, quit) char *name; int quit; { 
    int i, done; 
    char *mp; 
    if(all) return(YES); 
    done = YES; 
    for(i = 0; i &lt; modules; ++i) { 
      if(cmpmod(mptr[i], name) == 0) { 
        mdone[i] = YES; 
        return(YES); 
        } 
      if(!mdone[i]) done = NO; 
      } 
    if(quit &amp;&amp; done) exit(0); 
    return(NO); 
    } 
 
  /* 
  ** print &quot;not in library&quot; messages 
  */ 
  missing() { 
    int i; 
    for(i = 0; i &lt; modules; ++i) 
      if(!mdone[i]) puts2(mptr[i], &quot;Was Not in Library&quot;); 
    } 
 
  /* 
  ** move file1 to file2 
  */ 
  movfil(file1, file2) char *file1, *file2; { 
    unlink(file2); 
    if(file2[1] == ':') file2 += 2; 
    if(rename(file1, file2)) error(&quot;- Can't Rename Files&quot;); 
    } 
 
  /* 
  ** create new filename from old filename and specified extension 
  */ 
  newfn(dest, sour, ext) char *dest, *sour, *ext; { 
    while(*sour &amp;&amp; *sour != '.') *dest++ = *sour++; 
    strcpy(dest, ext); 
    } 
 
  /* 
  ** get next module name 
  */ 
  nxtmod(name) char *name; { 
    seek();                                /* go straight to next member */ 
    if(getrel() == PNAME) { 
      strcpy(name, symbol); 
      return (YES); 
      } 
    if(item == EFILE) { 
      *name++ = HIGH;                      /* high value */ 
      *name = NULL; 
      return (NO); 
      } 
    error(&quot;- Corrupt Library or Index&quot;); 
    } 
 
  /* 
  ** open library and index for input 
  */ 
  openin() { 
    while(!(inrel = fopen(oldlib, &quot;r&quot;))) { 
      puts(&quot;\nCreating New Library&quot;); 
      outrel = open(oldlib, &quot;w&quot;); 
      item = EFILE; 
      putrel(); 
      close(outrel); 
      outndx = open(oldndx, &quot;w&quot;); 
      putndx(0, 0); 
      putndx(EOF, EOF); 
      close(outndx); 
      } 
    inndx = open(oldndx, &quot;r&quot;); 
    } 
 
  /* 
  ** open libraries and indices for updating 
  */ 
  openup() { 
    openin(); 
    outrel = open(newlib, &quot;w&quot;); 
    outndx = open(newndx, &quot;w&quot;); 
    auxbuf(outrel, 4096); 
    } 
 
  /* 
  ** print files from library 
  */ 
  print() { 
    char modnam[NAMESIZE]; 
    openin(); 
    while(nxtmod(modnam)) { 
      if(match(modnam, YES)) { 
        while(YES) { 
          poll(YES); 
          if(item &gt; ENAME) seerel(); 
          getrel(); 
          if(item == EPROG) break; 
          } 
        } 
      } 
    missing(); 
    closein(); 
    } 
 
  /* 
  ** write an entry to the new index 
  */ 
  putndx(block, byte) int block, byte; { 
    if(write(outndx, &amp;block, 2) != 2 ||    /* next block to index */ 
       write(outndx, &amp;byte, 2) != 2)       /* next byte in block to index */ 
      error(&quot;- Error Writing New Index&quot;); 
    } 
 
  /* 
  ** restore REL variables 
  */ 
  restrel() { 
    item    = item2; 
    type    = type2; 
    field   = field2; 
    strcpy(symbol, sym2); 
    inrel   = inrel2; 
    inchunk = inch2; 
    inrem   = inrem2; 
    } 
  /* 
  ** save REL variables 
  */ 
  saverel() { 
    item2  = item; 
    type2  = type; 
    field2 = field; 
    strcpy(sym2, symbol); 
    inrel2 = inrel; 
    inch2  = inchunk; 
    inrem2 = inrem; 
    inrem  = 0;           /* force getrel() to read a byte */ 
    } 
 
  /* 
  ** seek to next member in old library 
  */ 
  extern int Uchrpos[];           /* lives in CSYSLIB */ 
  seek() { 
    getndx(); 
    if(oldblock == EOF) error(&quot;- Premature End of Index&quot;); 
    if(cseek(inrel, oldblock, 0) == EOF) 
      error(&quot;- Corrupt Library or Index&quot;); 
    Uchrpos[inrel] = oldbyte; 
    inrem = 0;                    /* force getrel() to read a byte */ 
    } 
 
  /* 
  ** print table of contents 
  */ 
  table() { 
    char name[NAMESIZE]; int i, j; 
    openin(); 
    puts(&quot;&quot;); 
    i = 0; 
    while(nxtmod(name)) { 
      poll(YES); 
      if(match(name, YES)) { 
        fputs(name, stdout); 
        j = 9 - strlen(name); 
        while(j--) putchar(' '); 
        if (!(++i % 8)) puts(&quot;&quot;); 
        } 
    } 
  puts(&quot;&quot;); 
  missing(); 
  closein(); 
  } 
 
  /* 
  ** update (add and replace) modules in alphanumeric order   */ 
  update() { 
    char mod[NAMESIZE]; int m; 
    openup(); 
    m = 0;                                 /* first in module list */ 
    nxtmod(mod);                           /* first in old library */ 
    while(YES) { 
      if(cmpmod(mptr[m], mod) &gt; 0) {       /* module &gt; member */ 
        cpymod(YES);                       /* copy rest of member */ 
        nxtmod(mod);                       /* next in old library */ 
        continue; 
        } 
      if(cmpmod(mptr[m], mod) &lt; 0) {       /* module &lt; member */ 
        addmod(mptr[m]);                   /* add new module */ 
        puts2(&quot; Added &quot;, mptr[m]); 
        ++m;                               /* next in module list */ 
       continu; 
       } 
      if(*mod != HIGH) {                       /* equal and not at end */ 
        addmod(mptr[m]);                       /* add new module */ 
        ++m;                                   /* next in module list */ 
        puts2(&quot;Replaced &quot;, mod); 
        nxtmod(mod);                           /* next in old library */ 
        continue; 
        } 
      break; 
      } 
    closeup(); 
    } 
 
  /* 
  ** abort with a usage message 
  */ 
  usage() { 
    error(&quot;Usage: LIB -{DPTUX}[A] library [module...]&quot;); 
    } <p>
</PRE> 
<b><a name="list7-5">LISTING 7-5</a><p></b>
<PRE> 
----------------------------------------------------------------FILE:CMIT.C 
  /* 
  ** CMIT.C -- Machine Instruction Table Compiler 
  ** 
  **                 Small-Mac Assembler Configuration Utility 
  ** 
  **                 Copyright 1985 J. E. Hendrix 
  ** 
  ** Usage: CMIT [-C] [-L] [table] [mac] 
  ** 
  ** -C       Configure the executable assembler (MAC.COM) with the indicated, 
  **          or default, machine instructin table. 
  ** 
  ** -L       List the compiled machine instruction table. 
  ** 
  ** table    The name of the machine instruction table file in source 
  **          format (default 8080.MIT). The default and only allowed 
  **          filename extension is MIT. A drive specifier is allowed. 
  ** 
  ** mac      Assembler COM file (default MAC.COM). Must have COM extension 
  **          to be recognized as such. Need specify only if not o the 
  **          default drive or has a different name. 
  ** 
  **          NOTE: if no switches are given, -L is assumed. If any switches 
  **          are given, only those actions so specified are taken. 
  ** 
  **          NOTE: After compiling and linking a new MAC.COM, it must be 
  **          configured by running this program before it may be executed. 
  **          A previously configured MAC.COM may be reconfigured at any time. 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;mac.h&quot;        /* must be included first */ 
  #include &quot;mit.h&quot; 
  #include &quot;notice.h&quot; 
 
  #define COMEXT &quot;.COM&quot; 
  #define MITEXT &quot;.MIT&quot; 
 
  char 
     macfn[MAXFN] = &quot;MAC.COM&quot;,    /* default assembler filename */ 
     mitfn[MAXFN] = &quot;8080.MIT&quot;;   /* default mit filename */ 
  int 
    con,                  /* configure? */ 
    list,                 /* list? */ 
    looks;                /* number of looks to find it */ 
 
  main(argc, argv) int argc, *argv; { 
    char str[MAXFN]; 
    fputs(&quot;Small-Mac MIT Compiler, &quot;, stderr); fputs(VERSION, stderr); 
    fputs(CRIGHT1, stderr); 
    getsw(argc, argv);             /* fetch and remember switches, etc. */ 
    load(); 
    if(list) print(); 
    if(con) config(); 
    } 
 
  /* 
  ** configure assembler with machine instruction table 
  */ 
  extern int Uchrpos[]; 
  config() { 
    int fd, sz; 
    fd = open(macfn, &quot;r+&quot;);               /* must exist */ 
    Uchrpos[fd] = 3;                      /* seek to mitable word */ 
    read(fd, &amp;sz, INTSZ);                 /* read table size */ 
    if(sz != mitable) { 
      printf(&quot;%s MIT is %u Bytes but Should be %u\n&quot;, macfn, sz, mitable); 
      abort(7); 
      } 
    write(fd, &amp;mitable + 1, mitable); 
    if(ferror(fd)) error2(macfn, &quot;- Write Error&quot;); 
    close(fd); 
    } 
 
  /* 
  ** get switches from command line 
  */ 
  getsw(argc, argv) int argc, *argv; { 
    char arg[MAXFN]; 
    int i, b, len; 
    i = 0; 
    while(getarg(++i, arg, MAXFN, argc, argv) != EOF) { 
      if(arg[0] == '-') { 
        if(toupper(arg[1]) == 'C')     con = YES; 
        else if(toupper(arg[1]) == 'L') list = YES; 
        else usage(); 
        } 
      else { 
        if(extend(arg, MITEXT, COMEXT)) 
             strcpy(macfn, arg); 
        else strcpy(mitfn, arg); 
        } 
      } 
    if(!con) list = YES; 
    } 
 
  /* 
  ** load table from diskette 
  */ 
  load() { 
    char str[MAXLINE], *mitend, *vptr, *last, *ptr, *cp; 
    int fd, top, bits, byte, ilen, h, i, j, 
        opnd[MIOPNDS], opnds, et, *fptr; 
    fd = open(mitfn, &quot;r&quot;); 
    ptr = mitbuf; 
    mitend = mitbuf + (MIBUFSZ - MAXLINE); 
  opnds = 0; 
  while(fgets(str, MAXLINE, fd)) {              /* load operand fields */ 
    poll(YES); 
    cp = skip(3, str);                          /* skip to operand field */ 
    if(!isgraph(*cp)) continue;                 /* no operand to load */ 
    for(j = 0; j &lt; opnds; ++j)                  /* already have it? */ 
      if(fldcmp(cp, opnd[j]) == 0) break; 
    if(j &lt; opnds) continue; 
    if(ptr &gt; mitend) goto mitovr1; 
    opnd[opnds++] = ptr;                        /* temp operand ptr */ 
    if(opnds == MIOPNDS) error2(str, &quot;- MIT Operand Overflow&quot;); 
    while(isgraph(*ptr = *cp++)) ++ptr;         /* copy operand field */ 
    *ptr++ = NULL; 
    } 
  if(rewind(fd)) error(&quot;- Can't Rewind MIT File&quot;);/* 2nd pass */ 
  last = ptr; *last = NULL; 
  top = 0; 
  while(fgets(str, MAXLINE, fd)) {              /* load mnemonics, etc. */ 
    poll(YES); 
    if(ptr &gt; mitend) {mitovr1: error2(str, &quot;- MIT Buffer Overflow&quot;);} 
    if(top &gt;= MICOUNT) error(&quot;- MIT Mnemonic Overflow&quot;); 
    cp = skip(2, str);                          /* skip to mnemonic field */ 
    if(fldcmp(cp, last)) {                      /* new mnemonic */ 
      *ptr++ = 0;                               /* terminate prior instr */ 
      mitptr[top++] = last = ptr;               /* mnemonic ptr */ 
      while(isgraph(*ptr = *cp++)) ++ptr;       /* copy mnemonic field */ 
      *ptr++ = NULL; 
      } 
    vptr = ptr++; *vptr = 2*INTSZ;              /* vlen field */ 
    cp = skip(3; str);                          /* locate operand */ 
    if(isgraph(*cp)) {                          /* has an operand field */ 
      for(j = 0; j &lt; opnds; ++j) 
        if(fldcmp(cp, opnd[j]) == 0) break; 
      if(j == opnds) error2(str, &quot;- Can't Find Operand&quot;); 
      putint(ptr, opnd[j]); 
      } 
    else putint(ptr, 0);                        /* has no operand */ 
    ptr += INTSZ; 
    fptr = ptr; ptr += INTSZ; *fptr = 0;        /* fmt field */ 
    bits = 13; 
    ilen = -1; 
    cp = skip(1, str);                          /* code field */ 
    while(isgraph(*cp)) { 
      if(islower(*cp)) {                        /* x1, x2, etc. */ 
        et = *cp++;                             /* expr type */ 
        bits -= 3; *fptr = ((*fptr &gt;&gt; 3) &amp; 8191) + 8192; 
        switch(*cp) { 
           default: error2(str, &quot;- Bad Expression Specifier&quot;); 
          case '2': *fptr += 32768; ilen += 2; break; 
            case '1': ++ilen; 
            } 
          if(et == 'p') *fptr += 16384;           /* pc relative expr */ 
          ++cp; 
          continue; 
          } 
        if(isxdigit(*cp)) { 
          if((j = xtoi(cp, &amp;byte)) &gt; 2) error2(str, &quot;- Bad Hex Byte&quot;); 
          cp += j; 
          *ptr++ = byte; *vptr += 1; 
          --bits; *fptr = ((*fptr &gt;&gt; 1) &amp; 32767); 
          ++ilen; 
          continue; 
          } 
        ++cp;                             /* bump past field separator */ 
        } 
      *fptr &gt;&gt;= bits;                     /* right adjust format byte */ 
      *fptr |= ilen &amp; 7;                  /* and insert instr length */ 
      } 
    *ptr++ = 0;                           /* terminate prior instr */ 
    printf(&quot; Operation Codes %5u\n&quot;, top); 
    printf(&quot;Buffer Space Used %5u\n&quot;, ptr - mitbuf); 
    for(i = 0; i &lt; MICOUNT; ++i)          /* init hash indices */ 
      mitndx[i] = mitnxt[i] = EOF; 
    for(i = 0; i &lt; top; ++i) {            /* create hash indices - pass 1 */ 
      poll(YES); 
      h = hash(mitptr[i], MICOUNT); 
      if(mitndx[h] == EOF) { 
        mitndx[h] = i; 
        } 
      } 
    for(i = j = 0; i &lt; top; ++i) {        /* create hash indices - pass 2 */ 
      poll(YES); 
      h = hash(mitptr[i], MICOUNT); 
      if(mitndx[h] != i) { 
        while(mitndx[j] != EOF) ++j;       /* must be empty slot */ 
        mitndx[j] = i; 
        while(mitnxt[h] != EOF) h = mitnxt[h]; 
        mitnxt[h] = j; 
        } 
      } 
    close(fd); 
    } 
 
  /* 
  ** print compiled machine instruction table 
  */ 
  print() { 
  int i ,k, bak, fd, fmt, len, opcode, holding; 
  char lin[MAXLINE], inst[MAXLINE], *ptr, *vptr, *cp; 
  fd = open(mitfn, &quot;r&quot;); 
  while(fgets(lin, MAXLINE, fd)) { 
    poll(YES); 
    i = 0; cp = skip(2, lin); 
    while(isgraph(inst[i++] = *cp++)) ; 
    if(inst[i-1] == '\n') inst[i-1] = ' '; 
    bak = i; 
    cp = skip(3, lin); 
    do { 
      i = bak; 
      while(isgraph(*cp) &amp;&amp; *cp != ANOTHER) inst[i++] = *cp++; 
      inst[i] = 0; 
      if(*cp == ANOTHER) ++cp; 
      printf(&quot;%-15s &quot;, inst);            /* mnemonic */ 

      if(!(ptr = find(inst))) 
        error(&quot;- Can't Find Instruction in MIT&quot;); 
      printf(&quot; (%2u looks) &quot;, looks); 
      ptr += INTSZ; 
      fmt = getint(ptr);                 /* ptr -&gt; first code byte */ 
      ptr += INTSZ; 
      len = (fmt &amp; 7) + 1; 
      fmt &gt;&gt;= 3; 
      holding = NO; 
      while(len-- &gt; 0) {                 /* for each byte of code */ 
        if(fmt &amp; 1) {                    /* expression */ 
          if(holding) { 
          opcode += opadj; 
          opadj = 0; 
          holding = NO; 
          printf(&quot; %2x&quot;, opcode); 
          } 
        fmt &gt;&gt;= 1; 
        switch(fmt &amp; 3) { 
          case 0: printf(&quot; x1&quot;); break;               /* 1-byte */ 
          case 1: printf(&quot; p1&quot;); break;               /* 1-byte pc rel */ 
          case 2: printf(&quot; x2&quot;); --len; break;        /* 2-byte */ 
          case 3: printf(&quot; p2&quot;); --len; break;        /* 2-byte pc rel */ 
          } 
        fmt &gt;&gt;= 1; 
        } 
      else {                                  /* code byte */ 
        if(holding) printf(&quot; %2x&quot;, opcode); 
        opcode = *ptr++ &amp; 255; 
        holding = YES; 
        } 
      fmt &gt;&gt;= 1; 
      } 
        if(holding) { 
          opcode += opadj; 
          printf(&quot; %2x&quot;, opcode); 
          } 
        puts(&quot;&quot;); 
        } while(*cp &gt; ' '); 
      } 
    close(fd); 
    } 
 
  /* 
  ** abort with a usage message 
  */ 
  usage() { 
    error(&quot;Usage: CMIT [-C] [-L] [table] [mac]&quot;); 
    } <p>
</PRE>
<b><a name="list7-6">LISTING 7-6</a><p></b>
<PRE> 
----------------------------------------------------------FILE:DREL. C 
  /* 
  ** DREL.C -- dump REL or LIB file 
  ** 
  **           Copyright 1985 J. E. Hendrix 
  ** 
  **  No command line switches are accepted. The user is prompted 

  **  for each file to be dumped. Output goes to the standard 
  **  output file and is, therefore, redirectable to any output 
  **  device or to a disk file. If an input file cannot be found 
  **  the user is prompted for another input file. File names must 
  **  be given, complete with extensions. Drive specifiers may be 
  **  given. 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;notice.h&quot; 
  #include &quot;mac.h&quot; 
  #include &quot;rel.h&quot; 
 
  main() { 
    char fn[MAXFN]; 
    fputs(&quot;Small-Mac REL/LIB Dump Utility, &quot;, stderr); 
    fputs(VERSION, stderr); 
    fputs(CRIGHT1, stderr); 
    while(YES) { 
      if(!reqstr(&quot;Library/Module Name: &quot;, fn, MAXFN)) 
exit(); 
      if(!(inrel = fopen(fn, &quot;r&quot;))) continue; 
      do { 
        poll(YES);                        /* poll for user interrupt */ 
        if(getrel() == ERR) abort(7);     /* get next REL item */ 

        seerel();                         /* display it */ 
        } while(item != EFILE); 
      fclose(inrel); 
      } 
    } <p>
</PRE>
 
<b><a name="list7-7">LISTING 7-7</a><p></b> 
<PRE>
----------------------------------------------------------FILE:STDIO.H 
  /* 
  ** STDIO.H -- Standard Small-C Definitions 
  ** 
  ** Copyright 1984 L. E. Payne and J. E. Hendrix 
  */ 
  #define stdin   0 
  #define stdout  1 
  #define stderr  2 
  #define ERR     (-2) 
  #define EOF     (-1) 
  #define YES     1 
  #define NO      0 
  #define NULL    0 
  #define CR      13 
  #define LF      10 
  #define BELL    7 
  #define SPACE ' ' 
  #define NEWLINE LF       /*23*/ /*45*/ 
 
-----------------------------------------------------------------FILE:MAC.H 
  /* 
  ** miscellaneous definitions 
  */ 
  #define MAXFN       15               /* max file name space */ 
  #define INTSZ        2               /* integer size in bytes */ 
  #define COMMENT     ';'              /* comment delimiter */ 
  #define ANOTHER     '|'              /* another operand option */ 
  #define MAXLINE     81               /* length of source line */ 
  #define MICOUNT    150               /* machine instruction hash space */ 
  #define MIOPNDS    300               /* maximum unique operand formats */ 
  #define MIBUFSZ   4600               /* mit syntax space */ 
  #define OBJEXT  &quot;.REL&quot;               /* object file extension */ 
  #define SRCEXT  &quot;.MAC&quot;               /* source file extension */ 
  #define MAXLAB       8               /* maximum label characters used */ 
  #define STACK     1024               /* reserved for stack space */ 
  #define OHDOPEN    164               /* overhead bytes per open file */ 
  #define MAXOPEN      2               /* maximum open files */ 
 
  /* 
  ** symbol table 
  */ 
  #define STMAX 500                   /* maximum lables allowed */ 
  #define STVALUE (MAXLAB + 1)        /* offset to value field */ 

  #define STFLAG (STVALUE + INTSZ)    /* offset to flag byte */ 
  #define STENTRY (STFLAG + 1)        /* st entry size */ 
  #define STBUFSZ (stmax * STENTRY)   /* st buffer size */ 
  #define LABBIT2 128                 /* label flag (pass 2) */ 
  #define LABBIT   64                 /* label flag */ 
  #define EQUBIT   32                 /* EQU flag (pass 2) */ 
  #define SETBIT   16                 /* SET flag */ 
  #define XRBIT    8                  /* external-reference flag */ 
  #define EPBIT    4                  /* entry-point flag */ 
  #define RELBITS  3                  /* relative bits (ABS, PREL) */ 
 
  /* 
  ** macro table 
  */ 
  #define MTNXT      0       /* pointer to next macro */ 
  #define MTNAM   INTSZ      /* macro name */ 
 
  /* 
  ** assembler instruction codes 
  */ 
  #define DW     1 
  #define DB     2 
  #define DS     3 
  #define EX     4 
  #define SET    5 
  #define EQU    6 
  #define ORG    7 
  #define END    8 
  #define MACRO  9 
  #define ENDM  10 
  #define CALL  11 
 
-----------------------------------------------------------FILE:EXT.H 
  extern int 
    pass, badsym, gotep, gotxr, gotlabel, gotnam, opadj, 
    hashval, loc, lin, err, endv, endt, lerr, srcfd, eom, 
    list, lline, part1, ccnt, lpage, pause, looks, mitable, 
    mitndx[], mitnxt[], mitptr[], stmax, stn, *stp; 
 
  extern char 
    *ep, *lp, *prior, *mt, *mtnext, *mtend, line[], 
    expbuf[], srcfn[], objfn[], 
    *st, *stend, *stptr, stsym[], mitbuf[]; 
 
---------------------------------------------------------------FILE:MIT.H 
  /* 
  ** machine instruction table 
  */ 
  int 
    mitable = 3*INTSZ*MICOUNT+MIBUFSZ, /* mit size signature */ 
    mitndx[MICOUNT],              /* mit indices (hash -&gt; which) */ 
    mitnxt[MICOUNT],              /* mit synonym chain */ 
    mitptr[MICOUNT];              /* mnemonic syntax ptrs */ 
  char 
    mitbuf[MIBUFSZ];              /* instruction syntax buffer */ 

 
  extern int                      /* reside in mit.c */ 
    opadj,                        /* operation code adjustment */ 

    hashval;                      /* global hash value for speed */ 
 
---------------------------------------------------------------FILE:REL.H 
  /* 
  ** rel.h -- header for REL file processing 
  */ 
 
                          /* item-type codes */ 
 
  #define ABS       0     /* absolute item */ 
  #define PREL      1     /* program (code) relative item */ 
  #define DREL      2     /* data relative item */ 
  #define CREL      3     /* common relative item */ 
 
  #define ENAME     4     /* entry name */ 
  #define CNAME     5     /* common block name */ 
  #define PNAME     6     /* program name */ 
  #define LNAME     7     /* library name */ 
  #define EXT       8     /* extension link-item */ 
 
  #define CSIZE     9     /* common size &amp; name */ 
  #define XCHAIN   10     /* external-reference-chain head &amp; name */ 
  #define EPOINT   11     /* entry point location &amp; name */ 
 
  #define XMOFF    12     /* external - offset */ 
  #define XPOFF    13     /* external + offset */ 
  #define DSIZE    14     /* data area size */ 
  #define SETLC    15     /* set location counter for loading */ 
  #define CHAIN    16     /* chain address (fill chain with loc ctr) */ 
  #define PSIZE    17     /* program (code) size */ 
  #define EPROG    18     /* end of program */ 
  #define EFILE    19     /* end of file */ 
 
  #define MAXSYM    6     /* maximum symbol length allowed in REL file */ 
  #define ONES     -1     /* all one bits */ 
 
                          /* common variables */ 
   extern int 
   inrel,                 /* file descriptor for input REL file */ 
   inrem,                 /* remaining bits in inchunk */ 
   inchunk,               /* current chunk from REL file */ 
   outrel,                /* file descriptor for output REL file */ 
   outrem,                /* remaining bits in outchunk */ 
   outchunk,              /* current chunk for REL file */ 
   item,                  /* current item code */ 
   type,                  /* type field */ 
   field;                 /* current bit field */ 
  extern char 
   symbol[9];             /* current string */ 
 
---------------------------------------------------------FILE:EXTEND.C 
  /* 
  ** if fn has no extension, extend it with ext1 
  ** if fn has an extension, require it to match ext1 or ext2 
  ** return true if fn's extension matches ext2, else false 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;mac.h&quot; 
  #define NOCCARGC 
  extend(fn, ext1, ext2) char *fn, *ext1, *ext2; { 
    char *cp; 
    if(cp = strchr(fn, '.')) { 
      if(strcmp(cp, ext2) == 0) return (YES); 
      if(strcmp(cp, ext1) == 0) return (NO); 
      puts2(fn, &quot; - invalid extension&quot;); 
      abort(7); 
      } 
    if(strlen(fn) &gt; MAXFN-4) error2(fn, &quot; - Too Long&quot;); 
    strcat(fn, ext1); 
    return (NO); 
    } 
 
-------------------------------------------------------------FILE:FILE.C 
  /* 
  ** file related functions 
  */ 
  #define NOCCARGC 
  open(name, mode) char *name, *mode; { 
    int fd; 
    if(fd = fopen(name, mode)) return(fd); 
    cant(name); 
    } 
  close(fd) int fd; { 
    if(fclose(fd)) error(&quot;Close Error&quot;); 
    } 
 
-----------------------------------------------------------FILE:GETREL.C 
  /* 
  ** getrel -- read a relocatable-object file 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;rel.h&quot; 
  #include &quot;mac.h&quot; 
  /* 
 
  ** get next REL item 
  ** return item code on success, ERR on error 
  ** on successful return: 
  **    item = item code 
  **    type = type of field 
  **   field = value of field 
  **  symbol = symbol name 
  */ 
  getrel() { 
    if(!getbits(1)) return (ERR);         /* get 1 bit */ 
    if(field == 0) {                      /* absolute item */ 
      if(!getbits(8)) return (ERR);       /* get next 8 bits */ 
      return (type = item = ABS);         /* absolute item */ 
      } 
    if(!getbits(2)) return (ERR);         /* get next 2 bits */ 
    switch(type = item = field) { 
      case 0: return (getspec());         /* special link item */ 

      case 1:                             /* program relative item */ 
      case 2:                             /* data relative item */ 
      case 3:                             /* common relative item */ 
      } 
    if(getfld() == ERR) return (ERR);     /* get next 16 bits */ 
    return (item);                        /* relative items */ 
    } 
 
  getspec() {                             /* get next special item */ 
    if(!getbits(4)) return (ERR);         /* get next 4 bits */ 
    type = ABS;                           /* default type */ 
    item = field + 4; 
    switch(field) { 
      case  0:                            /* entry symbol */ 
      case  1:                            /* select common block */ 
      case  2:                            /* program name */ 
      case  3:                            /* request library search */ 
      case  4:                            /* extension link items */ 
        if(getsym() == ERR) return (ERR); 
        break; 
      case  5:                            /* define common size */ 
      case  6:                            /* head of external reference chain */ 
      case  7:                            /* define entry point */ 
       if(gettyp() == ERR || getfld() == ERR || getsym() == ERR) 
return (ERR); 
       break; 
      case  8:                            /* external - offset */ 

      case  9:                            /* external + offset */ 

      case 10:                            /* size of data area */ 

      case 11:                            /* set loading location counter */ 
      case 12:                            /* chain addr (fill chain with lc) */ 
      case 13:                            /* size of program */ 
        if(gettyp() == ERR || getfld() == ERR) return (ERR); 
        break; 
      case 14:                            /* end of program */ 
        if(gettyp() == ERR || getfld() == ERR) return (ERR); 
        inrem = 0;                        /* force byte boundary */ 
        break; 
      case 15:                            /* end of file */ 
        inrem = 0;                        /* force byte boundary */ 
      } 
    return (item); 
    } 
 
  gettyp() { 
    if(!getbits(2)) return (ERR);         /* get 2-bit field type */ 
    return (type = field); 
    } 
 
  getfld() {                              /* get type and value of field */ 
    int low; 
    if(!getbits(8)) return (ERR);         /* get first 8 bits */ 
    low = field;                          /* save as low order byte */ 
    if(!getbits(8)) return (ERR);         /* get next 8 bits */ 
    field = (field &lt;&lt; 8) | low;           /* combine high &amp; low bytes */ 
    return (item); 
    } 
 
  getsym() {                              /* get symbol */ 
    int i, save; char *cp; 
    cp= symbol; 
    save = field;                         /* save field */ 
    if(!getbits(3)) return (ERR);         /* get 3-bit symbol length */ 
    i = field;                            /* capture symbol length */ 
    while(i--) { 
      if(!getbits(8)) return (ERR);       /* get next byte */ 
      *cp++ = field; 
      } 
    *cp = NULL;                           /* terminate symbol */ 
    field = save;                         /* restore field */ 
    return (item); 
    } 
 
  /* 
  ** get next  n bits from REL file into &quot;field&quot; 
  ** return true on success, false on error 
  */ 
  getbits(n) int n; { 
    int get; 
    field =  0;                                  /* initialize result */ 
    while(n) {                                   /* more bits to fetch */ 
      if(inrem == 0) {                           /* need another chunk */ 
       if(read(inrel, &amp;inchunk, 1) != 1) {       /* get next bit cluster */ 
         fputs(&quot;\n\7- Abnormal End of REL File\n&quot;, stdout); 
         return (NO);                            /* failure */ 
         } 
       inrem = 8;                                /* 8 bits remain */ 
       } 
     if(n &gt; inrem) get = inrem; else get = n;    /* how many from this chunk */ 
     n    -= get;                                /* decrement bits needed */ 
     inrem -= get;                               /* decr remaining bits */ 
     field = (field &lt;&lt; get) + 
             ((inchunk &gt;&gt; inrem) &amp; ~(ONES &lt;&lt; get)); 
     } 
   return (YES);                                 /* success */ 
   } 
 
------------------------------------------------------------- FILE:INT.C 
  /* 
  ** integer manipulation 
  */ 
  #define NOCCARGC 
  getint(a) int *a; {return (*a);}     /* get integer from address a */ 
  putint(a, i) int *a, i; {*a = i;}    /* put integer i at address a */ 
 
------------------------------------------------------------ FILE:MESS.C 
  /* 
  ** mess.c -- message functions 
  */ 
  #include &lt;stdio.h&gt; 
  #define  NOCCARGC 
  puts2(str1, str2) char *str1, *str2; { 
    fputs(str1, stdout); 
    puts(str2); 
    } 
  cant(str) char *str; { 
    error2(str, &quot;- Can't Open&quot;); 
    } 
  error2(str1, str2) char *str1, *str2; { 
    fputs(str1, stdout); 
    error(str2); 
    } 
  error(str) char *str; { 
    puts(str); 
    abort(7); 
    } 
 
--------------------------------------------------------------FILE:MIT.C 
  /* 
  ** mit.c -- machine instruction table functions 
  ** 
  **          mitndx[]     mitptr[]    mitnxt[] 
  **           -----        -----       ----- 
  **          |  |  |      |  |  |     |  |  | 
               -- --        -- --       -- -- 
  **          |  |  |      |  |  |     |  |  |&lt;-+ 
               -- --        -- --       -- -- 
  ** hash -&gt;  |  |  |  -&gt;  |  |  |     |  |  |  | 
               -- --        -- --       -- -- 
  **          |  |  |      |  |  |     |  |  |--+ 
               -- --        -- --       -- -- 
  **          |  |  |      |  |  |     |  |  | 
               -- --        -- --       -- -- 
  **                          | 
  **                          V 
  **                          mnemonic   variant... 
  **                                     | 
  **                           -- 
  **                          |  |...00  vlen   optr    fmt    obj... 
                               --         --   -- --   -- --   -- 
  **     format bits (&lt;-)                |  | |  |  | |  |  | |  |... 
                                          --   -- --   -- --   -- 
  **       3-bit instr Length (-1)               | 
  **       field types                           V 
  **         0 = obj byte                        operand pattern 
  **       001 = 8-bit expr                                                   -- 
  **       011 = 8-bit pc rel expr               |  |...00 
                                                  -- 
  **       101 = 16-bit expr 
  **       111 = 16-bit pc rel expr 
  ** 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;mac.h&quot;        /* must be included first */ 
  /* 
  #define NOCCARGC 
  */ 
  int 
    opadj,                        /* operation code adjustment */ 

    hashval;                      /* global hash value for speed */ 
  char 
  expbuf[MAXLINE];                /* buffer for operand expressions */ 
 
  extern int 
    mitable,                      /* machine instruction table (size) */ 
    mitndx[],                     /* mit indices (hash -&gt; which) */ 
    mitnxt[],                     /* mit synonym chain */ 
    mitptr[];                     /* mnemonic syntax ptrs */ 
 
  extern char 
    mitbuf[];                     /* instruction syntax buffer */ 

 
  extern int 
    looks;                 /* number of looks to find it */ 
 
  hash(ptr, cnt) char *ptr; int cnt; {             /* calculate hash value */ 
    hashval = 0; 
    while(*ptr &gt; ' ' &amp;&amp; atend(*ptr) == 0) 
       hashval = (hashval &lt;&lt; 1) + toupper(*ptr++); 
    return (hashval % cnt); 
    } 
 
  find(inst) char *inst; {                         /* search for instr in mit */ 
    char *mit; 
    int  h, ndx; 
    looks = 0; 
    ndx = mitndx[h = hash(inst, MICOUNT)];         /* calc hash index */ 
    while(ndx != EOF) { 
       ++looks; 
       if(fldcmp(inst, mit = mitptr[ndx]) == 0) {  /* mnemonic matches */ 
         inst = skip(2, inst);                     /* instr operand field */ 
         mit += strlen(mit) + 1;                   /* first variant */ 
         while(*mit++) {                           /* another variant? */ 
           ++looks; 
           if(match(inst, getint(mit))) return (mit); 
           mit += *(mit - 1);                      /* next variant */ 
           } 
         return (0); 
         } 
       if((h = mitnxt[h]) == EOF) return (0); 
       ndx = mitndx[h]; 
       } 
     return (0); 
     } 
   match(inst, mit) char *inst, *mit; {            /* match operands to mit */ 
     char *backup, *exp; int nest; 
     opadj = 0; 
     backup = inst; 
     if(mit == 0) { 
       if(atend(*inst)) return (YES); 
       return (NO); 
       } 
     exp = expbuf;                                 /* init expr buffer */ 
     while(YES) { 
       while(isspace(*inst)) ++inst; 
       while(isspace(*mit)) ++mit; 
       if(atend(*inst)) { 
         if(atend(*mit) || *mit == ANOTHER) return (YES); 
         goto next; 
         } 
       if(atend(*mit)) return (NO); 
       if(islower(*mit)) {                        /* expression */ 
         ++mit;                                   /* bump past x or y */ 
         nest = 0; 
         while(!atend(*inst)) {                   /* bypass expression */ 
           if(*inst == ',') break; 
           if(*inst == ')' &amp;&amp; nest == 0) break; 
           switch(*inst) { 
             case '(': ++nest; break; 
             case ')': --nest; 
             } 
           *exp++ = *inst++;                      /* extract expressions */ 
           } 
         *exp++ = ','; *exp = NULL;               /* terminate expression */ 
         continue; 
         } 
       if(lexorder(*inst++, *mit++)) { 
         next: 
         while(*mit) { 
           if(*mit == ANOTHER) {          /* end of syntax for this try */ 
             ++opadj;                     /* bump opcode adjustment */ 
             ++mit; inst = backup;        /* setup next try */ 
             exp = expbuf;                /* reset expr buffer pointer */ 
             break; 
             } 
           ++mit; 
           } 
        if(atend(*mit)) return (NO); 
        } 
       } 
      } 
 
---------------------------------------------------------- FILE:PUTREL.C 
  /* 
  ** putrel -- write a relocatable-object file 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;rel.h&quot; 
  #include &quot;mac.h&quot; 
  /* 
  ** put next REL item 
  ** return true on success, false on error 
  ** on call: 
  **    item = item code 
  **    type = type of field 
  **   field = value of field 
  **  symbol = symbol name 
  */ 
  putrel() { 
    switch(item) { 
      case ABS: 
        if(!putbits(0, 1) || !putbits(field, 8)) return (NO); 
        return (YES); 
      case PREL: case DREL: case CREL: 
        if(!putbits(1, 1) || !putbits(item, 2) || !putfld()) 
return (NO); 
        return (YES); 
      } 
    if(!putbits(4, 3) || !putbits(item-4, 4)) return (NO); 
    switch(item) { 
      case CSIZE: case XCHAIN: case EPOINT: 
        if(!putbits(type, 2) || !putfld()) return (NO); 
      case ENAME: case CNAME: case PNAME: case LNAME: case EXT: 
        if(!putsym()) return (NO); 
        return (YES); 
      case XMOFF:  case XPOFF:  case DSIZE: 
      case SETLC:  case CHAIN:  case PSIZE: 
        if(!putbits(type, 2) || !putfld()) return (NO); 
        return (YES); 
      case  EPROG: 
        if(!putbits(type, 2) || !putfld()) return (NO); 
      case EFILE: 
        if(outrem &lt; 8 &amp;&amp; !putbits(0, outrem)) return (NO);/* finish byte */ 
        return (YES); 
      } 
    return (NO); 
    } 
  puttyp() { 
    if(putbits(type, 2)) return (YES);     /* put 2-bit field type */ 
    return (NO); 
    } 
  putfld() {                               /* put low then high byte */ 
    if(putbits(field, 8) &amp;&amp; putbits(field &gt;&gt; 8, 8)) 
return (YES); 
    return (NO); 
    } 
  putsym() {                               /* put symbol */ 
    int i; chap *cp; 
    if((i = strlen(symbol)) &gt; MAXSYM) i = MAXSYM; /* enforce max length */ 
    if(!putbits(i, 3)) return (NO);        /* put 3-bit symbol length */ 
    cp = symbol; 
    while(i--) { 
      if(!putbits(*cp++, 8)) return (NO);  /* put next byte */ 
      } 
    return (YES); 
    } 
 
  /* 
  ** put next n bits from fld into REL file 
  ** return true on success, false on error 
  */ 
  putbits(fld, n) int fld, n; { 
    int put; 
    while(n) {                                    /* more bits to put */ 
      if(n &gt; outrem) put = outrem; else put = n;  /* how many for this chunk */ 
      outchunk = (outchunk &lt;&lt; put) + 
               ((fld &gt;&gt; (n-put)) &amp; ~(ONES &lt;&lt; put)); 
      n      -= put;                              /* decrement bits to put */ 
      outrem -= put;                              /* decr remaining bits */ 
      if(outrem == 0) {                           /* need another chunk */ 
        if(write(outrel, &amp;outchunk, 1) != 1) {    /* put next bit cluster */ 
           fputs(&quot;\n\7- Write Error in REL File\n&quot;, stdout); 
           return (NO);                           /* failure */ 
           } 
        outrem = 8;                               /* 8 bits remain */ 
        } 
      } 
    return (YES);                                 /* success */ 
    } 
------------------------------------------------------------- FILE:REL.C 
  /* 
  ** rel.c -- common data for REL file processing 
  */ 
                          /* common variables */ 
  int 
   inrel,                 /* file descriptor for input REL file */ 
   inrem = 0,             /* remaining bits in input chunk */ 
   inchunk,               /* current chunk from REL file */ 
   outrel,                /* file descriptor for output REL file */ 
   outrem = 8,            /* remaining bits in output chunk */ 
   outchunk,              /* current chunk for REL file */ 
   item,                  /* current item code */ 
   type,                  /* type field */ 
   field;                 /* current bit field */ 
  char 
   symbol[9];             /* current string */ 
 
------------------------------------------------------------- FILE:REQ.C 
  /* 
  ** req.c -- request user input 
  */ 
  #include &lt;stdio.h&gt; 
 
  reqnbr(prompt, nbr) char prompt[]; int *nbr; {      /* request number */ 
    char str[20]; 
    int sz; 
    if(iscons(stdin)) { 
      puts(&quot; &quot;); 
      fputs(prompt, stdout); 
      } 
    getstr(str, 20); 
    if((sz = utoi(str, nbr)) &lt; 0 || str[sz]) return (NO); 
    return (YES); 
    } 
  reqstr(prompt, str, sz) char prompt[], *str; int sz; { /* request string */ 
    if(iscons(stdin)) { 
      puts(&quot; &quot;); 
      fputs(prompt, stdout); 
      } 
    getstr(str, sz); 
    return (*str);                       /* null name returns false */ 
    } 
  getstr(str, sz) char *str; int sz; {   /* get string from user */ 
    char *cp; 
    fgets(str, sz, stdin); 
    if(iscons(stdin) &amp;&amp; !iscons(stdout)) 
       fputs(str, stdout);               /* echo */ 
    cp = str; 
    while(*cp) {                         /* trim ctl chars &amp; make uc */ 
      if(*cp == '\n') break; 
      if(isprint(*str = toupper(*cp++))) ++str; 
      } 
    *str = NULL; 
    } 
 
------------------------------------------------------------ FILE:SCAN.C 
  /* 
  ** scanning functions 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;mac.h&quot; 
  #define NOCCARGC 
  atend(ch) int ch; {                   /* is ch at end of line? */ 
    switch(ch) { 
      case COMMENT: case NULL: case '\n': return (YES); 
      } 
    return (NO); 
    } 
  fldcmp(s, t) char *s, *t; {           /* compare fields in a line */ 
    while(lexorder(*s, *t) == 0) { 
      if(!isgraph(*s)) return (0); 
      ++s; ++t; 
      } 
    if((isspace(*s) || atend(*s)) &amp;&amp; 
       (isspace(*t) || atend(*t))) return (0); 
    return (*s - *t); 
    } 
  skip(n, str) int n; char str[]; {      /* find nth non-blank field in str */ 
    char *cp; cp = str; 
    while(isspace(*cp)) ++cp; 
    while(--n) { 
      while(isgraph(*cp)) ++cp; 
      while(isspace(*cp)) ++cp; 
      } 
    return (cp); 
    } 
 
-----------------------------------------------------------FILE:SEEREL.C 
  /* 
  ** seerel -- show REL items 
  */ 
  #include &lt;stdio.h&gt; 
  #include &quot;rel.h&quot; 
  int lc, width; 
  /* 
  ** display REL item 
  ** on call: 
  ** item = item code 
  ** type = type of field 
  ** field = value of field 
  ** symbol = symbol name 
  */ 
  seerel() { 
    char str[6]; int tmp; 
    switch(item) { 
      case    ABS: see8(field, ' '); lc += 1; newlin(NO); return; 

      case   PREL: 
      case   DREL: 
      case   CREL: see16(); lc += 2; newlin(NO); return; 
      case  XMOFF: 
      case  XPOFF: tmp = type; type = item; see16(); 
                   type = tmp; newLin(NO); return; 
      case ENAME: seenam(&quot;    entry: &quot;, NO); goto eol; 
      case CNAME: seenam(&quot;   common: &quot;, NO); goto eol; 
      case PNAME: fputc('\n', stdout); 
                   seenam(&quot;- program: &quot;, NO); 
                   lc = 0; 
                   goto eol; 
      case LNAME: seenam(&quot;   library: &quot;, NO); goto eol; 

      case   EXT: fputs(&quot;extension Link item\n&quot;, stdout); return; 
 
      case  CSIZE: seenam(&quot; common sz: &quot;, YES); goto eol; 
      case XCHAIN: seenam(&quot; ext chain: &quot;, YES); goto eol; 
      case EPOINT: seenam(&quot;  entry pt: &quot;, YES); goto eol; 
 
      case DSIZE: fputs(&quot; data size: &quot;, stdout); goto fld; 
      case SETLC: fputs(&quot;   load at: &quot;, stdout); lc = field; goto fld; 
 
      case CHAIN: fputs(&quot; ld chn at: &quot;, stdout); goto fld; 
      case PSIZE: fputs(&quot; prog size: &quot;, stdout); goto fld; 
      case EPROG: fputs(&quot;- end prog: &quot;, stdout); goto fld; 
      case EFILE: fputs(&quot;- end file&quot;, stdout); goto eol; 
             fld: see16(); 
             eol: newlin(YES); 
                  return; 
      } 
    itou(item, str, 6); fputs(str, stdout); 
    fputs(&quot; is an Unknown Item Code\n&quot;, stdout); 
    } 
  see8(value, suff) int value, suff; {    /* display 8-bits */ 
    char str[5]; 
    if(width == 0 &amp;&amp; item &lt; CREL) {       /* need loc ctr pref */ 
      itox(lc, str, 5); 
      outz(str);                          /* output loc ctr */ 
      fputc(' ', stdout);                 /* output spacer */ 
      } 
    itox(value &amp; 255, str, 3);            /* convert to hex string */ 
    outz(str);                            /* output hex byte */ 
    if(suff) fputc(suff, stdout);         /* output suffix? */ 
    ++width;                              /* bump line width */ 
    } 
 
  see16() {                               /* display field */ 
    see8(field &gt;&gt; 8, 0);                  /* display high byte */ 
    see8(field, xtype());                 /* display low byte &amp; type */ 
    fputc(' ', stdout);                   /* output spacer */ 
    } 
  seenam(pref, val) char *pref; int val; {/* display symbol */ 
    newlin(YES); 
    width = 1;                            /* avoid address prefix */ 
    fputs(pref,    stdout); 
    if(val) see16();                      /* output a value */ 
    fputs(symbol,  stdout); 
    } 
  xtype() { 
    switch(type) { 
      case ABS: return(' '); 
      case PREL: return('\''); 
      case DREL: return('\&quot;'); 
      case CREL: return('~'); 
      case XPOFF: return('+'); 
      case XMOFF: return('-'); 
      } 
    return('?'); 
    } 
  newlin(nl) int nl;{                     /* decide about new line */ 
    if(width &gt; 15 || (nl &amp;&amp; width)) { 
      fputc('\n', stdout); 
      width = 0; 
      } 
    } 
 
  outz(str) char *str; {                  /* zero fill and output str */ 
    char *cp; 
    cp = str; 
    while(*cp == ' ') *cp++ = '0';        /* supply leading zeroes */ 
    fputs(str,  stdout); 
    } 
 
-------------------------------------------------------------FILE:WAIT.C 
  #include &lt;stdio.h&gt; 
  #define NOCCARGC 
  /* 
  ** wait.c -- wait for operator response 
  */ 
  wait() {                /* wait for user before clearing the message */ 
    fputs(&quot;\nWaiting...&quot;, stderr); 
    fgetc(stderr); 
    } <p>
</PRE> 
<b><a name="list7-8">LISTING 7-8</a> <p></b>
<PRE>
 
  8080 Machine Instruction Table 
 
  CE_x1  ACI x 
  88    ADC B|C|D|E|H|L|M|A 
  80    ADD B|C|D|E|H|L|M|A 
  C6_x1 ADI x 
  A0    ANA B|C|D|E|H|L|M|A 
  E6_x1 ANI x 
  CD_x2 CALL x 
  DC_x2 CC x 
  FC_x2 CM x 
  2F    CMA 
  3F    CMC 
  B8    CMP B|C|D|E|H|L|M|A 
  D4_x2 CNC x 
  C4_x2 CNZ x 
  F4_x2 CP x 
  EC_x2 CPE x 
  FE_x1 CPI x 
  E4_x2 CPO x 
  CC_x2 CZ x 
  27    DAA 
  39    DAD SP 
  19    DAD D 
  29    DAD H 
  09    DAD B 
  3D    DCR A 
  05    DCR B 
  0D    DCR C 
  15    DCR D 
  1D    DCR E 
  25    DCR H 
  2D    DCR L 
  35    DCR M 
  0B    DCX B 
  1B    DCX D 
  2B    DCX H 
  3B    DCX SP 
  F3    DI 
  FB    EI 
  76    HLT 
  DB_x1 IN x 
  3C    INR A 
  04    INR B 
  0C    INR C 
  14    INR D 
  1C    INR E 
  24    INR H 
  2C    INR L 
  34    INR M 
  03    INX B 
  13    INX D 
  23    INX H 
  33    INX SP 
  DA_x2 JC x 
  FA_x2 JM x 
  C3_x2 JMP x 
  D2_x2 JNC x 
  C2_x2 JNZ x 
  F2_x2 JP x 
  EA_x2 JPE x 
  E2_x2 JPO x 
  CA_x2 JZ x 
  3A_x2 LDA x 
  0A    LDAX B 
  1A    LDAX D 
  2A_x2 LHLD x 
  21_x2 LXI H,x 
  11_x2 LXI D,x 
  31_x2 LXI SP,x 
  01_x2 LXI B,x 
  7C    MOV A,H|A,L|A,M|A,A 
  54    MOV D,H|D,L|D,M|D,A 
  5D    MOV E,L|E,M|E,A 
  78    MOV A,B|A,C|A,D|A,E 
  40    MOV B,B|B,C|B,D|B,E|B,H|B,L|B,M|B,A 
  48    MOV C,B|C,C|C,D|C,E|C,H|C,L|C,M|C,A 
  50    MOV D,B|D,C|D,D|D,E 
  58    MOV E,B|E,C|E,D|E,E|E,H 
  60    MOV H,B|H,C|H,D|H,E|H,H|H,L|H,M|H,A 
  68    MOV L,B|L,C|L,D|L,E|L,H|L,L|L,M|L,A 
  77    MOV M,A 
  70    MOV M,B|M,C|M,D|M,E|M,H|M,L 
  3E_x1 MVI A,x 
  06_x1 MVI B,x 
  0E_x1 MVI C,x 
  16_x1 MVI D,x 
  1E_x1 MVI E,x 
  26_x1 MVI H,x 
  2E_x1 MVI L,x 
  36_x1 MVI M,x 
  00    NOP 
  B5    ORA L|M|A 
  B0    ORA B|C|D|E|H 
  F6_x1 ORI x 
  D3_x1 OUT x 
  E9    PCHL 
  C1    POP B 
  D1    POP D 
  E1    POP H 
  F1    POP PSW 
  E5    PUSH H 
  D5    PUSH D 
  C5    PUSH B 
  F5    PUSH PSW 
  17    RAL 
  1F    RAR 
  D8    RC 
  C9    RET 
  20    RIM 
  07    RLC 
  F8    RM 
  D0    RNC 
  C0    RNZ 
  F0    RP 
  E8    RPE 
  E0    RPO 
  0F    RRC 
  C7    RST 0 
  D7    RST 16 
  DF    RST 24 
  E7    RST 32 
  EF    RST 40 
  F7    RST 48 
  FF    RST 56 
  CF    RST 8 
  C8    RZ 
  98    SBB B|C|D|E|H|L|M|A 
  DE_x1 SBI x 
  22_x2 SHLD x 
  30    SIM 
  F9    SPHL 
  32_x2 STA x 
  02    STAX B 
  12    STAX D 
  37    STC 
  90    SUB B|C|D|E|H|L|M|A 
  D6_x1 SUI x 
  EB    XCHG 
  A8    XRA B|C|D|E|H|L|M|A 
  EE_x1 XRI x 
  E3    XTHL <p>
</PRE>

<b><a name="list7-9">LISTING 7-9</a><p></b> 
<PRE>
 
  Z80 Macine Instruction Table 
  DD_8E_x1    ADC A,(IX+x) 
  FD_8E_x1    ADC A,(IY+x) 
  88          ADC A,B|A,C|A,D|A,E|A,H|A,L|A,(HL)|A,A 
  CE_x1       ADC A,x 
  ED_4A       ADC HL,BC 
  ED_5A       ADC HL,DE 
  ED_6A       ADC HL,HL 
  ED_7A       ADC HL,SP 
  DD_86_x1    ADD A,(IX+x) 
  FD_86_x1    ADD A,(IY+x) 
  80          ADD A,B|A,C|A,D|A,E|A,H|A,L|A,(HL)|A,A 
  C6_x1       ADD A,x 
  09          ADD HL,BC 
  19          ADD HL,DE 
  29          ADD HL,HL 
  39          ADD HL,SP 
  DD_09       ADD IX,BC 
  DD_19       ADD IX,DE 
  DD_29       ADD IX,IX 
  DD_39       ADD IX,SP 
  FD_09       ADD IY,BC 
  FD_19       ADD IY,DE 
  FD_29       ADD IY,IY 
  FD_39       ADD IY,SP 
  DD_A6_x1    AND (IX+x) 
  FD_A6_x1    AND (IY+x) 
  A0          AND B|C|D|E|H|L|(HL)|A 
  E6_x1       AND x 
  DD_CB_x1_46 BIT 0,(IX+x) 
  FD_CB_x1_46 BIT 0,(IY+x) 
  CB_40       BIT 0,B|0,C|0,D|0,E|0,H|0,L|0,(HL)|0,A 
  DD_CB_x1_4E BIT 1,(IX+x) 
  FD_CB_x1_4E BIT 1,(IY+x) 
  CB_48       BIT 1,B|1,C|1,D|1,E|1,H|1,L|1,(HL)|1,A 
  DD_CB_x1_56 BIT 2,(IX+x) 
  FD_CB_x1_56 BIT 2,(IY+x) 
  CB_50       BIT 2,B|2,C|2,D|2,E|2,H|2,L|2,(HL)|2,A 
  DD_CB_x1_5E BIT 3,(IX+x) 
  FD_CB_x1_5E BIT 3,(IY+x) 
  CB_58       BIT 3,B|3,C|3,D|3,E|3,H|3,L|3,(HL)|3,A 
  DD_CB_x1_66 BIT 4,(IX+x) 
  FD_CB_x1_66 BIT 4,(IY+x) 
  CB_60       BIT 4,B|4,C|4,D|4,E|4,H|4,L|4,(HL)|4,A 
  DD_CB_x1_6E BIT 5,(IX+x) 
  FD_CB_x1_6E BIT 5,(IY+x) 
  CB_68       BIT 5,B|5,C|5,D|5,E|5,H|5,L|5,(HL)|5,A 
  DD_CB_x1_76 BIT 6,(IX+x) 
  FD_CB_x1_76 BIT 6,(IY+x) 
  CB_70       BIT 6,B|6,C|6,D|6,E|6, H|6,L|6,(HL)|6,A 
  DD_CB_x1_7E BIT 7,(IX+x) 
  FD_CB_x1_7E BIT 7,(IY+x) 
  CB_78       BIT 7,B|7,C|7,D|7,E|7,H|7,L|7,(HL)|7,A 
  DC_x2       CALL C,x 
  FC_x2       CALL M,x 
  D4_x2       CALL NC,x 
  C4_x2       CALL NZ,x 
  F4_x2       CALL P,x 
  EC_x2       CALL PE,x 
  E4_x2       CALL PO,x 
  CC_x2       CALL Z,x|x 
  3F          CCF 
  DD_BE_x1    CP (IX+x) 
  FD_BE_x1    CP (IY+x) 
  B8          CP B|C|D|E|H|L|(HL)|A 
  FE_x1       CP x 
  ED_A9       CPD 
  ED_B9       CPDR 
  ED_A1       CPI 
  ED_B1       CPIR 
  2F          CPL 
  27          DAA 
  35          DEC (HL) 
  DD_35_x1    DEC (IX+x) 
  FD_35_x1    DEC (IY+x) 
  3D          DEC A 
  05          DEC B 
  0B          DEC BC 
  0D          DEC C 
  15          DEC D 
  1B          DEC DE 
  1D          DEC E 
  25          DEC H 
  2B          DEC HL 
  DD_2B       DEC IX 
  FD_2B       DEC IY 
  2D          DEC L 
  3B          DEC SP 
  F3          DI 
  10_P1       DJNZ p 
  FB          EI 
  E3          EX (SP),HL 
  DD_E3       EX (SP),IX 
  FD_E3       EX (SP),IY 
  08          EX AF,AF' 
  EB          EX DE,HL 
  D9          EXX 
  76          HALT 
  ED_46       IM 0 
  ED_56       IM 1 
  ED_5E       IM 2 
  ED_78       IN A,(C) 
  DB_X1       IN A,(x) 
  ED_40       IN B,(C) 
  ED_48       IN C,(C) 
  ED_50       IN D,(C) 
  ED_58       IN E,(C) 
  ED_60       IN H,(C) 
  ED_68       IN L,(C) 
  DD_34_x1    INC (IX+x) 
  FD_34_x1    INC (IY+x) 
  3C          INC A 
  03          INC BC|B 
  OC          INC C 
  13          INC DE|D 
  1C          INC E 
  23          INC HL|H 
  DD_23       INC IX 
  FD_23       INC IY 
  2C          INC L 
  33          INC SP|(HL) 
  ED_AA       IND 
  ED_BA       INDR 
  ED_A2       INI 
  ED_B2       INIR 
  E9          JP (HL) 
  DD_E9       JP (IX) 
  FD_E9       JP (IY) 
  DA_x2       JP C,x 
  FA_x2       JP M,x 
  D2_x2       JP NC,x 
  C2_x2       JP NZ,x|x 
  F2_x2       JP P,x 
  EA_x2       JP PE,x 
  E2_x2       JP PO,x 
  CA_x2       JP Z,x 
  38_p1       JR C,p 
  30_p1       JR NC,p 
  20_p1       JR NZ,p 
  18_p1       JR p 
  28_p1       JR Z,p 
  02          LD (BC),A 
  12          LD (DE),A 
  77          LD (HL),A 
  70          LD (HL),B|(HL),C|(HL),D|(HL),E|(HL),H|(HL),L 
  36_x1       LD (HL),x 
  DD_77_x1    LD (IX+x),A 
  DD_70_x1    LD (IX+x),B|(IX+x),C|(IX+x),D 
  DD_73_x1    LD (IX+x),E|(IX+x),H|(IX+x),L 
  DD_36_x1_x1 LD (IX+x),x 
  FD_77_x1    LD (IY+x),A 
  FD_70_x1    LD (IY+x),B|(IY+x),C|(IY+x),D 
  FD_73_x1    LD (IY+x),E|(IY+x),H|(IY+x),L 
  FD_36_x1_x1 LD (IY+x),x 
  ED_43_x2    LD (x),BC 
  ED_53_x2    LD (x),DE 
  22_x2       LD (x),HL 
  DD_22_x2    LD (x),IX 
  FD_22_x2    LD (x),IY 
  ED_73_x2    LD (x),SP 
  0A          LD A,(BC) 
  1A          LD A,(DE) 
  DD_7E_x1    LD A,(IX+x) 
  FD_7E_x1    LD A,(IY+x) 
  78          LD A,B|A,C|A,D|A,E|A,H|A,L|A,(HL)|A,A 
  ED_57       LD A,I 
  ED_5F       LD A,R 
  3A_x2       LD A,(x) 
  3E_x1       LD A,X 
  DD_46_x1    LD B,(IX+x) 
  FD_46_x1    LD B,(IY+x) 
  40          LD B,B|B,C|B,D|B,E|B,H|B,L|B,(HL)|B,A 
  06_x1       LD B,x 
  ED_4B_x2    LD BC,(x) 
  01_x2       LD BC,x 
  DD_4E_x1    LD C,(IX+x) 
  FD_4E_x1    LD C,(IY+x) 
  48          LD C,B|C,C|C,D|C,E|C,H|C,L|C,(HL)|C,A 
  0E_x1       LD C,x 
  DD_56_x1    LD D,(IX+x) 
  FD_56_x1    LD D,(IY+x) 
  50          LD D,B|D,C|D,D|D,E|D,H|D,L|D,(HL)|D,A 
  16_x1       LD D,x 
  12          LD (DE),A 
  ED_5B_X2    LD DE,(x) 
  11_x2       LD DE,x 
  DD_5E_x1    LD E,(IX+x) 
  FD_5E_x1    LD E,(IY+x) 
  58          LD E,B|E,C|E,D|E,E,|E,H|E,L|E,(HL)|E,A 
  1E_x1       LD E,x 
  DD_66_x1    LD H,(IX+x) 
  FD_66_x1    LD H,(IY+x) 
  60          LD H,B|H,C|H,D|H,E|H,H|H,L|H,(HL)|H,A 
  26_x1       LD H,x 
  2A_x2       LD HL,(x) 
  ED_47       LD I,A 
  DD_2A_x2    LD IX,(x) 
  DD_21_X2    LD IX,x 
  FD_2A_x2    LD IY,(x) 
  FD_21_X2    LD IY,x 
  DD_6E_x1    LD L,(IX+x) 
  FD_6E_x1    LD L,(IY+x) 
  68          LD L,B|L,C|L,D|L,E|L,H|L,L|L,(HL)|L,A 
  2E_x1       LD L,x 
  ED_4F       LD R,A 
  F9          LD SP,HL 
  DD_F9       LD SP,IX 
  FD_F9       LD SP,IY 
  ED_7B_x2    LD SP,(x) 
  31_x2       LD SP,x|(x),A 
  ED_A8       LDD 
  ED_B8       LDDR 
  ED_A0       LDI 
  ED_B0       LDIR 
  ED_44       NEG 
  00          NOP 
  DD_B6_x1    OR (IX+x) 
  FD_B6_x1    OR (IY+x) 
  B0          OR B|C|D|E|H|L|(HL)|A 
  F6_x1       OR x 
  ED_BB       OTDR 
  ED_B3       OTIR 
  ED_79       OUT (C),A 
  ED_41       OUT (C),B 
  ED_49       OUT (C),C 
  ED_51       OUT (C),D 
  ED_59       OUT (C),E 
  ED_61       OUT (C),H 
  ED_69       OUT (C),L 
  D3_x1       OUT (x),A 
  ED_AB       OUTD 
  ED_A3       OUTI 
  F1          POP AF 
  C1          POP BC 
  D1          POP DE 
  E1          POP HL 
  DD_E1       POP IX 
  FD_E1       POP IY 
  F5          PUSH AF 
  C5          PUSH BC 
  D5          PUSH DE 
  E5          PUSH HL 
  DD_E5       PUSH IX 
  FD_E5       PUSH IY 
  DD_CB_x1_86 RES 0,(IX+x) 
  FD_CB_x1_86 RES 0,(IY+x) 
  CB_80       RES 0,B|0,C|0,D|0,E|0,H|0,L|0,(HL)|0,A 
  DD_CB_x1_8E RES 1,(IX+x) 
  FD_CB_x1_8E RES 1,(IY+x) 
  CB_88       RES 1,B|1,C|1,D|1,E|1,H|1,L|1,(HL)|1,A 
  DD_CB_x1_96 RES 2,(IX+x) 
  FD_CB_x1_96 RES 2,(IY+x) 
  CB_90       RES 2,B|2,C|2,D|2,E|2,H|2,L|2,(HL)|2,A 
  DD_CB_x1_9E RES 3,(IX+x) 
  FD_CB_x1_9E RES 3,(IY+x) 
  CB_98       RES 3,B|3,C|3,D|3,E|3,H|3,L|3,(HL)|3,A 
  DD_CB_x1_A6 RES 4,(IX+x) 
  FD_CB_x1_A6 RES 4,(IY+x) 
  CB_A0       RES 4,B|4,C|4,D|4,E|4,H|4,L|4,(HL)|4,A 
  DD_CB_x1_AE RES 5,(IX+x) 
  FD_CB_x1_AE RES 5,(IY+x) 
  CB_A8       RES 5,B|5,C|5,D|5,E|5,H|5,L|5,(HL)|5,A 
  DD_CB_x1_B6 RES 6,(IX+x) 
  FD_CB_x1_B6 RES 6,(IY+x) 
  CB_B0       RES 6,B|6,C|6,D|6,E|6,H|6,L|6,(HL)|6,A 
  DD_CB_x1_BE RES 7,(IX+x) 
  FD_CB_x1_BE RES 7,(IY+x) 
  CB_B8       RES 7,B|7,C|7,D|7,E|7,H|7,L|7,(HL)|7,A 
  C9          RET 
  D8          RET C 
  F8          RET M 
  D0          RET NC 
  C0          RET NZ 
  F0          RET P 
  E8          RET PE 
  E0          RET PO 
  C8          RET Z 
  ED_4D       RETI 
  ED_45       RETN 
  DD_CB_x1_16 RL (IX+x) 
  FD_CB_x1_16 RL (IY+x) 
  CB_10       RL B|C|D|E|H|L|(HL)|A 
  17          RLA 
  DD_CB_x1_06 RLC (IX+x) 
  FD_CB_x1_06 RLC (IY+x) 
  CB_00       RLC B|C|D|E|H|L|(HL)|A 
  07          RLCA 
  ED_6F       RLD 
  DD_CB_x1_1E RR (IX+x) 
  FD_CB_x1_1E RR (IY+x) 
  CB_18       RR B|C|D|E|H|L|(HL)|A 
  DD_CB_x1_0E RRC (IX+x) 
  FD_CB_x1_0E RRC (IY+x) 
  CB_08       RRC B|C|D|E|H|L|(HL)|A 
  0F          RRCA 
  ED_67       RRD 
  1F          RRA 
  C7          RST 0 
  C7          RST 00H 
  CF          RST 08H 
  C7          RST 0H 
  D7          RST 10H 
  D7          RST 16 
  DF          RST 18H 
  E7          RST 20H 
  DF          RST 24 
  EF          RST 28H 
  F7          RST 30H 
  E7          RST 32 
  FF          RST 38H 
  EF          RST 40 
  F7          RST 48 
  FF          RST 56 
  CF          RST 8 
  CF          RST 8H 
  DD_9E_x1    SBC A,(IX+x) 
  FD_9E_x1    SBC A,(IY+x) 
  98          SBC A,B|A,C|A,D|A,E|A,H|A,L|A,(HL)|A,A 
  DE_x1       SBC A,x 
  ED_42       SBC HL,BC 
  ED_52       SBC HL,DE 
  ED_62       SBC HL,HL 
  ED_72       SBC HL,SP 
  37          SCF 
  DD_CB_x1 C6 SET 0,(IX+x) 
  FD_CB_x1_C6 SET 0,(IY+x) 
  CB_C0       SET 0,B|0,C|0,D|0,E|0,H|0,L|0,(HL)|0,A 
  DD_CB_x1_CE SET 1,(IX+x) 
  FD_CB_x1_CE SET 1,(IY+x) 
  CB_C8       SET 1,B|1,C|1,D|1,E|1,H|1,L|1,(HL)|1,A 
  DD_CB_x1_D6 SET 2,(IX+x) 
  FD_CB_x1_D6 SET 2,(IY+x) 
  CB_D0       SET 2,B|2,C|2,D|2,E|2,H|2,L|2,(HL)|2,A 
  DD_CB_x1_DE SET 3,(IX+x) 
  FD_CB_x1_DE SET 3,(IY+x) 
  CB_D8       SET 3,B|3,C|3,D|3,E|3,H|3,L|3,(HL)|3,A 
  DD_CB_x1_E6 SET 4,(IX+x) 
  FD_CB_x1_E6 SET 4,(IY+x) 
  CB_E0       SET 4,B|4,C|4,D|4,E|4,H|4,L|4,(HL)|4,A 
  DD_CB_x1_EE SET 5,(IX+x) 
  FD_CB_x1_EE SET 5,(IY+x) 
  CB_E8       SET 5,B|5,C|5,D|5,E|5,H|5,L|5,(HL)|5,A 
  DD_CB_x1_F6 SET 6,(IX+x) 
  FD_CB_x1_F6 SET 6,(IY+x) 
  CB_F0       SET 6,B|6,C|6,D|6,E|6,H|6,L|6,(HL)|6,A 
  DD_CB_x1_FE SET 7,(IX+x) 
  FD_CB_x1_FE SET 7,(IY+x) 
  CB_F8       SET 7,B|7,C|7,D|7,E|7,H|7,L|7,(HL)|7,A 
  DD_CB_x1_26 SLA (IX+x) 
  FD_CB_x1_26 SLA (IY+x) 
  CB_20       SLA B|C|D|E|H|L|(HL)|A 
  DD_CB_x1_2E SRA (IX+x) 
  FD_CB_x1_2E SRA (IY+x) 
  CB_28       SRA B|C|D|E|H|L|(HL)|A 
  DD_CB_x1_3E SRL (IX+x) 
  FD_CB_x1_3E SRL (IY+x) 
  CB_38       SRL B|C|D|E|H|L|(HL)|A 
  DD_96_x1    SUB A,(IX+x) 
  FD_96_x1    SUB A,(IY+x) 
  90_         SUB A,B|A,C|A,D|A,E|A,H|A,L|A,(HL)|A,A 
  D6_x1       SUB x 
  DD_AE_x1    XOR (IX+x) 
  FD_AE_x1    XOR (IY+x) 
  A8          XOR B|C|D|E|H|L|(HL)|A 
  EE_x1       XOR x 
</PRE> 
<P>
<CENTER> Return to <a href="../toc.htm">Table of Contents
</a>
</CENTER>
<P>
</HTML> 
